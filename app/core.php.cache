<?php
namespace phpex\Library{
use phpex\Foundation\Session;
use phpex\Loader\ConfigureInterface;
use phpex\Library\RouteInterface;
interface AppInterface {
    public function loadConfig(ConfigureInterface $Configure);
    public function loadRoute(RouteInterface $route);
    public function getRouteConfig();
    public function getRoot();
    public function getName();
    public function getPublicName();
    public function getSessionName();
    public function getTheme();
    public function run($controller, $action, array $parameters = array());
    public function initSession();
    public function installInstance(Instance $instance);
    public function getNamespace();
    public function getRunController();
}
}
namespace phpex\Library{
use phpex\Loader\ConfigureInterface;
use phpex\Library\RouteInterface;
use phpex\Foundation\Session;
use phpex\Access\Access;
use phpex\Foundation\Response;
abstract class App implements AppInterface {
    protected $sessionName;
    protected $root;
    protected $namespace;
    
    protected $reflection;
    protected $runController;
    public function getRoot() {
        if (null === $this->root) {
            $this->root = dirname($this->reflection->getFileName());
        }
        return $this->root;
    }
    public function __construct() {
        $this->reflection = new \ReflectionObject($this);
    }
    public function getRouteConfig() {
        return new RouteConfig();
    }
    public function loadRoute(RouteInterface $route) {
        $route->loadRoute($this->getRoot() . "/Conf/route.yml", $this->getRouteConfig());
    }
    public function loadConfig(ConfigureInterface $Configure) {
        $Configure->load($this->getRoot() . "/Conf/config.yml", $this->getName());
    }
    public function installInstance(Instance $instance) {
    }
    public function getPublicName() {
        return $this->getName();
    }
    public function getSessionName() {
        if (null === $this->sessionName) {
            $this->sessionName = main()->getName() . "_" . $this->getName() . "_phpid";
        }
        return $this->sessionName;
    }
    public function getTheme() {
        return "default";
    }
    public function initSession($config = array()) {
        if (Q()->getSession()) {
            return;
        }
        $sessionConfig = array(
            "session_auto_start" => false,
            "session_name" => $this->getSessionName(),
            "cookie_domain" => NULL,
            "session_path" => NULL,
            "session_callback" => NULL,
        );
        $session = new Session(array_merge($sessionConfig, $config));
        if (Q()->get->has($this->getSessionName())) {
            $session->session_id(Q()->get->get($this->getSessionName()));
        } elseif (Q()->post->has($this->getSessionName())) {
            $session->session_id(Q()->post->get($this->getSessionName()));
        } elseif (Q()->cookies->has($this->getSessionName())) {
            $session->session_id(Q()->cookies->get($this->getSessionName()));
        }
        $timeout = isset($config["session_timeout"]) ? intval($config["session_timeout"]) : 0;
        if ($timeout) {
            session_set_cookie_params($timeout,"/");
            ini_set("session.gc_maxlifetime", $timeout);
            $session_id = $session->session_id();
            $session_file = $session->path() . "/sess_" . $session_id;
            if ($session_id && is_file($session_file) && filemtime($session_file) < time() - $timeout) {
                @unlink($session_file);
            }
        }
        if (!$session->isStarted())
            $session->start();
        Q()->setSession($session);
    }
    public function run($controller, $action, array $parameters = array()) {
        $this->initSession(C("session"));
        $classname = $this->getNamespace() . "\\Controller\\{$controller}Controller";
        try {
            $ref = new \ReflectionClass($classname);
        } catch (\Exception $ex) {
            E("The controller does not exist for '%s',message:'%s'", $controller, $ex->getMessage());
        }
        if (!$ref->isInstantiable()) {
            E("The controller does not instantiable for '%s'", $classname);
        }
        $object = $ref->newInstance();
        $access = new Access($controller, $action, $parameters);
        $access->setLoginUrl($this->getLoginUrl());
        $this->buildAccess($access);
        $object->setAccess($access);
        if ($ref->isSubclassOf("phpex\\Access\\AccessInterface")) {
            $response = $access->getResponse();
            if ($response instanceof Response)
                return $response;
        }
        $refo = new \ReflectionObject($object);
        if (!$refo->hasMethod($action)) {
            E("The requested method does not exist: %s::%s", $classname, $action);
        }
        $method = $refo->getMethod($action);
        if (!$method->isPublic() || $method->isStatic()) {
            throws("The requested method does not access: %s::%s ", $method->getFileName(), $method->getStartLine(), "", $classname, $action);
        }
        $methodParameters = $method->getParameters();
        $pargs = array();
        foreach ($methodParameters as $index => $parameter) {
            $name = $parameter->getName();
            if (isset($parameters[$name]))
                $pargs[$index] = $parameters[$name];
            elseif ($parameter->isDefaultValueAvailable())
                $pargs[$index] = $parameter->getDefaultValue();
            else
                E("Please pass in routing parameters: %s::%s for %s,see route to '%s'", $classname, $action, $name, R()->getRunRoute());
        }
        if ($ref->hasProperty("access")) {
            $accessProperty = $ref->getProperty("access");
            $accessProperty->setAccessible(true);
            $accessProperty->setValue($object, $access);
        }
        $this->runController = $object;
        unset($methodParameters, $ref, $refo);
        return $method->invokeArgs($object, $pargs);
    }
    public function getLoginUrl() {
    }
    protected function buildAccess(Access $access) {
    }
    public function isAutoBuild() {
        return true;
    }
    public function getNamespace() {
        if (null === $this->namespace) {
            $this->namespace = $this->reflection->getNamespaceName();
        }
        return $this->namespace;
    }
    public function getRunController() {
        return $this->runController;
    }
}
}
namespace phpex\Library{
class Build {
    protected static $directorys = array(
        "/Common",
        "/Conf",
        "/Controller",
        "/Event",
        "/Service",
        "/View",
        "/View/#theme#",
        "/View/#theme#Index",
        "/View/#theme#Public",
    );
    protected static $files = array(
        "/Common/function.php" => "createFunction",
        "/Conf/access.yml" => "createAccess",
        "/Conf/config.yml" => "createConf",
        "/Conf/route.yml" => "createRoute",
        "/Conf/role.yml" => "createRole",
        "/Controller/CommonController.php" => "createCommonController",
        "/Controller/IndexController.php" => "createIndexController",
        "/View/#theme#/Index/index.latte" => "createIndexLatte",
    );
    protected static $appTemplate = <<<app
<?php
namespace #App#;
use phpex\Library\App;
class #App#App extends App {
            
    public function getName() {
        return "#app#";
    }
}
app;
    protected static $IndexControllerTemplate = <<<late
<?php
namespace #App#\Controller;
            
class IndexController extends CommonController{
            
    public function index() { 
        //控制器示例代码
        return \$this->display();
    }
}
late;
    protected static $CommonControllerTemplate = <<<late
<?php
namespace #App#\Controller;
use phpex\Library\Controller;  
    
abstract class CommonController extends Controller{
            
    protected function _initialize() {
        
    }  
}
late;
    protected static $IndexLatteTemplate = <<<late
<style type="text/css">
    *{ padding: 0; margin: 0; } 
    div{ padding: 4px 48px;} 
    body{ background: #fff; font-family: "微软雅黑"; color: #333;font-size:24px} 
    h1{ font-size: 100px; font-weight: normal; margin-bottom: 12px; } 
    p{ line-height: 1.8em; font-size: 36px }
</style>
<div style="padding: 24px 48px;"> 
    <h1>^_^</h1>
    <p>您现在访问的是[#App#]模块下[IndexController]控制器中的[index]方法</p>
    <p>欢迎使用 <b>phpex</b>！</p><br/>
</div>
late;
    protected static $RouteTemplate = <<<late
#app#_index_index:
    pattern: /
    callback: "#App#:Index:index"    
    method: get   
    options:
late;
    static function buildAppList(MainInterface $main) {
        $appLists = $main->getAppList();
        $config = C();
        $ins = ins();
        foreach ($appLists as $name) {
            
            $app = ($main->getEnv() == "dev") ? self::createApp($name, $main) : self::newApp($name, $main);
            $app->loadConfig($config);
            \Composer\Autoload\includeFile($app->getRoot() . "/Common/function.php");
            $app->installInstance($ins);
            $ins->addInstance("app.$name", $app, array("app"));
        }
    }
    static protected function createApp($name, MainInterface $main) {
        $appClass = "$name\\{$name}App";
        $pathRoot = $main->getAppRoot() . "/$name";
        if (!class_exists($appClass)) {
            $path = "{$pathRoot}/{$name}App.php";
            if (!is_dir($pathRoot) && !mkdir($pathRoot, 777, true)) {
                E("Unable to create directory '%s'", $pathRoot);
            }
            if (!is_file($path)) {
                $hand = fopen($path, "c+");
                flock($hand, LOCK_SH);
                if (!$hand) {
                    E("Unable to open or create app '%s'", $appClass);
                } else {
                    ftruncate($hand, 0);
                    flock($hand, LOCK_EX);
                    $code = str_replace(array("#App#", "#app#"), array($name, lcfirst($name)), self::$appTemplate);
                    if (fwrite($hand, $code, strlen($code)) !== strlen($code)) {
                        ftruncate($hand, 0);
                        E("Unable to create app '%s'", $appClass);
                    }
                    flock($hand, LOCK_SH);
                    fclose($hand);
                }
            }
            include $path;
        }
        
        $app = new $appClass();
        if (!$app->isAutoBuild()) {
            return $app;
        }
        $theme = $app->getTheme() ? $app->getTheme() . "/" : "";
        foreach (self::$directorys as $directory) {
            $directoryPath = $pathRoot . str_replace(array("#theme#"), array($theme), $directory);
            if (!is_dir($directoryPath) && !mkdir($directoryPath, 0777, true)) {
                E("Unable to create directory '%s'", $directoryPath);
            }
        }
        foreach (self::$files as $file => $create) {
            $filePath = $pathRoot . str_replace(array("#theme#"), array($theme), $file);
            if (is_file($filePath)) {
                continue;
            }
            $fhand = fopen($filePath, "c+");
            if (!$fhand) {
                E("Unable to open or create file '%s'", $filePath);
            }
            flock($fhand, LOCK_SH);
            if (filesize($filePath) == 0) {
                ftruncate($fhand, 0);
                flock($fhand, LOCK_EX);
                $code = self::$create($name);
                if (fwrite($fhand, $code, strlen($code)) !== strlen($code)) {
                    E("Unable to create file '%s'", $filePath);
                }
                flock($fhand, LOCK_SH);
            }
            fclose($fhand);
        }
        return $app;
    }
    static protected function newApp($name, MainInterface $main) {
        $appClass = "$name\\{$name}App";
        if (!class_exists($appClass)) {
            E("Unable to create app '%s'", $appClass);
        }
        return new $appClass();
    }
    static protected function createFunction($name) {
        return "<?php\n//$name function";
    }
    static protected function createAccess($name) {
        return "#//$name Access";
    }
    static protected function createConf($name) {
        return "#//$name Conf";
    }
    static protected function createRoute($name) {
        return "#//$name route\n" . str_replace(array("#App#", "#app#"), array($name, lcfirst($name)), self::$RouteTemplate);
    }
    static protected function createRole($name) {
        return "#//$name role\n";
    }
    static protected function createCommonController($name) {
        return str_replace(array("#App#", "#app#"), array($name, lcfirst($name)), self::$CommonControllerTemplate);
    }
    static protected function createIndexController($name) {
        return str_replace(array("#App#", "#app#"), array($name, lcfirst($name)), self::$IndexControllerTemplate);
    }
    static protected function createIndexLatte($name) {
        return str_replace(array("#App#", "#app#"), array($name, lcfirst($name)), self::$IndexLatteTemplate);
    }
}
}
namespace phpex\Library{
use phpex\Foundation\Response;
use phpex\Library\View;
use phpex\Access\Access;
abstract class Controller {
    
    protected $view;
    
    protected $access;
    
    private $response;
    protected $debug = false;
    
    private $searches = array();
    public function get($name) {
        return ins()->get($name);
    }
    
    public static function _new() {
    }
    public function setAccess(Access $access) {
        $this->access = $access;
        $this->autoCreateDModel();
        $this->_initialize();
    }
    
    public function getView() {
        if (null === $this->view) {
            if (!ins()->has("core.view")) {
                $this->view = new View();
                ins()->addInstance("core.view", $this->view);
            } else {
                $this->view = ins()->get("core.view");
            }
        }
        return $this->view;
    }
    public function assign($key, $val = '') {
        $this->getView()->assign($key, $val);
    }
    public function openDebug() {
        $this->debug = true;
    }
    public function getAssign($key = '') {
        return $this->getView()->getAssign($key);
    }
    protected function _initialize() {
    }
    protected function redirect($url, $msg = "", $time = 0, $status = 302) {
        if (R()->has($url))
            $url = url($url);
        if (empty($url)) {
            throw new \InvalidArgumentException('Cannot redirect to an empty URL.');
        }
        $response = new Response();
        $response->setStatusCode($status);
        if ($time > 0)
            $response->setContent(
                sprintf('<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta http-equiv="refresh" content="%3$d;url=%1$s" />
        <title>Redirecting to %1$s</title>
    </head>
    <body>
    <h1>%2$s</h1>
    <p>系统将在%3$d秒之后自动跳转到 <a href="%1$s">%1$s</a>！</p>      
    </body>
</html>', htmlspecialchars($url, ENT_QUOTES, 'UTF-8'), $msg ?: "Redirecting", $time));
        $response->headers->set('Location', $url);
        if (!$response->isRedirect()) {
            throw new \InvalidArgumentException(sprintf('The HTTP status code is not a redirect ("%s" given).', $status));
        }
        return $response;
    }
    
    protected function getResponse($content = "", $status = 200) {
        if (null === $this->response) {
            $contentType = C("response.contentType");
            $charset = C("response.charset");
            $headers = array("Content-Type" => $contentType . ";charset=" . $charset);
            $this->response = new Response("", $status, $headers);
        }
        $this->response->setContent($content);
        return $this->response;
    }
    protected function show($content) {
        $content = $this->getView()->parse($content);
        $this->getResponse()->setContent($content);
        return $this->response;
    }
    
    protected function fetch($templateFile = "", array $assign = null) {
        return $this->getView()->fetch($templateFile, $assign);
    }
    
    protected function display($templateFile = '', array $assign = null, $main = true) {
        $content = $this->fetch($templateFile, $assign);
        if ($main)
            $this->addJumpTips($content);
        $this->getResponse();
        if ($main && Q()->server->has('HTTP_ACCEPT_ENCODING') && false !== strpos(Q()->server->get("HTTP_ACCEPT_ENCODING"), "gzip") && extension_loaded("zlib")) {
            $content = gzencode($content, 9);
            $this->response->headers->set("Content-Encoding", "gzip");
            $this->response->headers->set("Vary", "Accept-Encoding");
            $this->response->headers->set("Content-Length", strlen($content));
        }
        $this->response->setContent($content);
        if (!$this->response->getCharset())
            $this->response->setCharset(C("response.charset"));
        return $this->response;
    }
    
    protected function success($message = '', $jumpUrl = '', $time = 1, $tpl = "success_tpl") {
        if ($jumpUrl === "") {
            $jumpUrl = $this->getRequest()->server->get("HTTP_REFERER");
        }
        if (Q()->isAjax()) {
            return $this->ajaxReturn(array("status" => "y", "data" => $message));
        }
        $app_core_controller_jump_tips = array(
            "status" => "success",
            "tpl" => $tpl,
            "time" => $time,
            "interval" => 1000,
            "referer" => Q()->getUri(),
            "title" => array("操作成功", "操作失败"),
            "msg" => $message
        );
        $this->setSession("app_core_controller_jump_tips", $app_core_controller_jump_tips);
        return $this->redirect($jumpUrl);
    }
    
    protected function error($message = '', $jumpUrl = '', $time = 3, $tpl = "error_tpl") {
        if ($jumpUrl === "") {
            $jumpUrl = $this->getRequest()->server->get("HTTP_REFERER");
        }
        if (Q()->isAjax()) {
            return $this->ajaxReturn(array("status" => "n", "info" => $message));
        }
        if ($this->debug) {
            $debug = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS);
            $from = "<pre><b>" . dirtrim($debug[0]["file"]) . ";line:" . $debug[0]["line"] . "</b>\n";
            return $this->show($from . $message . "</pre>");
        }
        $app_core_controller_jump_tips = array(
            "status" => "error",
            "tpl" => $tpl,
            "time" => $time,
            "interval" => 1000,
            "referer" => Q()->getUri(),
            "title" => array("操作成功", "操作失败"),
            "msg" => $message
        );
        $this->setSession("app_core_controller_jump_tips", $app_core_controller_jump_tips);
        return $this->redirect($jumpUrl);
    }
    protected function fail($message) {
        $this->assign("message", $message);
        return $this->display(C("template.fail") ?: C("view.fail"));
    }
    private function addJumpTips(&$content) {
        if (!Q()->getSession() || !Q()->getSession()->has("app_core_controller_jump_tips"))
            return;
        $app_core_controller_jump_tips = Q()->getSession()->get("app_core_controller_jump_tips");
        $file = C("view." . $app_core_controller_jump_tips["tpl"]);
        $tips = $this->getView()->fetch($file, (array)$app_core_controller_jump_tips);
        Q()->getSession()->remove("app_core_controller_jump_tips");
        Q()->getSession()->save();
        if (!$tips)
            return;
        $content = str_replace("</body>", $tips . "</body>", $content);
    }
    protected function ajaxResponse() {
    }
    protected function ajaxReturn($data, $type = "") {
        if (empty($type))
            $type = C('response.ajax_type');
        switch (strtoupper($type)) {
            case 'XML' :
                $headers = array("Content-Type" => "text/xml;charset=utf-8");
                return new Response(xml_encode($data), 200, $headers);
            case 'JSONP':
                                $handler = isset($_GET[C('response.jsonpHandlerVar')]) ? $_GET[C('response.jsonpHandlerVar')] : C('response.jsonpHandler');
                $headers = array("Content-Type" => C('response.jsonContentType') . ";charset=utf-8");
                return new Response($handler . '(' . json_encode($data) . ');', 200, $headers);
            case 'EVAL' :
                                $headers = array("Content-Type" => "text/html;charset=utf-8");
                return new Response(json_encode($data), 200, $headers);
            case 'CORS' :
                $headers = array(
                    "Content-Type" => C('response.jsonContentType') . ";charset=utf-8",
                    "Access-Control-Allow-Origin" => "*",
                    "Access-Control-Allow-Methods" => "GET,POST,OPTIONS",
                    "Access-Control-Allow-Credentials" => "true",
                    "Access-Control-Allow-Headers" => "x-requested-with,content-type"
                );
                return new Response(json_encode($data), 200, $headers);
            case 'JSON' :
            default;
                                $headers = array("Content-Type" => C('response.jsonContentType') . ";charset=utf-8");
                return new Response(json_encode($data), 200, $headers);
        }
    }
    
    protected function getUser($key = null) {
        return $this->access->getUser($key);
    }
    protected function getRequest() {
        return Q();
    }
    protected function setSession($key, $value) {
        Q()->getSession()->set($key, $value)->save();
        return $this;
    }
    
    protected function form($name, $action = "", $method = "post") {
        return new \phpex\Helper\Form\Form($name, $action, $method);
    }
    
    final protected function search($name = "search") {
        if (!isset($this->searches[$name]))
            $this->searches[$name] = new \phpex\Helper\Search\Search($this);
        return $this->searches[$name];
    }
    protected function flushUser() {
        $this->access->flushUser();
    }
    protected function autoCreateDModel() {
        $objRef = new \ReflectionClass($this);
        $vars = $objRef->getProperties(\ReflectionProperty::IS_PUBLIC | \ReflectionProperty::IS_PROTECTED);
        $docMatch = array();
        foreach ($vars as $var) {
            $doc = $var->getDocComment();
            if (!$doc) {
                continue;
            }
            if (preg_match("#^\s*\*\s+@var\s+(?<class>\\\\Admin\\\\DModel\\\\[A-Z][a-zA-Z_0-9]+DModel)\s*$#m", $doc, $docMatch)) {
                $this->{$var->name} = new $docMatch["class"];
            }
        }
    }
}
}
namespace phpex\Library{
class Instance {
    private $instances = array();
    private $tags = array();
    private static $instance;
    private function __construct() {
        
    }
    
    public static function getInstance() {
        if (null === self::$instance) {
            self::$instance = new static();
        }
        return self::$instance;
    }
    
    public function newInstance($name, $class, array $parameters = array(), array $tags = array()) {
        if (isset($this->instances[$name])) {
            E(sprintf("Add instance is not allowed to repeat:%s", $name));
        }
        class_exists($class) or E(sprintf("Class not found:%s", $class));
        $refClass = new \ReflectionClass($class);
        $this->instances[$name] = $refClass->newInstanceArgs($parameters);
        foreach ($tags as $tag) {
            if ($this->tags[$tag] && in_array($this->instances[$name], $this->tags[$tag]))
                continue;
            $this->tags[$tag][] = $this->instances[$name];
        }
        return $this;
    }
    
    public function addInstance($name, $object, array $tags = array()) {
        if (isset($this->instances[$name])) {
            E(sprintf("Add instance is not allowed to repeat:%s", $name));
        }
        if (!is_object($object) || is_null($object))
            E(sprintf("Must for an object instance:%s", $name));
        $this->instances[$name] = $object;
        foreach ($tags as $tag) {
            if (isset($this->tags[$tag]) && in_array($object, $this->tags[$tag]))
                continue;
            $this->tags[$tag][] = $object;
        }
        return $this;
    }
    
    public function addTags($name, $tag) {
        if (!isset($this->instances[$name])) {
            E(sprintf("There is no instance:%s", $name));
        }
        if ($this->tags[$tag] && in_array($this->instances[$name], $this->tags[$tag]))
            return $this;
        $this->tags[$tag][] = $this->instances[$name];
        return $this;
    }
    
    public function get($name) {
        if (!isset($this->instances[$name])) {
            E(sprintf("There is no instance:%s", $name));
        }
        return $this->instances[$name];
    }
    
    public function getTag($tag) {
        return isset($this->tags[$tag]) ? $this->tags[$tag] : array();
    }
    public function install($InstanceList) {
        
    }
    public function has($name) {
        return isset($this->instances[$name]);
    }
}
}
namespace phpex\Library{
use phpex\Loader\ConfigureInterface;
use phpex\Error\ErrorHandler;
use phpex\Foundation\Response;
use phpex\Event\EventContainer;
use phpex\Console\Application;
use phpex\Foundation\Session;
interface MainInterface {
    public function getAppList();
    
    public function boot();
    
    public function getLogDir();
    
    public function addCommands(Application $application);
    
    public function loadConfig(ConfigureInterface $loader);
    
    public function run();
    
    public function registerErrorHandler(ErrorHandler $ErrorHandler);
    
    public function getEnv();
    
    public function getAppRoot();
    
    public function getRuntime();
    
    public function getVendorRoot();
    
    public function getName();
}
}
namespace phpex\Library{
use phpex\Error\ErrorHandler;
use phpex\Foundation\Response;
use phpex\Console\Application;
use phpex\Console\CommandFind;
abstract class Main implements MainInterface {
    const VERSION = '1.0.0';
    protected $build = array("phpex\\Library\\Build", "buildAppList");
    private $appRootDir;
    private $native_debug = false;
    private $appLists = array();
    private $vendorRootDir;
    private $mainRootDir;
    private $environment;
    private $debug;
    private $booted = false;
    private $commands = array();
    private $sessionConfig = array();
    public function __construct($environment, $debug = false) {
        $this->environment = $environment;
        $this->debug = (bool)$debug;
        ins()->addInstance("core.main", $this);
        if ($debug === 1) {
            $this->native_debug = true;
        }
        $this->registerErrorHandler(new ErrorHandler);
    }
    
    public function registerErrorHandler(ErrorHandler $ErrorHandler) {
        if ($this->native_debug) {
            error_reporting(E_ALL);
            return;
        }
        error_reporting(0);        $ErrorHandler->register_shutdown_function(array('phpex\\Error\\phpexError', 'fatalError'));
        $ErrorHandler->set_error_handler(array('phpex\\Error\\phpexError', 'appError'));
        $ErrorHandler->set_exception_handler(array('phpex\\Error\\phpexError', 'appException'));
    }
    
    public function run() {
        $this->boot();
        
        $apps = ins()->getTag("app");
        $route = R();
        foreach ($apps as $app) {
            $app->loadRoute($route);
        }
        $response = $route->dispatch()->getResponse();
        if (is_object($response) && $response instanceof Response)
            return $response;
        E("The controller must return a response (%s given). Did you forget to add a return statement somewhere in your controller", typeof($response));
    }
    
    public function boot() {
        if (!$this->booted) {
            ins()->newInstance("core.event", "phpex\\Event\\EventContainer");
            ins()->newInstance("core.config", "phpex\Loader\\Configure");
            $config = C();
            $config->load($this->getMainRoot() . "/Common/general.yml");
            $this->loadConfig($config);
            if ($config->has("service"))
                ins()->install($config->get("service"));
            $this->_initialize();
            call_user_func($this->build, $this);
            $this->booted = true;
        }
        return true;
    }
    protected function _initialize() {
    }
    
    public function addCommands(Application $application) {
        $command_path = $this->getMainRoot() . "/Command";
        $commandFind = new CommandFind();
        $commandFind->find("phpex", $command_path);
        $apps = ins()->getTag("app");
        foreach ($apps as $app) {
            list($namespace) = explode("\\", get_class($app));
            $commandFind->find($namespace, $app->getRoot() . "/Command");
        }
        $application->addCommands($commandFind->getCommands());
    }
    
    public function getEnv() {
        return $this->environment;
    }
    
    public function getDebug() {
        return $this->debug;
    }
    
    public function getAppRoot() {
        if (null === $this->appRootDir) {
            $r = new \ReflectionObject($this);
            $this->appRootDir = str_replace('\\', '/', dirname($r->getFileName()));
        }
        return $this->appRootDir;
    }
    
    public function getRuntime() {
        return dirname($this->getVendorRoot()) . "/runtime";
    }
    
    public function getLogDir() {
        return $this->getRuntime() . "/Logs";
    }
    
    public function getVendorRoot() {
        if (null === $this->vendorRootDir) {
            $ref = new \ReflectionClass("Composer\Autoload\ClassLoader");
            $this->vendorRootDir = dirname(dirname($ref->getFileName()));
        }
        return $this->vendorRootDir;
    }
    public function getMainRoot() {
        if (null === $this->mainRootDir) {
            
            $load = ins()->get("core.autoload");
            $prefixes = $load->getPrefixes();
            $this->mainRootDir = str_replace('\\', '/', $prefixes["phpex\\"][0]) . "/phpex";
        }
        return $this->mainRootDir;
    }
}
}
namespace phpex\Library{
use phpex\Foundation\Request;
interface RouteInterface {
    public static function getInstance();
    public function setCacheDir($cacheDir = "");
    public function loadCache($path = "");
    public function loadRoute($path = "", RouteConfig $couteConfig = null);
    public function add($name, $pattern, $callback, $method = "any", $extra = array());
    public function setRequest(Request $request);
    public function dispatch($pathinfo = "");
    public function getController();
    public function getAction();
    public function getParameter();
    public function getResponse();
}
}
namespace phpex\Library{
use phpex\Foundation\Request;
use phpex\Error\phpexError;
class Route implements RouteInterface {
    const ROUTE_NORMAL = 1;
    const ROUTE_PATHINFO = 2;
    const ROUTE_REWRITE = 4;
    private $methods = array(
        "GET" => 1,
        "POST" => 2,
        "PUT" => 4,
        "DELETE" => 8,
        "HEAD" => 16,
    );
    private static $instance;
    
    private $modePaths = array();
    
    private $request;
    
    private $options = array(
        "cacheDir" => "RouteCache",
        "var_name" => "r",
        "encrypt" => "Encryption",
        "key" => "phpex",
        'route_mode' => Route::ROUTE_PATHINFO
    );
    private $App, $Controller, $Action, $Parameter, $RunRoute;
    private $routeOptions = array(
        'prefix' => '',
        'domain' => "",
        'encrypt' => '',
        'path' => '',
        'secure' => 0,
        'route_mode' => Route::ROUTE_PATHINFO,
        'require' => array(),
        'default' => array(),
    );
    private $defaultParameter = array();
    
    private $Response;
    private $lists = array();
    private $pathInfo;
    private function __construct(Request $request = null, $cacheDir = "", $var_name = "r", $encrypt = "Encryption", $key = "phpex") {
        $this->request = $request;
        $cacheDir and $this->options['cacheDir'] = $cacheDir;
        $this->options['var_name'] = $var_name;
        $this->options['encrypt'] = $encrypt;
        $this->options['key'] = $key;
        $this->options['route_mode'] = C('route.url_mode');
        $script_name = $this->request->server->get("SCRIPT_NAME");
        $script_name = $this->trimdir($script_name);
        $this->modePaths[Route::ROUTE_NORMAL] =
        $this->modePaths[Route::ROUTE_PATHINFO] = $script_name;
        $this->modePaths[Route::ROUTE_REWRITE] = $this->dir_name($script_name);
    }
    private function trimdir($dir_name) {
        return preg_replace("#[\\\\/]{2,}#", "/", $dir_name);
    }
    private function dir_name($path) {
        $basename = basename($path);
        return $this->trimdir(substr($path, 0, 0 - strlen($basename)));
    }
    
    public static function getInstance() {
        if (null === self::$instance) {
            self::$instance = new static(Q(), C("route.cache"), C("route.var_name"), C("route.encrypt"), C("route.encrypt_key"));
        }
        return self::$instance;
    }
    public function add($name, $pattern, $call, $method = "any", $extra = array()) {
        $methods = 0;
        if (empty($method) || $method == "any") {
            $methods = array_sum($this->methods);
        } else {
            $eMethod = explode("|", strtoupper($method));
            foreach ($eMethod as $m) {
                $methods = $methods | $this->methods[$m];
            }
            unset($eMethod);
        }
        $params = array();
        $callback = function ($match) use (&$params) {
            $params[$match[1]] = "";
            return "(?<{$match[1]}>[a-zA-Z0-9_]+)";
        };
        $match = preg_replace_callback("/\:([a-zA-Z0-9_]+)/", $callback, rtrim($extra["prefix"] . $pattern, "/"));
        $this->lists[$name] = array(
            "pattern" => $extra["prefix"] . $pattern,
            "match" => "/^" . str_replace("/", "\/", $match) . "$/",
            "method" => $methods,
            "callback" => $call,
            "params" => $params,
            "extra" => $extra
        );
    }
    
    public function dispatch($pathInfo = "", $m = false) {
        if ($pathInfo) {
            $this->pathInfo = $pathInfo;
        } else {
            $pathInfo = $this->pathInfo = $this->request->getPathInfo() ?: $this->request->get->get($this->options["var_name"]);
        }
        $method = $m === false ? $this->methods[$this->request->getMethod()] : $m;
        $callBack = array();
        $paramscount = -1;
        $lists = $this->lists;
        uksort($this->lists, function ($a, $b) use ($lists) {
            return (strlen($lists[$a]['pattern']) < strlen($lists[$b]['pattern']));
        });
        unset($lists);
        foreach ($this->lists as $name => $route) {
            if ($route["extra"]["domain"] && $route["extra"]["domain"] != $this->request->getHttpHost()) {
                                continue;
            }
            if ($route["extra"]["secure"] !== null && $route["extra"]["secure"] != $this->request->isSecure()) {
                                if ($route["extra"] !== 0)
                    continue;
            }
            if (!($route["method"] & $method)) {
                                continue;
            }
            $path = $pathInfo;
            if ($route["extra"]["encrypt"]) {
                $path = $this->deEncrypt($route["extra"]["encrypt"]);
            }
                        if (preg_match($route["match"], rtrim($path, "/"), $match)) {                $params = array();
                foreach ($route["params"] as $key => $param) {                    if (isset($match[$key])) {
                        $params[$key] = $match[$key];
                    } elseif (isset($route["extra"]["default"][$key])) {
                        $params[$key] = $route["extra"]["default"][$key];
                    }
                }
                $hasrequire = true;
                foreach ($route["extra"]["require"] ?: array() as $require => $requireMatch) {                    if (!isset($params[$require]) || !preg_match("/^{$requireMatch}$/", $params[$require])) {
                        $hasrequire = false;
                        break;
                    }
                }
                if (!$hasrequire)
                    continue;
                if (count($params) == 0) {                     $callBack = array(
                        "name" => $name,
                        "callback" => $route["callback"],
                        "params" => $params,
                    );
                    break;
                } elseif ($paramscount == -1) {                    $callBack = array(
                        "name" => $name,
                        "callback" => $route["callback"],
                        "params" => $params,
                    );
                    $paramscount = count($params);
                } elseif (count($params) < $paramscount) {                    $callBack = array(
                        "name" => $name,
                        "callback" => $route["callback"],
                        "params" => $params,
                    );
                    $paramscount = count($params);
                }
            }
        }
        if (empty($callBack)) {
            phpexError::$httpStatus = 404;
            E("Not found the callback for '%s'", $pathInfo);
        }
        if ($callBack["params"] && (FALSE !== strpos($callBack["callback"], "{"))) {
            $finds = $replaces = array();
            foreach ($callBack["params"] as $find => $replace) {
                $finds[] = "{{$find}}";
                $replaces[] = $replace;
            }
            $callBack["callback"] = str_replace($finds, $replaces, $callBack["callback"]);
        }
        list($this->App, $this->Controller, $this->Action) = explode(":", $callBack["callback"]);
        
        $app = ins()->get("app." . ucfirst($this->App));
        $this->Parameter = $callBack["params"];
        $this->RunRoute = $callBack['name'];
        $this->Response = $app->run(ucfirst($this->Controller), $this->Action, $callBack["params"]);
        unset($callBack);
        return $this;
    }
    private function deEncrypt($encrypt) {
                return $encrypt;
    }
    public function getMethods() {
        return $this->methods;
    }
    private function enEncrypt($input, $encrypt) {
                return $input;
    }
    public function getAction() {
        return $this->Action;
    }
    public function getAppName() {
        return $this->App;
    }
    public function getController() {
        return $this->Controller;
    }
    public function getParameter() {
        return $this->Parameter;
    }
    public function getDefaultParameter() {
        return $this->defaultParameter;
    }
    public function setDefaultParameter(array $parameters, $cover = false) {
        if ($cover) {
            $this->defaultParameter = $parameters;
        } else {
            $this->defaultParameter = array_merge($this->defaultParameter, $parameters);
        }
        return $this;
    }
    public function getResponse() {
        return $this->Response;
    }
    public function getRunRoute() {
        return $this->RunRoute;
    }
    public function loadCache($path = "") {
        $lists = include $path;
        $this->lists = array_merge($this->lists, (array)$lists);
    }
    
    public function loadRoute($path = "", RouteConfig $RouteConfig = null) {
        static $first = false;
        $RouteConfig->secure === null and $RouteConfig->secure = C('route.secure');
        $routePath = $this->options["cacheDir"] . "/_" . main()->getEnv() . ".php";
        if (!is_dir(dirname($routePath))) {
            mkdir(dirname($routePath), 0777, true) or E("Unable to open or create cacheDir '%s'", dirname($routePath));
        }
        $handle = fopen($routePath, "c+");
        if (!$handle) {
            E("Unable to open or create file '%s'", $routePath);
        }
        flock($handle, LOCK_SH);
        $stat = fstat($handle);
        if ($stat["size"] > 0 && main()->getEnv() == "prod" && !$first) {
            if (!$this->lists) {
                $this->lists = include $routePath;
            }
            return;
        }
        if (!$first && $stat["size"] > 0) {
            $this->lists = (array)include $routePath;
        }
        $first = true;
                $cacheLogsPath = $this->options["cacheDir"] . "/_cache_" . main()->getEnv() . ".php";
        $cacheHandle = fopen($cacheLogsPath, "c+");
        if (!$cacheHandle) {
            E("Unable to open or create file '%s'", $cacheHandle);
        }
                $cacheKey = ltrim(preg_replace("/[\:\/\\\\\.]+/", "-", $path), "-");
        flock($cacheHandle, LOCK_SH);
        $cacheStat = fstat($cacheHandle);
        $cacheLogs = $cacheStat["size"] == 0 ? array() : (array)include $cacheLogsPath;
        if ($stat["size"] == 0 || $cacheStat["size"] == 0 || !isset($cacheLogs[$cacheKey]) || $cacheLogs[$cacheKey] !== filemtime($path)) {
            $cacheLogs[$cacheKey] = filemtime($path);
            ftruncate($handle, 0);
            flock($handle, LOCK_EX | LOCK_NB);
                        $configs = parseFile($path);
            if (!is_array($configs)) {
                E("Parse file failure '%s'", $path);
            }
            $extra = (array)$RouteConfig;
            $extra["route_mode"] or $extra["route_mode"] = $this->options['route_mode'];
            foreach ($configs as $name => $config) {
                $this->add($name, $config["pattern"], $config["callback"], $config["method"], array_replace($this->routeOptions, $extra, isset($config["options"]) ? $config["options"] : array()));
            }
            $code = sprintf("<?php\n//route cache \nreturn %s;", var_export($this->lists, true));
            if (fwrite($handle, $code, strlen($code)) !== strlen($code)) {
                E("Unable to create file '%s'", $routePath);
            }
                        ftruncate($cacheHandle, 0);
            flock($cacheHandle, LOCK_EX | LOCK_NB);
            $codecache = sprintf("<?php\n//route cache \nreturn %s ;", var_export($cacheLogs, true));
            if (fwrite($cacheHandle, $codecache, strlen($codecache)) !== strlen($codecache)) {
                E("Unable to create file '%s'", $cacheLogsPath);
            }
        }
        flock($handle, LOCK_UN);
        flock($cacheHandle, LOCK_UN);
        fclose($handle);
        fclose($cacheHandle);
    }
    public function setCacheDir($cacheDir = "") {
        $cacheDir and $this->options['cacheDir'] = $cacheDir;
    }
    public function setRequest(Request $request) {
        $this->request = $request;
    }
    
    public function getUrlForRoute($name, array $params = array(), $intact = false) {
        if (!isset($this->lists[$name]))
            E("Routing does not exist for %s ", $name);
        $routeInfo = &$this->lists[$name];
        $extra = &$routeInfo["extra"];
        $parameters = array_merge($routeInfo["params"], $this->defaultParameter, (array)$extra['default'], $params);
        $fillParameters = $extraParameters = array();
        foreach ($parameters as $parName => $parameter) {             if ("" === trim($parameter))
                E("Lack of routing parameters of '%s' for '%s'  ", $parName, $name);
            if ($routeInfo["extra"]["require"] &&
                isset($extra["require"][$parName]) &&
                !preg_match("/" . $extra["require"][$parName] . "/", $parameter)
            ) {
                E("Routing parameter format is not correct '%s' for '%s',success format: match '%s' ", $parName, $name, $extra["require"][$parName]);
            }
            if (key_exists($parName, $routeInfo["params"]))
                $fillParameters[":" . $parName] = $parameter;
            else
                $extraParameters[$parName] = $parameter;
        }
        if ($fillParameters) {             uksort($fillParameters, function ($a, $b) {
                return strlen($a) < strlen($b);
            });
            $pattern = str_replace(array_keys($fillParameters), $fillParameters, $routeInfo["pattern"]);
        } else {
            $pattern = $routeInfo["pattern"];
        }
        $extra["secure"] === null and $extra["secure"] = $this->request->isSecure();
        return $this->getSchemeHttpHost($extra["secure"], $extra['domain'], $intact) .
            $this->trimdir($this->getPath($extra["route_mode"]) . $this->getPattern($pattern, $extra["route_mode"], $extra["encrypt"])) .
            $this->getQuery($pattern, $extra["route_mode"], $extra["encrypt"], $extraParameters);
    }
    private function getSchemeHttpHost($isSecure, $domain = "", $intact = false) {
        static $schemeHttpHost = array();
        if (isset($schemeHttpHost[$isSecure][$domain][$intact])) {
            return $schemeHttpHost[$isSecure][$domain][$intact];
        }
        if ($intact === false && $isSecure == $this->request->isSecure()) {
            if (empty($domain) || $domain == $this->request->getHttpHost()) {
                $schemeHttpHost[$isSecure][$domain][$intact] = "";
            } else {
                $schemeHttpHost[$isSecure][$domain][$intact] = $this->request->getScheme() . "://" . $domain;
            }
        } else {
            $scheme = $isSecure ? "https://" : "http://";
            $schemeHttpHost[$isSecure][$domain][$intact] = $scheme . (empty($domain) ? $this->request->getHttpHost() : $domain);
        }
        return $schemeHttpHost[$isSecure][$domain][$intact];
    }
    private function getPath($urlMode = Route::ROUTE_PATHINFO) {
        return isset($this->modePaths[$urlMode]) ? $this->modePaths[$urlMode] : $this->request->server->get("SCRIPT_NAME");
    }
    private function getPattern($pattern, $mode, $encrypt) {
        if ($mode == Route::ROUTE_NORMAL) {
            return "";
        }
        return $encrypt ? $this->enEncrypt($pattern, $encrypt) : $pattern;
    }
    private function getQuery($pattern, $mode, $encrypt, $extraParameters) {
        if ($mode == Route::ROUTE_NORMAL) {
            if (isset($extraParameters[$this->options["var_name"]]))
                unset($extraParameters[$this->options["var_name"]]);
            $extraParameters = array_merge(array($this->options["var_name"] => $pattern), $extraParameters);
        }
        if (empty($extraParameters))
            return "";
        return "?" . ($encrypt ? $this->enEncrypt(http_build_query($extraParameters), $encrypt) : http_build_query($extraParameters));
    }
    public function getActionForRoute($name, $params = array()) {
        if (!isset($this->lists[$name]))
            return false;
        $routeInfo = &$this->lists[$name];
        $callback = &$routeInfo['callback'];
        $args = array();
        foreach ($params as $key => $par) {
            if (false !== strpos($callback, "{" . $key . "}")) {
                $callback = str_replace("{" . $key . "}", $par, $callback);
            } else {
                $args[$key] = $par;
            }
        }
        ksort($args);
        list($app, $controller_name, $action_name) = explode(":", $callback);
        return array(
            "app" => $app,
            "controller" => ucfirst($controller_name),
            "action" => $action_name,
            "class" => $app . "\\Controller\\" . ucfirst($controller_name) . "Controller",
            "params" => $args
        );
    }
    public function has($name) {
        return isset($this->lists[$name]);
    }
}
}
namespace phpex\Library{
class RouteConfig {
    
    public $prefix = "";
    
    public $domain = "";
    
    public $encrypt = "";
    
    public $path = "";
    
    public $secure = null;
    
    public $route_mode;
}
}
namespace phpex\Library{
class RouteController {
    private $relateClass;
    private $relateAction;
    private $relateArgs = array();
    public function __construct($class) {
        $this->relateClass = $class;
    }
    public function __call($action, $args) {
        if ($this->relateAction) return $this;
        $this->relateAction = $action;
        $this->relateArgs = $args;
        return $this;
    }
    public function invoke() {
    }
}
}
namespace phpex\Library{
class RouteDeclare {
    private $name, $method, $configs = array(
        "prefix" => "",
        "domain" => "",
        "encrypt" => null,
        "root" => "",
        "secure" => null,
        'route_mode' => Router::ROUTE_PATHINFO
    );
    private $callback, $url, $urlRequire = array(), $view;
    public function __construct($name, $method, array $configs) {
        $this->name = $name;
        $this->method = $method;
        $this->configs = $configs;
    }
    public function call($callback) {
        $this->callback = $callback;
        return $this;
    }
    
    public function url($url, $_ = null) {
        $args = func_get_args();
        $url = array_shift($args);
        $this->url = $url;
        $this->urlRequire = $args;
        return $this;
    }
    public function view($view) {
        $this->view = $view;
        return $this;
    }
    public function setPrefix($prefix) {
        $this->configs['prefix'] = $prefix;
        return $this;
    }
    public function setDomain($domain) {
        $this->configs['domain'] = $domain;
        return $this;
    }
    public function setEncrypt($encrypt) {
        $this->configs['encrypt'] = $encrypt;
        return $this;
    }
    public function setSecure($secure) {
        $this->configs['secure'] = $secure;
        return $this;
    }
    public function setRouteMode($routeMode) {
        $this->configs['route_mode'] = $routeMode;
        return $this;
    }
}
}
namespace phpex\Library{
class View {
    private $_assign = array();
    public function assign($key, $val = '') {
        if (is_array($key)) {
            $this->_assign = array_merge($this->_assign, $key);
            return;
        } elseif (empty($key)) {
            return;
        }
        $keys = explode(".", $key);
        $joinkey = '';
        foreach ($keys as $ckey) {
            $joinkey.="['$ckey']";
        }
        eval('$this->_assign' . $joinkey . '=$val;');
    }
    public function getAssign($key = '') {
        if (empty($key))
            return $this->_assign;
        $keys = explode(".", $key);
        $joinkey = '';
        foreach ($keys as $ckey) {
            $joinkey.="['$ckey']";
        }
        eval('$return=isset($this->_assign' . $joinkey . ')?$this->_assign' . $joinkey . ':null;');
        return $return;
    }
    public function parse($content) {
        return $content;
    }
    public function fetch($templateFile = '', $assign = null) {
        $configs = C("view");
        $basename = basename($templateFile);
        $suffix = strstr($basename, ".");
        if ($suffix)
            $templateFile = substr($templateFile, 0, -strlen($suffix));
        else {
            $suffix = "." . getkey($configs["RelateEngine"], $configs["engine"]);
        }
        $pattern = "/^(?<app>[a-zA-Z0-9_]+@)?"
                . "(?<theme>[a-zA-Z0-9_]+#)?"
                . "(?<con>[a-zA-Z0-9_]+[\\:\\/])?"
                . "(?<act>[a-zA-Z0-9_]+)?$/";
        if (!$templateFile) {             
            $app = ins()->get("app." . ucfirst(R()->getAppName()));
            $theme = $app->getTheme() ? $app->getTheme() . "/" : "";
            $templateFile = $app->getRoot() . "/View/" . $theme . ucfirst(R()->getController()) . "/" . R()->getAction();
        } elseif (preg_match($pattern, $templateFile, $matches)) {             
            if (!isset($matches["app"]) || empty($matches["app"])) {
                $appName = ucfirst(R()->getAppName());
            } else {
                $appName = ucfirst(substr($matches["app"], 0, -1));
            }
            $app = ins()->get("app." . $appName);
            if (!isset($matches["theme"]) || empty($matches["theme"])) {
                $theme = $app->getTheme() ? $app->getTheme() . "/" : "";
            } else {
                $theme = substr($matches["theme"], 0, -1) . "/";
            }
            if (!isset($matches["con"]) || empty($matches["con"])) {
                $con = R()->getController();
            } else {
                $con = substr($matches["con"], 0, -1);
            }
            $con=  ucfirst($con);
            if (!isset($matches["act"]) || empty($matches["act"])) {
                $act = R()->getAction();
            } else {
                $act = $matches["act"];
            }
            $templateFile = $app->getRoot() . "/View/" . $theme . $con . "/" . $act;
        }
        $templateFile .= $suffix;
        if (!is_file($templateFile)) {
            E("Template file does not exist:'%s'", $templateFile);
        }
        $subInfos = explode(".", $suffix);
        $subInfo = array_pop($subInfos);
        if (!isset($configs["RelateEngine"][$subInfo])) {
            E('Does not support the template engine:"%s"', $subInfo);
        }
        $EngineClass = "\\Engine\\" . $configs['RelateEngine'][$subInfo] . "Engine";
        $Engine = new $EngineClass();
        if (null === $assign) {
            $assign = $this->_assign;
        }
        $Engine->setAppName(isset($appName) ? $appName : ucfirst(R()->getAppName()));
        return $Engine->fetch($templateFile, $assign, $configs);
    }
}
}
namespace phpex\Loader{
interface ConfigureInterface {
    
    public function load($path, $reference = null);
    
    public function get($key = '');
    public function set($key, $value);
    
    public function has($key);
}
}
namespace phpex\Loader{
use phpex\Library\Container;
class Configure implements ConfigureInterface {
    protected $configures = array();
    
    public function load($path, $reference = null) {
        if (null === $reference)
            $this->configures = array_replace_recursive($this->configures, parseFile($path));
        elseif (true === $reference)
            $this->configures = array_replace_recursive(parseFile($path), $this->configures);
        else
            $this->configures[$reference] = isset($this->configures[$reference]) ?
                    array_replace_recursive($this->configures[$reference], parseFile($path)) :
                    parseFile($path);
        if (!empty($this->configures) && is_array($this->configures)) {
            $this->array_map($this->configures, $this->configures);
            if (isset($this->configures['imports'])) {
                $imports = $this->configures['imports'];
                unset($this->configures['imports']);
                foreach ($imports as $import) {
                    $import_configs = parseFile($import);
                    $this->configures = array_merge_recursive((array) $import_configs, $this->configures);
                }
            }
        }
    }
    private function array_map(&$configs, &$topconfigs) {
        if (!is_array($configs)) {
            $configs = preg_replace_callback("/%([^%#]*)#?([^%]*)%/", function($matches) {
                $name = strstr($matches[1], " ", true);
                $container = ins()->has($name) ? ins()->get($name) : ins()->get("core.config");
                $method = substr($matches[1], strlen($name) + 1);
                if (!method_exists($container, $method))
                    $method = "get";
                $args = explode(",", $matches[2]);
                $return = call_user_func_array(array(&$container, $method), $args);
                if (is_scalar($return) || is_null($return)) {
                    return $return;
                } else {
                    E("The '%s' return value must be a scalar,give(%s)", $matches[0], strtoupper(typeof($return)));
                }
            }, $configs
            );
            if (0 === strpos($configs, "@")) {
                $configs = parseFile(substr($configs, 1));
            }
        } else {
            foreach ($configs as &$val) {
                $this->array_map($val, $topconfigs);
            }
        }
    }
    
    public function get($key = '') {
        if (empty($key))
            return $this->configures;
        $keys = explode(".", $key);
        $joinkey = '';
        foreach ($keys as $ckey) {
            $joinkey.="['$ckey']";
        }
        $configs = $this->configures;
        $evalStr = '$return=isset($configs' . $joinkey . ')?$configs' . $joinkey . ':null;';
        eval($evalStr);
        return $return;
    }
    public function sets(array $sets) {
        $this->configures = array_replace($this->configures, $sets);
    }
    public function set($key, $value) {
        $keys = explode(".", $key);
        $joinkey = '';
        foreach ($keys as $ckey) {
            $joinkey.="['$ckey']";
        }
        $configs = $this->configures;
        $evalStr = '$configs' . $joinkey . '=$value;';
        eval($evalStr);
        $this->configures = $configs;
    }
    
    public function has($key) {
        $keys = explode(".", $key);
        $joinkey = '';
        foreach ($keys as $ckey) {
            $joinkey.="['$ckey']";
        }
        $configs = $this->configures;
        $evalStr = '$return=isset($configs' . $joinkey . ')?true:false;';
        eval($evalStr);
        return $return;
    }
}
}
namespace phpex\Loader{
class CacheConfigure extends Configure {
    public function load($path, $reference = null) {
        parent::load($path, $reference = null);
    }
}
}
namespace phpex\Loader{
interface LoaderInterface {
    public function loadClass($class);
    public function register($prepend = false);
    public function unregister();
}
}
namespace phpex\Access{
use phpex\Foundation\Response;
use phpex\Library\View;
class Access {
    protected $user;
    protected $access_session_name = "access";
    protected $url;
    protected $rolename = "guest";
    protected $ignore = array();
    protected $controller, $action, $parameters;
    protected $errorTpl = "";
    protected $nodes = array();
    protected $actionNames = array();
    protected $closeNodeAccess = false;
    
    protected $userMap;
    protected $response;
    public function __construct($controller, $action, $parameters) {
        $this->controller = $controller;
        $this->action = $action;
        $this->parameters = $parameters;
    }
    
    public function setUser($user) {
        $this->user = $user;
        if ($user && is_object($user)) {
            $this->userMap = new \ReflectionObject($user);
        }
    }
    
    public function closeNodeAccess($close = true) {
        $this->closeNodeAccess = (bool)$close;
    }
    public function setLoginUrl($url) {
        $this->url = $url;
    }
    public function setAccessSessionName($accessSessionName) {
        $this->access_session_name = $accessSessionName;
    }
    public function clearAccredit() {
        Q()->getSession()->remove($this->access_session_name)->save();
    }
    public function accredit($user, $rolename = "", $confs = array()) {
        $this->setUser($user);
        $rolename or $rolename = $this->getUser("roleName");
        
        $app = ins()->get("app." . R()->getAppName());
        $confs = $confs ?: array($app->getNamespace(), $app->getRoot() . "/Conf");
        $rolenames = explode(",", $rolename);
        $weight = 0;
        $this->buildNodes($inodes, $confs[1], $confs[0]);
        $this->filterNode($rolenames, $confs[1], $inodes, $fNode, $weight);
        $accessInfo = array(
            "rolename" => $rolenames,
            "weight" => $weight,
            "user" => $user,
            "nodes" => $fNode
        );
        Q()->getSession()->set($this->access_session_name, $accessInfo)->save();
    }
    public function buildNodes(&$inodes, $basePath, $namespace, $defaultAccredit = 1, $defaultGuest = 0) {
        $inodes = parseFile($basePath . "/node.yml");
        is_array($inodes) or $inodes = array();
        if (!is_file($basePath . "/menu.yml")) {
            $navbars = array();
        } else {
            $navbars = parseFile($basePath . "/menu.yml");
            if (!is_array($navbars)) {
                $navbars = array();
            }
        }
        $namespaceLen = strlen($namespace) + 12;
        $changed = false;
        foreach ($navbars as $nav) {
            $act_info = R()->getActionForRoute($nav[2], $nav[3]);
            if (!$act_info)
                continue;
            $action = sprintf("%s.%s.%s", $act_info["app"], $act_info["controller"], $act_info["action"]);
            if ($act_info["params"]) {
                $action .= "." . str_replace(array("&", "="), array(".", ":"), http_build_query($act_info["params"]));
            }
            if (isset($inodes[$action])) {
                continue;
            }
            $changed = true;
            $inodes[$action] = array(
                "name" => $nav[1],
                "accredit" => $defaultAccredit,
                "guest" => $defaultGuest
            );
        }
        $path = realpath($basePath . "/../Controller");
        $files = glob($path . "/*Controller.php");
        foreach ($files as $file) {
            $classname = $namespace . "\\Controller\\" . rtrim(basename($file), ".php");
            $r = new \ReflectionClass($classname);
            if ($r->isSubclassOf('phpex\\Library\\Controller') && $r->isSubclassOf('phpex\\Access\\AccessInterface') && !$r->isAbstract()) {
                $names = substr($classname, $namespaceLen, -10);
                
                $methods = $r->getMethods(\ReflectionMethod::IS_PUBLIC);
                foreach ($methods as $method) {
                    if ($classname != $method->class)
                        continue;
                    $doc = $method->getDocComment();
                    if (preg_match("/@ignore/", $doc)) {
                        continue;
                    }
                    $action = sprintf("%s.%s.%s", $namespace, $names, $method->getName());
                    if (isset($inodes[$action])) {
                        continue;
                    }
                    $changed = true;
                    $inodes[$action] = array(
                        "name" => $this->getNames($method->getName(), $doc),
                        "accredit" => $defaultAccredit,
                        "guest" => $defaultGuest
                    );
                }
            }
        }
        ksort($inodes);
        $changed and file_put_contents($basePath . "/node.yml", arrDump($inodes));
    }
    private function getNames($action, $doc) {
        if ($doc && preg_match("/@name\s+(\S+)/", $doc, $name)) {
            return $name[1];
        } elseif (isset($this->actionNames[$action])) {
            return $this->actionNames[$action];
        } else {
            return $action;
        }
    }
    public function filterNode(array $rolenames, $basePath, array $inodes, &$fNode, &$weight = 0) {
        $roles = parseFile($basePath . "/role.yml");
        is_array($iroles) or $iroles = array();
        foreach ($roles as $key => $role) {
            if (in_array($key, $rolenames)) {
                $weight = $weight | $role["weight"];
            }
        }
        if (!$weight) {
            $fNode = array();
            return;
        }
        foreach ($inodes as $name => $node) {
            if (!isset($node["accredit"]))
                continue;
            if ($node["accredit"] & $weight) {
                $fNode[$name] = $node;
            } elseif ($node["guest"]) {
                $fNode[$name] = $node;
            }
        }
    }
    
    public function getUser($key = null) {
        if (!$key)
            return $this->user;
        if ($this->userMap && $this->userMap->hasProperty($key)) {
            $property = $this->userMap->getProperty($key);
            $property->setAccessible(true);
            return $property->getValue($this->user);
        }
        return null;
    }
    
    public function flushUser() {
        if (!$this->user)
            return;
        $this->user = DM()->getManager()
            ->createQuery(sprintf("select u from %s u where u.id=%d", get_class($this->user), $this->user->getId()))
            ->setMaxResults(1)->getOneOrNullResult();
        $access = (array)Q()->getSession()->get($this->access_session_name);
        $access = array_merge($access, array("user" => $this->user));
        Q()->getSession()->set($this->access_session_name, $access);
        Q()->getSession()->save();
    }
    
    public function getLoginUrl() {
        return $this->url;
    }
    public function isAccredit($controller = "", $action = "", array $parameter = array()) {
        if ($this->closeNodeAccess) {
            return true;
        }
        $controller = $controller ?: $this->controller;
        $action = $action ?: $this->action;
        $parameter = $parameter ?: $this->parameters;
        $node = sprintf("%s.%s.%s", R()->getAppName(), $controller, $action);
        ksort($parameter);
        do {
            $pstr = http_build_query($parameter);
            $pname = $pstr ? $node . "." . str_replace(array("&", "="), array(".", ":"), $pstr) : $node;
            if (isset($this->nodes[$pname])) {
                return true;
            }
            array_pop($parameter);
        } while (count($parameter) > 0);
        return isset($this->nodes[$node]);
    }
    public function isIgnore() {
        if (isset($this->ignore[R()->getAppName()][$this->controller][$this->action]))
            return true;
        elseif (isset($this->ignore[R()->getAppName()][$this->controller]["*"]))
            return true;
        return false;
    }
    public function isLogin() {
        return $this->user ? true : false;
    }
    public function addIgnore($controller, $action = "*", $app = null) {
        if (null === $app)
            $app = R()->getAppName();
        $this->ignore[$app][$controller][$action] = true;
        return $this;
    }
    public function setErrorTpl($tpl) {
        $this->errorTpl = $tpl;
    }
    public function loadSession() {
        $accessInfo = Q()->getSession()->has($this->access_session_name) ?
            Q()->getSession()->get($this->access_session_name) : array();
        if ($accessInfo) {
            isset($accessInfo["user"]) and $this->setUser($accessInfo["user"]);
            $this->rolename = isset($accessInfo["rolename"]) ? $accessInfo["rolename"] : $this->rolename;
            $this->nodes = isset($accessInfo["nodes"]) ? $accessInfo["nodes"] : $this->nodes;
        }
        if (isset($this->nodes[0]))
            unset($this->nodes[0]);
    }
    public function setResponse($response) {
        $this->response = $response;
    }
    public function getResponse() {
        if ($this->response) {
            return $this->response;
        }
        if ($this->isIgnore()) {
            return true;
        }
        if (empty($this->user))
            return $this->jumpLogin();
        if ($this->isAccredit()) {
            return true;
        }
        if (!ins()->has("core.view")) {
            $view = new View();
            ins()->addInstance("core.view", $view);
        } else {
            $view = ins()->get("core.view");
        }
        $headers = array("Content-Type" => C("response.contentType") . ";charset=" . C("response.charset"));
        return new Response($view->fetch($this->errorTpl ?: main()->getMainRoot() . "/Common/denied"), 403, $headers);
    }
    private function jumpLogin() {
        $headers = array("Content-Type" => C("response.contentType") . ";charset=" . C("response.charset"));
        $response = new Response("", 200, $headers);
        if (!$this->url) {
            $response->setContent('<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>没有权限</title>
    </head>
    <body>
        <h5>请先设置登录URL.</h5>
    </body>
</html>');
        } else {
            $response->setStatusCode(200);
            $parse = parse_url($this->url);
            if (isset($parse["query"])) {
                parse_str($parse["query"], $queryarr);
                if (!isset($queryarr['redirect_url'])) {
                    $queryarr['redirect_url'] = Q()->getUri();
                }
                $urls = explode("?", $this->url);
                $url = $urls[0] . "?" . http_build_query($queryarr);
            } else {
                $queryarr = array("redirect_url" => Q()->getUri());
                $url = $this->url . "?" . http_build_query($queryarr);
            }
            $response->setContent('<!DOCTYPE html><html>
        <head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>请先登录</title></head>
        <body onload="document.getElementById(\'jumpToLogin\').click()"><a id="jumpToLogin" href="' . $url . '">正在跳转..</a></body>
</html>');
        }
        return $response;
    }
}
}
namespace phpex\Access{
interface AccessInterface {
    public function setAccess(Access $access);
}
}
namespace phpex\Asset{
use phpex\Util\ORG\Image;
class Asset {
    private $config = array(), $cdnConfig = array();
    private $publics = array(), $cdnPublics = array();
    private $apps = array();
    private $baseUrl = "";
    private $basePath = "";
    private $safeAccessScript = "";
    public function path($path = "") {
        if ($this->cdnConfig["enabled"]) return $this->cdnPath($path);
        $path = $this->baseUrl . str_ireplace($this->apps, $this->publics, $path);
        $realPath = str_replace("/./", "/", $path);
        do {
            if (false === ($pos = strpos($realPath, "/../"))) {
                break;
            }
            $leftPath = substr($realPath, 0, $pos);
            $rightPaht = substr($realPath, $pos + 3);
            $realPath = dirname($leftPath) . $rightPaht;
        } while ($realPath);
        return preg_replace('/\/{2,}/', '/', $realPath);
    }
    public function cdnPath($path) {
        $path = str_ireplace($this->apps, $this->cdnPublics, $path);
        $realPath = str_replace("/./", "/", $path);
        do {
            if (false === ($pos = strpos($realPath, "/../"))) {
                break;
            }
            $leftPath = substr($realPath, 0, $pos);
            $rightPaht = substr($realPath, $pos + 3);
            $realPath = dirname($leftPath) . $rightPaht;
        } while ($realPath);
        return $this->cdnConfig['url'] . preg_replace('/\/{2,}/', '/', $realPath);
    }
    public function __construct() {
        $this->cdnConfig = C("cdn") ?: array("enabled" => false);
        $this->cdnConfig["enabled"] ? $this->_cdnInit() : $this->_init();
    }
    private function _cdnInit() {
        
        $apps = ins()->getTag("app");
        $i = 0;
        foreach ($apps as $app) {
            $this->apps[$i] = "[" . ucfirst($app->getName()) . "]";
            $this->cdnPublics[$i] = $app->getPublicName() . ($app->getTheme() ? "/" . $app->getTheme() : "");
            $this->cdnPublics[$i] = "/statics/" . $this->cdnConfig["name"] . "/" . $this->cdnPublics[$i];
            $i++;
        }
        $this->apps[$i + 1] = "*";
        $this->apps[$i + 2] = ",";
        $this->apps[$i + 3] = "[Core]";
        $this->cdnPublics[$i + 1] = "x";
        $this->cdnPublics[$i + 2] = "_";
        $this->cdnPublics[$i + 3] = "/libs";
    }
    private function _init() {
        $this->config = C("asset");
              
        $apps = ins()->getTag("app");
        $i = 0;
        foreach ($apps as $app) {
            $this->apps[$i] = "[" . ucfirst($app->getName()) . "]";
            $this->publics[$i] = $app->getPublicName() . ($app->getTheme() ? "/" . $app->getTheme() : "");
            $i++;
        }
        $this->apps[$i + 1] = "*";
        $this->apps[$i + 2] = ",";
        $this->apps[$i + 3] = "[Core]";
        $this->publics[$i + 1] = "x";
        $this->publics[$i + 2] = "_";
        $this->publics[$i + 3] = "core";
        $this->publics[$i + 2] = "_";
        $this->baseUrl = Q()->getBasePath() . "/" . $this->config["basedir"] . "/";
        $this->basePath = dirname(Q()->server->get("SCRIPT_FILENAME"));
        if (0 === stripos($this->config["safe_access_script"], "http"))
            $this->safeAccessScript = $this->config["safe_access_script"];
        else
            $this->safeAccessScript = Q()->getBasePath() . "/" . $this->config["safe_access_script"];
    }
    public function thumbnail($output, $input = "", $type = "small") {
        if ($input && is_file($input)) {
            $file = $input;
        } elseif ($input) {
            $file = $this->basePath . str_ireplace($this->apps, $this->publics, $input);
        } else {
            $file = $this->basePath . str_ireplace($this->apps, $this->publics, $output);
        }
        if (!is_file($file)) {
            $file = $this->config["_empty"]["input"];
        }
        $config = isset($this->config["thumb"][$type]) ? $this->config["thumb"][$type] : current($this->config["thumb"]);
        $output = dirname($output) . "/" . $config["prefix"] . $config["size"] . "_" . basename($output);
        $saveName = $this->basePath . str_ireplace($this->apps, $this->publics, $output);
        if (!is_file($saveName) || "dev" == main()->getEnv()) {
            list($width, $height) = explode("*", $config["size"]);
            Image::thumb($file, $saveName, $width, $height);
        }
        return $this->baseUrl . str_ireplace($this->apps, $this->publics, $output);
    }
    public function water($output, $input = "", $type = "default") {
        if ($input && is_file($input)) {
            $file = $input;
        } elseif ($input) {
            $file = $this->basePath . str_ireplace($this->apps, $this->publics, $input);
        } else {
            $file = $this->basePath . str_ireplace($this->apps, $this->publics, $output);
        }
        if (!is_file($file)) {
            $file = $this->config["_empty"]["input"];
        }
        $config = isset($this->config["water"][$type]) ? $this->config["water"][$type] : current($this->config["water"]);
        $output = dirname($output) . "/" . $config["prefix"] . "a_" . $config['alpha'] . "_p" . $config['position'] . "_m" . $config['margin'] . "_" . basename($output);
        $saveName = $this->basePath . str_ireplace($this->apps, $this->publics, $output);
        if (!is_file($saveName) || "dev" == main()->getEnv()) {
            Image::water($file, $config['path'], $saveName, $config['alpha'], $config['position'], $config['margin']);
        }
        return Q()->getBasePath() . $this->modulePath($output);
    }
    public function clip($output, $input = "", $type = "small") {
        if ($input && is_file($input)) {
            $file = $input;
        } elseif ($input) {
            $file = $this->basePath . str_ireplace($this->apps, $this->publics, $input);
        } else {
            $file = $this->basePath . str_ireplace($this->apps, $this->publics, $output);
        }
        if (!is_file($file)) {
            $file = $this->config["_empty"]["input"];
        }
        $config = isset($this->config["clip"][$type]) ? $this->config["clip"][$type] : current($this->config["clip"]);
        $output = dirname($output) . "/" . $config["prefix"] . $config['size'] . "_p" . $config['point'] . "_" . basename($output);
        $saveName = $this->basePath . str_ireplace($this->apps, $this->publics, $output);
        if (!is_file($saveName) || "dev" == main()->getEnv()) {
            list($width, $height) = explode("*", $config["size"]);
            list($x, $y) = explode(",", $config["point"]);
            Image::clip($file, $saveName, $width, $height, $x, $y);
        }
        return $this->baseUrl . str_ireplace($this->apps, $this->publics, $output);
    }
    
    public function uploadPath($path, $type) {
        if ($this->cdnConfig["enabled"]) return $this->cdnUploadPath($path, $type);
        $path = ltrim($path, "/");
        if (!isset($this->config["thumb"][$type]))
            return $this->safeAccessScript . $path;
        $basename = basename($path);
        $dirname = dirname($path);
        $thumbconfig = $this->config["thumb"][$type];
        return $this->safeAccessScript . $dirname . "/" . $thumbconfig["prefix"] . str_replace("*", "_", $thumbconfig["size"]) . "_" . $basename;
    }
    public function cdnUploadPath($path, $type) {
        $path = ltrim($path, "/");
        if (!isset($this->config["thumb"][$type])) return $this->cdnConfig['url'] . "/uploads/" . $path;
        $basename = basename($path);
        $dirname = dirname($path);
        $thumbconfig = $this->config["thumb"][$type];
        return $this->cdnConfig['url'] . "/uploads/" .  $dirname . "/" . $thumbconfig["prefix"] . str_replace("*", "_", $thumbconfig["size"]) . "_" . $basename;
    }
}
}
namespace Symfony\Component\Console{
use Symfony\Component\Console\Descriptor\TextDescriptor;
use Symfony\Component\Console\Descriptor\XmlDescriptor;
use Symfony\Component\Console\Helper\DebugFormatterHelper;
use Symfony\Component\Console\Helper\ProcessHelper;
use Symfony\Component\Console\Helper\QuestionHelper;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\ArgvInput;
use Symfony\Component\Console\Input\ArrayInput;
use Symfony\Component\Console\Input\InputDefinition;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputAwareInterface;
use Symfony\Component\Console\Output\BufferedOutput;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Output\ConsoleOutput;
use Symfony\Component\Console\Output\ConsoleOutputInterface;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Command\HelpCommand;
use Symfony\Component\Console\Command\ListCommand;
use Symfony\Component\Console\Helper\HelperSet;
use Symfony\Component\Console\Helper\FormatterHelper;
use Symfony\Component\Console\Helper\DialogHelper;
use Symfony\Component\Console\Helper\ProgressHelper;
use Symfony\Component\Console\Helper\TableHelper;
use Symfony\Component\Console\Event\ConsoleCommandEvent;
use Symfony\Component\Console\Event\ConsoleExceptionEvent;
use Symfony\Component\Console\Event\ConsoleTerminateEvent;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;
class Application
{
    private $commands = array();
    private $wantHelps = false;
    private $runningCommand;
    private $name;
    private $version;
    private $catchExceptions = true;
    private $autoExit = true;
    private $definition;
    private $helperSet;
    private $dispatcher;
    private $terminalDimensions;
    private $defaultCommand;
    
    public function __construct($name = 'UNKNOWN', $version = 'UNKNOWN')
    {
        $this->name = $name;
        $this->version = $version;
        $this->defaultCommand = 'list';
        $this->helperSet = $this->getDefaultHelperSet();
        $this->definition = $this->getDefaultInputDefinition();
        foreach ($this->getDefaultCommands() as $command) {
            $this->add($command);
        }
    }
    public function setDispatcher(EventDispatcherInterface $dispatcher)
    {
        $this->dispatcher = $dispatcher;
    }
    
    public function run(InputInterface $input = null, OutputInterface $output = null)
    {
        if (null === $input) {
            $input = new ArgvInput();
        }
        if (null === $output) {
            $output = new ConsoleOutput();
        }
        $this->configureIO($input, $output);
        try {
            $exitCode = $this->doRun($input, $output);
        } catch (\Exception $e) {
            if (!$this->catchExceptions) {
                throw $e;
            }
            if ($output instanceof ConsoleOutputInterface) {
                $this->renderException($e, $output->getErrorOutput());
            } else {
                $this->renderException($e, $output);
            }
            $exitCode = $e->getCode();
            if (is_numeric($exitCode)) {
                $exitCode = (int) $exitCode;
                if (0 === $exitCode) {
                    $exitCode = 1;
                }
            } else {
                $exitCode = 1;
            }
        }
        if ($this->autoExit) {
            if ($exitCode > 255) {
                $exitCode = 255;
            }
            exit($exitCode);
        }
        return $exitCode;
    }
    
    public function doRun(InputInterface $input, OutputInterface $output)
    {
        if (true === $input->hasParameterOption(array('--version', '-V'))) {
            $output->writeln($this->getLongVersion());
            return 0;
        }
        $name = $this->getCommandName($input);
        if (true === $input->hasParameterOption(array('--help', '-h'))) {
            if (!$name) {
                $name = 'help';
                $input = new ArrayInput(array('command' => 'help'));
            } else {
                $this->wantHelps = true;
            }
        }
        if (!$name) {
            $name = $this->defaultCommand;
            $input = new ArrayInput(array('command' => $this->defaultCommand));
        }
                $command = $this->find($name);
        $this->runningCommand = $command;
        $exitCode = $this->doRunCommand($command, $input, $output);
        $this->runningCommand = null;
        return $exitCode;
    }
    
    public function setHelperSet(HelperSet $helperSet)
    {
        $this->helperSet = $helperSet;
    }
    
    public function getHelperSet()
    {
        return $this->helperSet;
    }
    
    public function setDefinition(InputDefinition $definition)
    {
        $this->definition = $definition;
    }
    
    public function getDefinition()
    {
        return $this->definition;
    }
    
    public function getHelp()
    {
        $messages = array(
            $this->getLongVersion(),
            '',
            '<comment>Usage:</comment>',
            '  [options] command [arguments]',
            '',
            '<comment>Options:</comment>',
        );
        foreach ($this->getDefinition()->getOptions() as $option) {
            $messages[] = sprintf('  %-29s %s %s',
                '<info>--'.$option->getName().'</info>',
                $option->getShortcut() ? '<info>-'.$option->getShortcut().'</info>' : '  ',
                $option->getDescription()
            );
        }
        return implode(PHP_EOL, $messages);
    }
    
    public function setCatchExceptions($boolean)
    {
        $this->catchExceptions = (bool) $boolean;
    }
    
    public function setAutoExit($boolean)
    {
        $this->autoExit = (bool) $boolean;
    }
    
    public function getName()
    {
        return $this->name;
    }
    
    public function setName($name)
    {
        $this->name = $name;
    }
    
    public function getVersion()
    {
        return $this->version;
    }
    
    public function setVersion($version)
    {
        $this->version = $version;
    }
    
    public function getLongVersion()
    {
        if ('UNKNOWN' !== $this->getName() && 'UNKNOWN' !== $this->getVersion()) {
            return sprintf('<info>%s</info> version <comment>%s</comment>', $this->getName(), $this->getVersion());
        }
        return '<info>Console Tool</info>';
    }
    
    public function register($name)
    {
        return $this->add(new Command($name));
    }
    
    public function addCommands(array $commands)
    {
        foreach ($commands as $command) {
            $this->add($command);
        }
    }
    
    public function add(Command $command)
    {
        $command->setApplication($this);
        if (!$command->isEnabled()) {
            $command->setApplication(null);
            return;
        }
        if (null === $command->getDefinition()) {
            throw new \LogicException(sprintf('Command class "%s" is not correctly initialized. You probably forgot to call the parent constructor.', get_class($command)));
        }
        $this->commands[$command->getName()] = $command;
        foreach ($command->getAliases() as $alias) {
            $this->commands[$alias] = $command;
        }
        return $command;
    }
    
    public function get($name)
    {
        if (!isset($this->commands[$name])) {
            throw new \InvalidArgumentException(sprintf('The command "%s" does not exist.', $name));
        }
        $command = $this->commands[$name];
        if ($this->wantHelps) {
            $this->wantHelps = false;
            $helpCommand = $this->get('help');
            $helpCommand->setCommand($command);
            return $helpCommand;
        }
        return $command;
    }
    
    public function has($name)
    {
        return isset($this->commands[$name]);
    }
    
    public function getNamespaces()
    {
        $namespaces = array();
        foreach ($this->commands as $command) {
            $namespaces[] = $this->extractNamespace($command->getName());
            foreach ($command->getAliases() as $alias) {
                $namespaces[] = $this->extractNamespace($alias);
            }
        }
        return array_values(array_unique(array_filter($namespaces)));
    }
    
    public function findNamespace($namespace)
    {
        $allNamespaces = $this->getNamespaces();
        $expr = preg_replace_callback('{([^:]+|)}', function ($matches) { return preg_quote($matches[1]).'[^:]*'; }, $namespace);
        $namespaces = preg_grep('{^'.$expr.'}', $allNamespaces);
        if (empty($namespaces)) {
            $message = sprintf('There are no commands defined in the "%s" namespace.', $namespace);
            if ($alternatives = $this->findAlternatives($namespace, $allNamespaces, array())) {
                if (1 == count($alternatives)) {
                    $message .= "\n\nDid you mean this?\n    ";
                } else {
                    $message .= "\n\nDid you mean one of these?\n    ";
                }
                $message .= implode("\n    ", $alternatives);
            }
            throw new \InvalidArgumentException($message);
        }
        $exact = in_array($namespace, $namespaces, true);
        if (count($namespaces) > 1 && !$exact) {
            throw new \InvalidArgumentException(sprintf('The namespace "%s" is ambiguous (%s).', $namespace, $this->getAbbreviationSuggestions(array_values($namespaces))));
        }
        return $exact ? $namespace : reset($namespaces);
    }
    
    public function find($name)
    {
        $allCommands = array_keys($this->commands);
        $expr = preg_replace_callback('{([^:]+|)}', function ($matches) { return preg_quote($matches[1]).'[^:]*'; }, $name);
        $commands = preg_grep('{^'.$expr.'}', $allCommands);
        if (empty($commands) || count(preg_grep('{^'.$expr.'$}', $commands)) < 1) {
            if (false !== $pos = strrpos($name, ':')) {
                                $this->findNamespace(substr($name, 0, $pos));
            }
            $message = sprintf('Command "%s" is not defined.', $name);
            if ($alternatives = $this->findAlternatives($name, $allCommands, array())) {
                if (1 == count($alternatives)) {
                    $message .= "\n\nDid you mean this?\n    ";
                } else {
                    $message .= "\n\nDid you mean one of these?\n    ";
                }
                $message .= implode("\n    ", $alternatives);
            }
            throw new \InvalidArgumentException($message);
        }
                if (count($commands) > 1) {
            $commandList = $this->commands;
            $commands = array_filter($commands, function ($nameOrAlias) use ($commandList, $commands) {
                $commandName = $commandList[$nameOrAlias]->getName();
                return $commandName === $nameOrAlias || !in_array($commandName, $commands);
            });
        }
        $exact = in_array($name, $commands, true);
        if (count($commands) > 1 && !$exact) {
            $suggestions = $this->getAbbreviationSuggestions(array_values($commands));
            throw new \InvalidArgumentException(sprintf('Command "%s" is ambiguous (%s).', $name, $suggestions));
        }
        return $this->get($exact ? $name : reset($commands));
    }
    
    public function all($namespace = null)
    {
        if (null === $namespace) {
            return $this->commands;
        }
        $commands = array();
        foreach ($this->commands as $name => $command) {
            if ($namespace === $this->extractNamespace($name, substr_count($namespace, ':') + 1)) {
                $commands[$name] = $command;
            }
        }
        return $commands;
    }
    
    public static function getAbbreviations($names)
    {
        $abbrevs = array();
        foreach ($names as $name) {
            for ($len = strlen($name); $len > 0; --$len) {
                $abbrev = substr($name, 0, $len);
                $abbrevs[$abbrev][] = $name;
            }
        }
        return $abbrevs;
    }
    
    public function asText($namespace = null, $raw = false)
    {
        $descriptor = new TextDescriptor();
        $output = new BufferedOutput(BufferedOutput::VERBOSITY_NORMAL, !$raw);
        $descriptor->describe($output, $this, array('namespace' => $namespace, 'raw_output' => true));
        return $output->fetch();
    }
    
    public function asXml($namespace = null, $asDom = false)
    {
        $descriptor = new XmlDescriptor();
        if ($asDom) {
            return $descriptor->getApplicationDocument($this, $namespace);
        }
        $output = new BufferedOutput();
        $descriptor->describe($output, $this, array('namespace' => $namespace));
        return $output->fetch();
    }
    
    public function renderException($e, $output)
    {
        do {
            $title = sprintf('  [%s]  ', get_class($e));
            $len = $this->stringWidth($title);
            $width = $this->getTerminalWidth() ? $this->getTerminalWidth() - 1 : PHP_INT_MAX;
                        if (defined('HHVM_VERSION') && $width > 1 << 31) {
                $width = 1 << 31;
            }
            $formatter = $output->getFormatter();
            $lines = array();
            foreach (preg_split('/\r?\n/', $e->getMessage()) as $line) {
                foreach ($this->splitStringByWidth($line, $width - 4) as $line) {
                                        $lineLength = $this->stringWidth(preg_replace('/\[[^m]*m/', '', $formatter->format($line))) + 4;
                    $lines[] = array($line, $lineLength);
                    $len = max($lineLength, $len);
                }
            }
            $messages = array('', '');
            $messages[] = $emptyLine = $formatter->format(sprintf('<error>%s</error>', str_repeat(' ', $len)));
            $messages[] = $formatter->format(sprintf('<error>%s%s</error>', $title, str_repeat(' ', max(0, $len - $this->stringWidth($title)))));
            foreach ($lines as $line) {
                $messages[] = $formatter->format(sprintf('<error>  %s  %s</error>', $line[0], str_repeat(' ', $len - $line[1])));
            }
            $messages[] = $emptyLine;
            $messages[] = '';
            $messages[] = '';
            $output->writeln($messages, OutputInterface::OUTPUT_RAW);
            if (OutputInterface::VERBOSITY_VERBOSE <= $output->getVerbosity()) {
                $output->writeln('<comment>Exception trace:</comment>');
                                $trace = $e->getTrace();
                array_unshift($trace, array(
                    'function' => '',
                    'file'     => $e->getFile() != null ? $e->getFile() : 'n/a',
                    'line'     => $e->getLine() != null ? $e->getLine() : 'n/a',
                    'args'     => array(),
                ));
                for ($i = 0, $count = count($trace); $i < $count; $i++) {
                    $class = isset($trace[$i]['class']) ? $trace[$i]['class'] : '';
                    $type = isset($trace[$i]['type']) ? $trace[$i]['type'] : '';
                    $function = $trace[$i]['function'];
                    $file = isset($trace[$i]['file']) ? $trace[$i]['file'] : 'n/a';
                    $line = isset($trace[$i]['line']) ? $trace[$i]['line'] : 'n/a';
                    $output->writeln(sprintf(' %s%s%s() at <info>%s:%s</info>', $class, $type, $function, $file, $line));
                }
                $output->writeln("");
                $output->writeln("");
            }
        } while ($e = $e->getPrevious());
        if (null !== $this->runningCommand) {
            $output->writeln(sprintf('<info>%s</info>', sprintf($this->runningCommand->getSynopsis(), $this->getName())));
            $output->writeln("");
            $output->writeln("");
        }
    }
    
    protected function getTerminalWidth()
    {
        $dimensions = $this->getTerminalDimensions();
        return $dimensions[0];
    }
    
    protected function getTerminalHeight()
    {
        $dimensions = $this->getTerminalDimensions();
        return $dimensions[1];
    }
    
    public function getTerminalDimensions()
    {
        if ($this->terminalDimensions) {
            return $this->terminalDimensions;
        }
        if (defined('PHP_WINDOWS_VERSION_BUILD')) {
                        if (preg_match('/^(\d+)x\d+ \(\d+x(\d+)\)$/', trim(getenv('ANSICON')), $matches)) {
                return array((int) $matches[1], (int) $matches[2]);
            }
                        if (preg_match('/^(\d+)x(\d+)$/', $this->getConsoleMode(), $matches)) {
                return array((int) $matches[1], (int) $matches[2]);
            }
        }
        if ($sttyString = $this->getSttyColumns()) {
                        if (preg_match('/rows.(\d+);.columns.(\d+);/i', $sttyString, $matches)) {
                return array((int) $matches[2], (int) $matches[1]);
            }
                        if (preg_match('/;.(\d+).rows;.(\d+).columns/i', $sttyString, $matches)) {
                return array((int) $matches[2], (int) $matches[1]);
            }
        }
        return array(null, null);
    }
    
    public function setTerminalDimensions($width, $height)
    {
        $this->terminalDimensions = array($width, $height);
        return $this;
    }
    
    protected function configureIO(InputInterface $input, OutputInterface $output)
    {
        if (true === $input->hasParameterOption(array('--ansi'))) {
            $output->setDecorated(true);
        } elseif (true === $input->hasParameterOption(array('--no-ansi'))) {
            $output->setDecorated(false);
        }
        if (true === $input->hasParameterOption(array('--no-interaction', '-n'))) {
            $input->setInteractive(false);
        } elseif (function_exists('posix_isatty') && $this->getHelperSet()->has('dialog')) {
            $inputStream = $this->getHelperSet()->get('dialog')->getInputStream();
            if (!@posix_isatty($inputStream)) {
                $input->setInteractive(false);
            }
        }
        if (true === $input->hasParameterOption(array('--quiet', '-q'))) {
            $output->setVerbosity(OutputInterface::VERBOSITY_QUIET);
        } else {
            if ($input->hasParameterOption('-vvv') || $input->hasParameterOption('--verbose=3') || $input->getParameterOption('--verbose') === 3) {
                $output->setVerbosity(OutputInterface::VERBOSITY_DEBUG);
            } elseif ($input->hasParameterOption('-vv') || $input->hasParameterOption('--verbose=2') || $input->getParameterOption('--verbose') === 2) {
                $output->setVerbosity(OutputInterface::VERBOSITY_VERY_VERBOSE);
            } elseif ($input->hasParameterOption('-v') || $input->hasParameterOption('--verbose=1') || $input->hasParameterOption('--verbose') || $input->getParameterOption('--verbose')) {
                $output->setVerbosity(OutputInterface::VERBOSITY_VERBOSE);
            }
        }
    }
    
    protected function doRunCommand(Command $command, InputInterface $input, OutputInterface $output)
    {
        foreach ($command->getHelperSet() as $helper) {
            if ($helper instanceof InputAwareInterface) {
                $helper->setInput($input);
            }
        }
        if (null === $this->dispatcher) {
            return $command->run($input, $output);
        }
        $event = new ConsoleCommandEvent($command, $input, $output);
        $this->dispatcher->dispatch(ConsoleEvents::COMMAND, $event);
        try {
            $exitCode = $command->run($input, $output);
        } catch (\Exception $e) {
            $event = new ConsoleTerminateEvent($command, $input, $output, $e->getCode());
            $this->dispatcher->dispatch(ConsoleEvents::TERMINATE, $event);
            $event = new ConsoleExceptionEvent($command, $input, $output, $e, $event->getExitCode());
            $this->dispatcher->dispatch(ConsoleEvents::EXCEPTION, $event);
            throw $event->getException();
        }
        $event = new ConsoleTerminateEvent($command, $input, $output, $exitCode);
        $this->dispatcher->dispatch(ConsoleEvents::TERMINATE, $event);
        return $event->getExitCode();
    }
    
    protected function getCommandName(InputInterface $input)
    {
        return $input->getFirstArgument();
    }
    
    protected function getDefaultInputDefinition()
    {
        return new InputDefinition(array(
            new InputArgument('command', InputArgument::REQUIRED, 'The command to execute'),
            new InputOption('--help',           '-h', InputOption::VALUE_NONE, 'Display this help message.'),
            new InputOption('--quiet',          '-q', InputOption::VALUE_NONE, 'Do not output any message.'),
            new InputOption('--verbose',        '-v|vv|vvv', InputOption::VALUE_NONE, 'Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug'),
            new InputOption('--version',        '-V', InputOption::VALUE_NONE, 'Display this application version.'),
            new InputOption('--ansi',           '',   InputOption::VALUE_NONE, 'Force ANSI output.'),
            new InputOption('--no-ansi',        '',   InputOption::VALUE_NONE, 'Disable ANSI output.'),
            new InputOption('--no-interaction', '-n', InputOption::VALUE_NONE, 'Do not ask any interactive question.'),
        ));
    }
    
    protected function getDefaultCommands()
    {
        return array(new HelpCommand(), new ListCommand());
    }
    
    protected function getDefaultHelperSet()
    {
        return new HelperSet(array(
            new FormatterHelper(),
            new DialogHelper(),
            new ProgressHelper(),
            new TableHelper(),
            new DebugFormatterHelper(),
            new ProcessHelper(),
            new QuestionHelper(),
        ));
    }
    
    private function getSttyColumns()
    {
        if (!function_exists('proc_open')) {
            return;
        }
        $descriptorspec = array(1 => array('pipe', 'w'), 2 => array('pipe', 'w'));
        $process = proc_open('stty -a | grep columns', $descriptorspec, $pipes, null, null, array('suppress_errors' => true));
        if (is_resource($process)) {
            $info = stream_get_contents($pipes[1]);
            fclose($pipes[1]);
            fclose($pipes[2]);
            proc_close($process);
            return $info;
        }
    }
    
    private function getConsoleMode()
    {
        if (!function_exists('proc_open')) {
            return;
        }
        $descriptorspec = array(1 => array('pipe', 'w'), 2 => array('pipe', 'w'));
        $process = proc_open('mode CON', $descriptorspec, $pipes, null, null, array('suppress_errors' => true));
        if (is_resource($process)) {
            $info = stream_get_contents($pipes[1]);
            fclose($pipes[1]);
            fclose($pipes[2]);
            proc_close($process);
            if (preg_match('/--------+\r?\n.+?(\d+)\r?\n.+?(\d+)\r?\n/', $info, $matches)) {
                return $matches[2].'x'.$matches[1];
            }
        }
    }
    
    private function getAbbreviationSuggestions($abbrevs)
    {
        return sprintf('%s, %s%s', $abbrevs[0], $abbrevs[1], count($abbrevs) > 2 ? sprintf(' and %d more', count($abbrevs) - 2) : '');
    }
    
    public function extractNamespace($name, $limit = null)
    {
        $parts = explode(':', $name);
        array_pop($parts);
        return implode(':', null === $limit ? $parts : array_slice($parts, 0, $limit));
    }
    
    private function findAlternatives($name, $collection)
    {
        $threshold = 1e3;
        $alternatives = array();
        $collectionParts = array();
        foreach ($collection as $item) {
            $collectionParts[$item] = explode(':', $item);
        }
        foreach (explode(':', $name) as $i => $subname) {
            foreach ($collectionParts as $collectionName => $parts) {
                $exists = isset($alternatives[$collectionName]);
                if (!isset($parts[$i]) && $exists) {
                    $alternatives[$collectionName] += $threshold;
                    continue;
                } elseif (!isset($parts[$i])) {
                    continue;
                }
                $lev = levenshtein($subname, $parts[$i]);
                if ($lev <= strlen($subname) / 3 || false !== strpos($parts[$i], $subname)) {
                    $alternatives[$collectionName] = $exists ? $alternatives[$collectionName] + $lev : $lev;
                } elseif ($exists) {
                    $alternatives[$collectionName] += $threshold;
                }
            }
        }
        foreach ($collection as $item) {
            $lev = levenshtein($name, $item);
            if ($lev <= strlen($name) / 3 || false !== strpos($item, $name)) {
                $alternatives[$item] = isset($alternatives[$item]) ? $alternatives[$item] - $lev : $lev;
            }
        }
        $alternatives = array_filter($alternatives, function ($lev) use ($threshold) { return $lev < 2*$threshold; });
        asort($alternatives);
        return array_keys($alternatives);
    }
    
    public function setDefaultCommand($commandName)
    {
        $this->defaultCommand = $commandName;
    }
    private function stringWidth($string)
    {
        if (!function_exists('mb_strwidth')) {
            return strlen($string);
        }
        if (false === $encoding = mb_detect_encoding($string)) {
            return strlen($string);
        }
        return mb_strwidth($string, $encoding);
    }
    private function splitStringByWidth($string, $width)
    {
                        
        if (!function_exists('mb_strwidth')) {
            return str_split($string, $width);
        }
        if (false === $encoding = mb_detect_encoding($string)) {
            return str_split($string, $width);
        }
        $utf8String = mb_convert_encoding($string, 'utf8', $encoding);
        $lines = array();
        $line = '';
        foreach (preg_split('//u', $utf8String) as $char) {
                        if (mb_strwidth($line.$char, 'utf8') <= $width) {
                $line .= $char;
                continue;
            }
                        $lines[] = str_pad($line, $width);
            $line = $char;
        }
        if (strlen($line)) {
            $lines[] = count($lines) ? str_pad($line, $width) : $line;
        }
        mb_convert_variables($encoding, 'utf8', $lines);
        return $lines;
    }
}
}
namespace phpex\Console{
use Symfony\Component\Console\Application as baseApplication;
use phpex\Library\MainInterface;
use phpex\Library\Main;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Helper\HelperSet;
use Doctrine\ORM\Tools\Console\ConsoleRunner;
use Doctrine\DBAL\Tools\Console\Helper\ConnectionHelper;
use Doctrine\ORM\Tools\Console\Helper\EntityManagerHelper;
class Application extends baseApplication {
    private $main;
    private $commandsRegistered = false;
    public function __construct(MainInterface $main) {
        parent::__construct("phpex Command Line Interface", Main::VERSION);
        $this->main = $main;
    }
    
    public function getMain() {
        return $this->main;
    }
    
    public function doRun(InputInterface $input, OutputInterface $output) {
        $this->main->boot();
        if (!$this->commandsRegistered) {
            $conn = $input->getParameterOption("--conn", "default");
            $helperSet = ConsoleRunner::createHelperSet(DM($conn)->getManager());
            $this->setCatchExceptions(true);
            $this->setHelperSet($helperSet);
            ConsoleRunner::addCommands($this);
            $this->main->addCommands($this);
            $this->commandsRegistered = true;
        }
        return parent::doRun($input, $output);
    }
}
}
namespace phpex\Console{
use Symfony\Component\Console\Command\Command;
class CommandFind {
    protected $commands = array();
    public function find($namespace, $path) {
        $files = glob($path . "/*Command.php");
        if ($files) {
            foreach ($files as $file) {
                $classname = $namespace . "\\Command\\" . rtrim(basename($file), ".php");
                $r = new \ReflectionClass($classname);
                if ($r->isSubclassOf('Symfony\\Component\\Console\\Command\\Command') && !$r->isAbstract() && !$r->getConstructor()->getNumberOfRequiredParameters()) {
                    $this->commands[] = $r->newInstance();
                }
            }
        }
    }
    
    public function getCommands() {
        return $this->commands;
    }
}
}
namespace phpex\DModel{
use Doctrine\ORM\EntityManager;
use Doctrine\ORM\QueryBuilder;
use phpex\Util\ORG\Page;
use Exception;
abstract class DModel {
    private static $instance = array();
    public static function getInstance() {
        $class = get_called_class();
        if (isset(self::$instance[$class])) return self::$instance[$class];
        return self::$instance[$class] = new static();
    }
    
    protected $query;
    CONST RULE_REQUIRE = '/\S+/';     CONST RULE_EMAIL = '/^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/';      CONST RULE_URL = '/^http(s?):\/\/(?:[A-za-z0-9-]+\.)+[A-za-z]{2,4}(?:[\/\?#][\/=\?%\-&~`@[\]\':+!\.#\w]*)?$/';     CONST RULE_CURRENCY = '/^\d+(\.\d+)?$/';     CONST RULE_NUMBER = '/^\d+$/';     CONST RULE_INTEGER = '/^[-\+]?\d+$/';     CONST RULE_DECIMAL = '/^[-\+]?\d+(\.\d{1,2})?$/';     CONST RULE_ENGLISH = '/^[A-Za-z]+$/';     CONST RULE_FUNCTION = 1;     CONST RULE_CALLBACK = 2;     CONST RULE_CONFIRM = 4;     CONST RULE_EQUAL = 8;     CONST RULE_IN = 16;     CONST RULE_LENGTH = 32;     CONST RULE_BETWEEN = 64;     CONST RULE_UNIQUE = 128;     CONST RULE_REGEX = 8;         const TYPE_INSERT = 1;
    const TYPE_UPDATE = 2;
    const TYPE_BOTH = 3;
    const TYPE_EMPTY = 4;
    const TYPE_EXIST = 8;
    const TYPE_VALUE = 16;
    const TYPE_ALL = 28;
        const CHECK_EXIST = 1;
    const CHECK_NEED = 2;
    const CHECK_NOT_NULL = 4;
        CONST FILL_STRING = 1;
    CONST FILL_FIELD = 2;
    CONST FILL_FUNCTION = 4;
    CONST FILL_CALLBACK = 8;
    CONST FILL_OBJECT = 16;
    const FILL_DATATIME = 32;
    protected $entity;
    protected $buildQuery;
    protected $alias;
    protected $error;
    protected $entities = array();
    protected $savelist = array();
    protected $form;
    protected $formElement = array();
    protected $selectField = "";
    protected $clearQueryCache = false;
    protected $rules = array();
    protected $srcData = array();
    protected $srcEntity = array();
    protected $checkData = array();
    protected $create = array();
    protected $fills = array();
    protected $metas;
    protected $scalar = false;
    protected $dateFormat = array(
        "date" => "Y-m-d",
        "time" => "H:i:s",
        "datetime" => "Y-m-d H:i:s"
    );
    protected $pagesize = 20;
    
    protected $manager;
    public function __construct(EntityManager $manager = null) {
        if (null === $manager) {
            $this->manager = DM()->getManager();
        } else {
            $this->manager = $manager;
        }
        try {
            $this->metas = $this->manager->getClassMetadata($this->getMapping())->fieldMappings;
        } catch (Exception $ex) {
            $trace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS);
            if ($trace[1]["class"] == "ReflectionClass")
                throw $ex;
            else
                throws($ex->getMessage(), $trace[0]["file"], $trace[0]["line"], $trace[1]["class"] . "::" . $trace[1]["function"]);
        }
        $this->_initialize();
    }
    
    protected abstract function resolveArray(&$result);
    
    protected abstract function resolveObject($result = null);
    public abstract function newEntity();
    protected function _initialize() {
    }
    public function throws(Exception $ex, $debug) {
        throws($ex->getMessage(), $debug[0]["file"], $debug[0]["line"], $ex->getCode());
    }
    public function resetDoctrine() {
        $this->getBuildQuery()->resetDQLParts();
        $this->manager->clear();
        $this->getBuildQuery()->setParameters(array());
        return $this;
    }
    public function getMetas() {
        return $this->metas;
    }
    
    public function getBuildQuery() {
        if (null === $this->buildQuery) {
            $this->getAlias();
        }
        return $this->buildQuery;
    }
    public function groupBy($groupBy) {
        $this->getBuildQuery()->groupBy($groupBy);
        return $this;
    }
    
    public function setAlias($alias) {
        $this->alias = strtolower($alias);
        $this->buildQuery = $this->manager->getRepository($this->getMapping())->createQueryBuilder($alias);
        $this->getBuildQuery()->resetDQLPart("from");
        $this->getBuildQuery()->from($this->getMapping(), $this->alias);
        return $this;
    }
    
    public function getAlias() {
        if (null === $this->alias) {
            $resolve = explode("\\", $this->getMapping());
            $this->setAlias(substr(end($resolve), 0, 1));
        }
        return $this->alias;
    }
    
    public function getMapping() {
        if (null === $this->entity) {
            $namespace = get_called_class();
            $resolve = explode("\\", $namespace);
            $entity = end($resolve);
            array_pop($resolve);
            array_pop($resolve);
            $this->entity = join("\\", $resolve) . "\\Entity\\" . substr($entity, 0, -6);
        }
        return $this->entity;
    }
    
    public function find($id) {
        try {
            $result = $this->manager->getRepository($this->getMapping())->find($id);
        } catch (Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
        if (!$result)
            return null;
        try {
            $this->resolveObject($result);
            $this->add($result);
            return $result;
        } catch (Exception $ex) {
            throws($ex->getMessage(), $ex->getFile(), $ex->getLine(), $ex->getCode());
        }
    }
    
    public function findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null) {
        try {
            $results = $this->manager->getRepository($this->getMapping())->findBy($criteria, $orderBy, $limit, $offset);
        } catch (Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
        try {
            if ($results) {
                foreach ($results as $result) {
                    $this->resolveObject($result);
                    $this->add($result);
                }
            }
            return $results;
        } catch (Exception $ex) {
            throws($ex->getMessage(), $ex->getFile(), $ex->getLine(), $ex->getCode());
        }
    }
    
    public function findAll($type = 1) {
        try {
            $results = $this->manager->getRepository($this->getMapping())->findAll();
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
        if ($results && $type == 1) {
            foreach ($results as $result) {
                $this->resolveObject($result);
                $this->add($result);
            }
            return $results;
        } else {
            $items = array();
            foreach ($results as $result) {
                $items[] = $this->toArray($result);
                $this->add($result);
            }
            return $items;
        }
        return null;
    }
    
    public function findOneBy(array $criteria, array $orderBy = null) {
        try {
            $result = $this->manager->getRepository($this->getMapping())->findOneBy($criteria, $orderBy);
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
        try {
            if ($result) {
                $this->resolveObject($result);
                $this->add($result);
            }
            return $result;
        } catch (Exception $ex) {
            throws($ex->getMessage(), $ex->getFile(), $ex->getLine(), $ex->getCode());
        }
    }
    
    public function name($alias) {
        return $this->setAlias($alias);
    }
    
    public function native($alias) {
    }
    
    public function select($fields = null) {
        if (empty($fields)) {
            $fields = $this->getAlias();
        }
        try {
            $this->selectField = $fields;
            $this->getBuildQuery()->select($fields);
            return $this;
        } catch (Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    
    public function where($where, $parameters = null, $parameter = null) {
        if (empty($where)) {
            return $this;
        }
        try {
            $this->getBuildQuery()->where($where);
            if (empty($parameters)) {
                return $this;
            }
            $args = is_array($parameters) ? $parameters : array($parameters => $parameter);
            $this->getBuildQuery()->setParameters($args);
            return $this;
        } catch (Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    
    public function andWhere($where, $parameters = null, $parameter = null) {
        if (empty($where)) {
            return $this;
        }
        try {
            $this->getBuildQuery()->andWhere($where);
            if (empty($parameters)) {
                return $this;
            }
            $args = is_array($parameters) ? $parameters : array($parameters => $parameter);
            $this->getBuildQuery()->setParameters(array_merge($this->getBuildQuery()->getParameters(), $args));
            return $this;
        } catch (Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    
    public function orWhere($where, $parameters = null, $parameter = null) {
        if (empty($where)) {
            return $this;
        }
        try {
            $this->getBuildQuery()->orWhere($where);
            if (empty($parameters)) {
                return $this;
            }
            $args = is_array($parameters) ? $parameters : array($parameters => $parameter);
            $this->getBuildQuery()->setParameters(array_merge($this->getBuildQuery()->getParameters(), $args));
            return $this;
        } catch (Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    
    public function setParameter($parameters, $parameter = null, $clear = true) {
        try {
            if (empty($parameters)) {
                return $this;
            }
            $args = is_array($parameters) ? $parameters : array($parameters => $parameter);
            if ($clear) {
                $this->getBuildQuery()->setParameters($args);
            } else {
                $this->getBuildQuery()->setParameters(array_merge($this->getBuildQuery()->getParameters(), $args));
            }
            return $this;
        } catch (Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    public function clearParameter() {
        $this->getBuildQuery()->setParameters();
        return $this;
    }
    
    public function leftJoin($entity, $alias = null, $on = null) {
        try {
            if (!$alias || !$on) {
                list($lentity, $lalias, $lon) = preg_split("\s+", $entity);
                $entity = $lentity;
                $alias = $alias ?: $lalias;
                $on = $on ?: $lon;
            }
            $this->getBuildQuery()->leftJoin($this->joinEntity($entity), $alias, "WITH", $on);
            return $this;
        } catch (Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    
    public function innerJoin($entity, $alias = null, $on = null) {
        try {
            if (!$alias || !$on) {
                list($lentity, $lalias, $lon) = preg_split("\s+", $entity);
                $entity = $lentity;
                $alias = $alias ?: $lalias;
                $on = $on ?: $lon;
            }
            $this->getBuildQuery()->innerJoin($this->joinEntity($entity), $alias, "WITH", $on);
            return $this;
        } catch (Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    protected function joinEntity($entity) {
        if (false !== strpos($entity, "\\"))
            return $entity;
        $namespace = get_called_class();
        $resolve = explode("\\", $namespace);
        $resolveentity = explode("\\", $entity);
        return $resolve[0] . "\\Entity\\" . end($resolveentity);
    }
    
    public function limit($first, $max) {
        try {
            $this->getBuildQuery()->setFirstResult($first)->setMaxResults($max);
            return $this;
        } catch (Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    
    public function setMax($number = null) {
        if ($number === null) {
            return $this;
        }
        try {
            $this->getBuildQuery()->setMaxResults($number);
            return $this;
        } catch (Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    
    public function setFirst($offset = 0) {
        try {
            $this->getBuildQuery()->setFirstResult($offset);
            return $this;
        } catch (Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    private function buildSelect() {
        $from = $this->getBuildQuery()->getDQLPart("from");
        if (empty($from)) {
            $this->select();
        }
    }
    
    public function getArray($scalar = false, $resolve = true) {
        $this->scalar = $scalar;
        $this->buildSelect();
        $this->query = $this->getBuildQuery()->getQuery();
                $this->query->expireResultCache($this->clearQueryCache);
        try {
            $results = $this->query->getResult($scalar ? 3 : 2);
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
        if (!$results)
            return null;
        try {
            if ($resolve) {
                foreach ($results as &$result) {
                    $this->resolveArray($result);
                }
            }
            return $results;
        } catch (Exception $ex) {
            throws($ex->getMessage(), $ex->getFile(), $ex->getLine(), $ex->getCode());
        }
    }
    
    public function getOneArray($scalar = false, $resolve = true) {
        $this->scalar = $scalar;
        $this->buildSelect();
        $this->query = $this->getBuildQuery()->getQuery();
        $this->query->expireResultCache($this->clearQueryCache);
        try {
            $results = $this->query->getOneOrNullResult($scalar ? 3 : 2);
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
        if (!$results)
            return null;
        try {
            if ($resolve) {
                $this->resolveArray($results);
            }
            return $results;
        } catch (Exception $ex) {
            throws($ex->getMessage(), $ex->getFile(), $ex->getLine(), $ex->getCode());
        }
    }
    
    public function getObject($resolve = true) {
        $this->buildSelect();
        $this->query = $this->getBuildQuery()->getQuery();
        $this->query->expireQueryCache($this->clearQueryCache);
        try {
            $results = $this->query->getResult();
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
        if (!$results)
            return null;
        try {
            if ($resolve) {
                foreach ($results as $result) {
                    $this->resolveObject($result);
                    $this->add($result);
                }
            }
            return $results;
        } catch (Exception $ex) {
            throws($ex->getMessage(), $ex->getFile(), $ex->getLine(), $ex->getCode());
        }
    }
    
    public function getOneObject($resolve = true) {
        $this->buildSelect();
        $this->query = $this->getBuildQuery()->getQuery();
        $this->query->expireQueryCache($this->clearQueryCache);
        try {
            $results = $this->query->setMaxResults(1)->getOneOrNullResult(1);
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
        if (!$results)
            return null;
        try {
            if ($resolve) {
                $this->resolveObject($results);
            }
            return $results;
        } catch (Exception $ex) {
            throws($ex->getMessage(), $ex->getFile(), $ex->getLine(), $ex->getCode());
        }
    }
    
    public function count() {
        $this->select("count(distinct " . $this->getAlias() . ")");
        $DQLParts = $this->getBuildQuery()->getDQLParts();
        $this->query = $this->getBuildQuery()->getQuery();
        try {
            if (count($DQLParts["groupBy"]) > 0) {
                $sql = $this->query->getSQL();
                $params = $this->query->getParameters();
                $args = array();
                foreach ($params as $p) {
                    $args[] = $p->getValue();
                }
                $sql = "select count(*) tmp from ({$sql}) as tmp_table";
                $conn = $this->manager->getConnection();
                $stat = $conn->prepare($sql);
                $stat->execute($args ?: null);
                $count = $stat->fetchColumn(0);
                return $count ?: 0;
            }
            return $this->query->getSingleScalarResult();
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    
    public function min($field) {
        try {
            $result = $this->manager->getRepository($this->getMapping())->findOneBy(array(), array($field => "ASC"));
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
        try {
            if ($resolve) {
                $this->resolveObject($result);
                $this->add($result);
            }
            return $result;
        } catch (Exception $ex) {
            throws($ex->getMessage(), $ex->getFile(), $ex->getLine(), $ex->getCode());
        }
    }
    
    public function max($field) {
        try {
            $result = $this->manager->getRepository($this->getMapping())->findOneBy(array(), array($field => "DESC"));
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
        try {
            if ($resolve) {
                $this->resolveObject($result);
                $this->add($result);
            }
            return $result;
        } catch (Exception $ex) {
            throws($ex->getMessage(), $ex->getFile(), $ex->getLine(), $ex->getCode());
        }
    }
    
    public function sum($field) {
        if (!strpos($field, "."))
            $field = $this->getAlias() . "." . $field;
        $this->select("sum(" . $field . ")");
        $this->limit(null, null);
        try {
            $this->query = $this->getBuildQuery()->getQuery();
            return $this->query->getSingleScalarResult();
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    
    public function add($entity) {
        if (!is_object($entity)) {
            $ex = new Exception("Add entities must be for the object(" . typeof($entity) . " given) ");
            $this->throws($ex, debug_backtrace());
        }
        $sid = spl_object_hash($entity);
        if (isset($this->entities[$sid])) {
            return $this;
        }
        $this->entities[$sid] = $entity;
        try {
            $this->manager->persist($entity);
            return $this;
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    
    public function save($entity = null) {
        if (!is_object($entity)) {
            $ex = new Exception("Save entities must be for the object(" . typeof($entity) . " given) ");
            $this->throws($ex, debug_backtrace());
        }
        $sid = spl_object_hash($entity);
        if (isset($this->savelist[$sid])) {
            return $this;
        }
        $this->entities[$sid] = $entity;
        $this->savelist[$sid] = $sid;
        try {
            $this->manager->persist($entity);
            return $this;
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    
    public function remove($entity) {
        if (!is_object($entity)) {
            $ex = new Exception("Remove entities must be for the object(" . typeof($entity) . " given) ");
            $this->throws($ex, debug_backtrace());
        }
        try {
            $this->manager->remove($entity);
            if (isset($this->entities[$sid])) {
                unset($this->entities[$sid]);
            }
            if (isset($this->savelist[$sid])) {
                unset($this->savelist[$sid]);
            }
            return $this;
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    
    public function setInc($field, $step = 1) {
        list($alias) = explode(".", $field);
        $this->getBuildQuery()->resetDQLPart("set");
        $this->query = $this->getBuildQuery()->update($this->getMapping(), $alias)
            ->set($field, $field . "+" . $step)
            ->getQuery();
        try {
            return $this->query->execute();
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    
    public function setDec($field, $step = 1) {
        list($alias) = explode(".", $field);
        $this->getBuildQuery()->resetDQLPart("set");
        $this->query = $this->getBuildQuery()->update($this->getMapping(), $alias)
            ->set($field, $field . "-" . $step)
            ->getQuery();
        try {
            return $this->query->execute();
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    public function update($data) {
        $this->getBuildQuery()->update();
        $this->getBuildQuery()->resetDQLPart("set");
        foreach ($data as $key => $value) {
            $this->getBuildQuery()->set($key, $value);
        }
        $this->query = $this->getBuildQuery()->getQuery();
        try {
            return $this->query->execute();
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    public function delete() {
        $this->query = $this->getBuildQuery()->delete()->getQuery();
        try {
            return $this->query->execute();
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    
    public function getField($scalar = false) {
            }
    
    public function query($sql, $params = null) {
        try {
            $stmt = $this->manager->getConnection()->prepare($sql);
            if ($params) {
                foreach ($params as $key => $val) {
                    $stmt->bindValue(":{$key}", $val);
                }
            }
            return $stmt->execute($sql);
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    
    public function execute($dql, $parameters = null) {
        try {
            return $this->manager->createQuery($dql)->execute($parameters);
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    
    public function sql($isexit = true) {
        
        $Logger = $this->manager->getConnection()->getConfiguration()->getSQLLogger();
        $sql = $Logger->lastSql();
        $str = "";
        if ($sql[0]) {
            $str .= $sql[0];
        }
        if ($sql[1]) {
            $str .= "<br> sql Params:" . http_build_query($sql[1]);
        }
        if ($sql[2]) {
            $str .= "<br> sql Params types:" . http_build_query($sql[2]);
        }
        if ($isexit) {
            echo $str;
            exit;
        } elseif ($isexit === false) {
            echo $str;
        } else {
            return $str;
        }
    }
    
    public function startTrans() {
        try {
            $this->manager->beginTransaction();
            return $this;
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    
    public function commit() {
        try {
            $this->manager->commit();
            return $this;
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    
    public function rollback() {
        try {
            $this->manager->rollback();
            return $this;
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    
    public function toArray($entity) {
        if (!$entity) {
            return "";
        }
        if (!is_object($entity)) {
            $ex = new Exception("toArray entities must be for the object(" . typeof($entity) . " given) ");
            $this->throws($ex, debug_backtrace());
        }
        $ref = new \ReflectionObject($entity);
        
        $properties = $ref->getProperties(\ReflectionMethod::IS_PRIVATE);
        $items = array();
        foreach ($properties as $property) {
            $property->setAccessible(true);
            $items[$property->getName()] = $property->getValue($entity);
        }
        $this->scalar = false;
        $this->resolveArray($items);
        return $items;
    }
    
    public function listToArray(array $lists) {
        $items = array();
        foreach ($lists as $key => $entity) {
            if (!is_object($entity)) {
                $ex = new Exception("listToArray entities item must be for the object(" . typeof($entity) . " given) ");
                $this->throws($ex, debug_backtrace());
            }
            $items[$key] = $this->toArray($entity);
        }
        return $items;
    }
    public function EntityAccess($entity) {
        return new EntityAccess($entity);
    }
    
    public function cache($key = true, $expire = null, $type = '') {
            }
    
    public function fillEntity($entity, array &$data = array(), $format = true) {
        if (!is_object($entity)) {
            $ex = new Exception("fillEntity entities must be for the object(" . typeof($entity) . " given) ");
            $this->throws($ex, debug_backtrace());
        }
        $ref = new \ReflectionObject($entity);
        
        $properties = $ref->getProperties(\ReflectionProperty::IS_PRIVATE);
        foreach ($properties as $property) {
            if (!isset($data[$property->getName()]) && !$format) {
                continue;
            }
            $property->setAccessible(true);
            $value = (isset($data[$property->getName()]) && (null !== $data[$property->getName()])) ? $data[$property->getName()] : $property->getValue($entity);
            if ($format)
                $value = $this->formatTransform($property->getName(), $value);
            $data[$property->getName()] = $value;
            $property->setValue($entity, $value);
        }
        return $entity;
    }
    
    protected function formatTransform($name, $value) {
        if (!$this->metas[$name])
            return $value;
        switch (strtolower($this->metas[$name]["type"])) {
            case "boolean":
                return (bool)$value;
            case "integer":
                return (int)$value;
            case "double":
                return (double)$value;
            case "decimal":
                return (double)number_format($value, $this->metas[$name]["scale"] ?: 2, ".", "");
            case "date":
            case "time":
            case "datetime":
                if ($value === null)
                    return null;
                return is_object($value) && $value instanceof \DateTime ? $value :
                    \DateTime::createFromFormat($this->dateFormat[strtolower($this->metas[$name])] ?: $this->dateFormat["datetime"], (string)$value);
            case "string":
            default:
                return (string)$value;
        }
    }
    public function clearEntity($entity) {
        $this->manager->clear($entity);
    }
    public function refresh($entity) {
        $this->manager->refresh($entity);
    }
    
    public function create(array &$data, $entity = null, $autoFill = "_fill") {
        if (null === $entity) {
            $entity = empty($this->entities) ? $this->newEntity() : current($this->entities);
        }
        $this->srcEntity = $entity ? clone $entity : null;
        try {
            $data = $this->autoFill($data, $entity, $autoFill);
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
        if (empty($data)) {
            return $this;
        }
        try {
            $this->fillEntity($entity, $data);
            $this->create = array($entity, $data);
            return $this;
        } catch (Exception $ex) {
            if ($ex instanceof \phpex\Error\Exception) {
                throw $ex;
            }
            $this->throws($ex, debug_backtrace());
        }
    }
    private function autoFill($data, $entity, $method = "_fill") {
        if (!$entity || !is_object($entity)) {
            throw new Exception("autoFill entities must be for the object(" . typeof($entity) . " given) ");
        }
        $this->srcData = $data;
        $methods = explode(",", $method);
        foreach ($methods as $m) {
            if (method_exists($this, $m))
                $this->{$m}();
        }
        $ref = new \ReflectionObject($entity);
        
        $idpro = $ref->hasProperty("id") ? $ref->getProperty("id") : false;
        $idpro && $idpro->setAccessible(true);
        if ($idpro && $idpro->getValue($entity)) {
            $trigger = self::TYPE_UPDATE;
        } else {
            $trigger = self::TYPE_INSERT;
        }
        $items = array();
        foreach ($this->fills as $fill) {
            $item = isset($data[$fill["name"]]) ? $data[$fill["name"]] : null;
            if (!($fill["type"] & $trigger))
                continue;
            if (null === $item && !($fill["type"] & self::TYPE_EXIST))
                continue;
            if (empty($item) && !($fill["type"] & self::TYPE_EMPTY))
                continue;
            if (!empty($item) && !($fill["type"] & self::TYPE_VALUE))
                continue;
            switch ($fill["rule"]) {
                case self::FILL_STRING;
                case self::FILL_OBJECT;
                    $items[$fill["name"]] = $fill["params"];
                    break;
                case self::FILL_FIELD:
                    if (isset($data[$fill["params"]])) {
                        $items[$fill["name"]] = $data[$fill["params"]];
                    } elseif ($ref->hasProperty($fill["params"])) {
                        $pro = $ref->getProperty($fill["params"]);
                        $pro->setAccessible(true);
                        $items[$fill["name"]] = $pro->getValue($entity);
                    }
                    break;
                case self::FILL_FUNCTION:
                    $func = new \ReflectionFunction($fill["params"]);
                    $params = $func->getParameters();
                    if (isset($params[1]) && $params[1]->getName() == "entity")
                        $items[$fill["name"]] = $func->invoke($item, $entity);
                    else
                        $items[$fill["name"]] = $func->invoke($item);
                    break;
                case self::FILL_CALLBACK:
                    $items[$fill["name"]] = call_user_func(array(&$this, $fill["params"]), $item, $entity);
                    break;
                case self::FILL_DATATIME:
                    $items[$fill["name"]] = $item instanceof \DateTime ? $item :
                        \DateTime::createFromFormat($fill["params"] ?: $this->dateFormat["datetime"], (string)$item ?: now());
                    break;
            }
        }
        foreach ($items as $key => $value) {
            $data[$key] = $value;
        }
        return $data;
    }
    
    public function addFill($name, $params, $rule = self::FILL_STRING, $trigger_type = self::TYPE_INSERT) {
        if ($trigger_type & self::TYPE_EMPTY || $trigger_type & self::TYPE_EXIST || $trigger_type & self::TYPE_VALUE) {
            $trigger = $trigger_type;
        } else {
            $trigger = $trigger_type | self::TYPE_ALL;
        }
        $this->fills[] = array(
            "name" => $name,
            "rule" => $rule,
            "params" => $params,
            "type" => $trigger
        );
        return $this;
    }
    
    public function check(array $data = array(), $entity = null, $autoCheck = "_check") {
        if (isset($this->create[0]) && null === $entity)
            $entity = $this->create[0];
        if (isset($this->create[1]) && empty($data))
            $data = $this->create[1];
        if (!$entity || !is_object($entity)) {
            $ex = new Exception("check entities must be for the object(" . typeof($entity) . " given) ");
            $this->throws($ex, debug_backtrace());
        }
        $methods = explode(",", $autoCheck);
        try {
            foreach ($methods as $m) {
                if (method_exists($this, $m))
                    $this->{$m}();
            }
        } catch (Exception $ex) {
            throws($ex->getMessage(), $ex->getFile(), $ex->getLine(), $ex->getCode());
        }
        $this->checkData = $data;
        if (method_exists($entity, "getId") && $entity->getId()) {
            return $this->_updateCheck($data, $entity);
        } else {
            return $this->_insertCheck($data, $entity);
        }
    }
    public function getError() {
        return $this->error;
    }
    public function flush($entity = null) {
        try {
            $this->manager->flush($entity);
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
    }
    
    public function order($sort, $order = null) {
        $this->getBuildQuery()->addOrderBy($sort, $order);
        return $this;
    }
    public function data_sort($value = "", $key = "data_sort") {
        if (!$value) $value = Q()->get->get($key);
        if ($value) {
            $sorts = explode("|", $value);
            $this->getBuildQuery()->addOrderBy($sorts[0], isset($sorts[1]) && $sorts[1] != 2 ? "ASC" : "DESC");
        }
        return $this;
    }
    
    public function addRule($name, $rule, $msg, $params = "", $condition = self::CHECK_EXIST, $trigger_type = self::TYPE_BOTH, $data_type = 3) {
        $this->rules[$name][$rule] = array("msg" => $msg, "params" => $params, "condition" => $condition, "type" => $trigger_type, "data_type" => $data_type);
        return $this;
    }
    private function _insertCheck($datas, $entity) {
        $items = array();
        foreach ($this->rules as $field => $rules) {
            foreach ($rules as $rule => $params) {
                if ($params["type"] === self::TYPE_UPDATE) {
                    continue;
                }
                if ($params["data_type"] == 1) {
                    $items[$field] = $this->srcData[$field];
                } elseif ($params["data_type"] == 3 && isset($this->srcData[$field])) {
                    $items[$field] = $this->srcData[$field];
                } else {
                    $items[$field] = $datas[$field];
                }
                if (!isset($items[$field]) && $params["condition"] === self::CHECK_EXIST) {
                    continue;
                }
                if ((!isset($items[$field]) || empty($items[$field])) && $params["condition"] === self::CHECK_NOT_NULL) {
                    continue;
                }
                if (!isset($items[$field])) {
                    $this->error = $params["msg"];
                    return false;
                }
                if (empty($items[$field])) {
                    $this->error = $params["msg"];
                    return false;
                }
                if (isset($this->validate[$rule])) {
                    if (!preg_match($this->validate[$rule], $items[$field])) {
                        $this->error = $params["msg"];
                        return false;
                    }
                    continue;
                }
                $switch = $this->_switch($rule, $field, $params, $items, $entity);
                if (!$switch) {
                    $this->error = $params["msg"];
                    return FALSE;
                }
                if ($rule == self::RULE_UNIQUE) {
                    $result = $this->manager->getRepository($this->getMapping())->findOneBy(array($field => $items[$field]));
                    if ($result) {
                        $this->error = $params["msg"];
                        return false;
                    }
                }
            }
        }
        return true;
    }
    private function _updateCheck($datas, $entity) {
        $items = array();
        foreach ($this->rules as $field => $rules) {
            foreach ($rules as $rule => $params) {
                if ($params["type"] === self::TYPE_INSERT) {
                    continue;
                }
                if ($params["data_type"] == 1) {
                    $items[$field] = $this->srcData[$field];
                } elseif ($params["data_type"] == 3 && isset($this->srcData[$field])) {
                    $items[$field] = $this->srcData[$field];
                } else {
                    $items[$field] = $datas[$field];
                }
                if (!isset($items[$field]) && $params["condition"] === self::CHECK_EXIST) {
                    continue;
                }
                if ((!isset($items[$field]) || empty($items[$field])) && $params["condition"] === self::CHECK_NOT_NULL) {
                    continue;
                }
                if (!isset($items[$field])) {
                    $this->error = $params["msg"];
                    return false;
                }
                if (empty($items[$field])) {
                    $this->error = $params["msg"];
                    return false;
                }
                if (isset($this->validate[$rule])) {
                    if (!preg_match($this->validate[$rule], $items[$field])) {
                        $this->error = $params["msg"];
                        return false;
                    }
                    continue;
                }
                $switch = $this->_switch($rule, $field, $params, $items, $entity);
                if (!$switch) {
                    $this->error = $params["msg"];
                    return FALSE;
                }
                if ($rule == self::RULE_UNIQUE) {
                    $result = $this->manager->getRepository($this->getMapping())->findOneBy(array($field => $items[$field]));
                    if ($result && $result->getId() != $entity->getId()) {
                        $this->error = $params["msg"];
                        return false;
                    }
                }
            }
        }
        return true;
    }
    private function _switch($rule, $field, $params, $data, $entity) {
        switch ($rule) {
            case self::RULE_REGEX:
                if (!preg_match($params["params"], $data[$field])) {
                    return false;
                }
                break;
            case self::RULE_FUNCTION:
                $validate = call_user_func($params["params"], $data[$field], $entity);
                if (!$validate) {
                    return false;
                }
                break;
            case self::RULE_CALLBACK:
                $validate = call_user_func(array(&$this, $params["params"]), $data[$field], $entity);
                if (!$validate) {
                    return false;
                }
                break;
            case self::RULE_CONFIRM:
                if ($data[$field] != $data[$params["params"]]) {
                    return false;
                }
                break;
            case self::RULE_EQUAL:
                if ($data[$field] != $params["params"]) {
                    return false;
                }
                break;
            case self::RULE_IN:
                $arrays = is_array($params["params"]) ? $params["params"] : explode(",", $params["params"]);
                if (!in_array($data[$field], $arrays)) {
                    return false;
                }
                break;
            case self::RULE_LENGTH:
                $arrays = is_array($params["params"]) ? $params["params"] : explode(",", $params["params"]);
                if (strlen($data[$field]) < $arrays[0]) {
                    return false;
                }
                if (isset($arrays[1]) && strlen($data[$field]) > $arrays[1]) {
                    return false;
                }
                break;
            case self::RULE_BETWEEN:
                $arrays = is_array($params["params"]) ? $params["params"] : explode(",", $params["params"]);
                if (($data[$field]) < $arrays[0]) {
                    return false;
                }
                if (isset($arrays[1]) && ($data[$field]) > $arrays[1]) {
                    return false;
                }
                break;
        }
        return true;
    }
    public function setPage(Page $page = null) {
        if (null === $page) {
            $page = ins()->get("app." . ucfirst(R()->getAppName()))->getRunController()->page();
        }
        $selectField = $this->selectField;
        $page->setTotal($this->count());
        if ($page->showEvent()) {
            $this->limit($page->firstRow, $page->listRows);
        }
        try {
            $this->select($selectField);
        } catch (\Exception $ex) {
            $this->throws($ex, debug_backtrace());
        }
        return $this;
    }
    
    public function page($pagination = 0, $size = null) {
        if (is_numeric($size)) {
            $size = (int)$size;
        } else {
            $size = $this->pagesize;
        }
        $this->setFirst($pagination * $size)->setMax($size);
        return $this;
    }
}
}
namespace phpex\DModel{
use Exception;
class DModelInstance {
    public $defaultNamespace = "Admin";
    private $instances = array();
    public function __call($name, $arguments) {
        if (isset($this->instances[$name])) {
            return $this->instances[$name];
        }
        if (strpos("_", $name))
            list($DModel, $namespace) = explode("_", $name, 2);
        else {
            $namespace = &$this->defaultNamespace;
            $DModel = &$name;
        }
        try {
            $ref = new \ReflectionClass($namespace . "\\DModel\\" . $DModel . "DModel");
            $this->instances[$name] = $ref->newInstanceArgs($arguments);
        } catch (Exception $ex) {
            $trace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS);
            throws($ex->getMessage(), $trace[0]["file"], $trace[0]["line"], $trace[1]["class"] . "::" . $trace[1]["function"]);
        }
        return $this->instances[$name];
    }
}
}
namespace phpex\DModel{
class EntityAccess implements \Iterator, \ArrayAccess, \Countable {
    private $entity = null;
    
    private $pro = array();
    public function __construct($entity) {
        $this->entity = $entity;
        if ($entity && is_object($entity)) {
            $ref = new \ReflectionObject($entity);
            $properties = $ref->getProperties(\ReflectionProperty::IS_PRIVATE);
            foreach ($properties as $pro) {
                $pro->setAccessible(true);
                $this->pro[$pro->name] = $pro;
            }
        }
    }
    public function __call($method, $arg) {
        if ($this->entity && is_object($this->entity) && method_exists($this->entity, $method)) {
            return call_user_func_array(array($this->entity, $method), $arg);
        }
        return null;
    }
    
    public function offsetExists($offset) {
        return isset($this->pro[$offset]);
    }
    
    public function offsetGet($offset) {
        if ($this->entity && is_object($this->entity) && isset($this->pro[$offset])) {
            return $this->pro[$offset]->getValue($this->entity);
        }
        return null;
    }
    
    public function offsetSet($offset, $value) {
        if ($this->entity && is_object($this->entity) && isset($this->pro[$offset])) {
            $this->pro[$offset]->setValue($this->entity, $value);
        }
    }
    
    public function offsetUnset($offset) {
        throw new \Exception('Do not allow the deleted from the Result');
    }
    
    public function count($mode = 'COUNT_NORMAL') {
        return count($this->pro);
    }
    
    public function key() {
        return key($this->pro);
    }
    
    public function rewind() {
        reset($this->pro);
    }
    
    public function valid() {
        return key($this->pro) !== null;
    }
    
    public function current() {
        $key = key($this->pro);
        if ($key !== null) {
            return $this->offsetGet($key);
        }
        return null;
    }
    
    public function next() {
        next($this->pro);
    }
}
}
namespace phpex\Driver{
use Doctrine\ORM\EntityManager;
interface DbInterFace {
    
    public function setOptions($options = null, $value = "");
   
    
    public function getManager();
    
    public function addPath($namespace, $path);
}
}
namespace phpex\Driver{
use Doctrine\ORM\EntityManager,
    Doctrine\Common\Cache\ArrayCache,
    Doctrine\Common\Cache\ApcCache,
    Doctrine\ORM\Configuration;
use Doctrine\Common\Persistence\Mapping\Driver\phpexFileLocator,
    Doctrine\ORM\Mapping\Driver\PHPDriver,
    Doctrine\ORM\Mapping\Driver\XmlDriver,
    Doctrine\ORM\Mapping\Driver\YamlDriver;
class Doctrine implements DbInterFace {
    protected $configs = array();
    protected $options = array();
    protected $paths = array();
    protected $entityManager;
    
    protected $lastStatement;
    
    public function __construct() {
        
    }
    public function setOptions($options = null, $value = "") {
        if (empty($options)) {
            return true;
        }
        if (is_array($options)) {
            $this->options = array_merge($this->options, $options);
            return true;
        }
        $this->options[$options] = $value;
    }
    public function addPath($namespace, $path) {
        $this->paths[$namespace] = $path;
        return true;
    }
    
    public function create($configure, $paths, $mapType = "yml", $isDevMode = false) {
        foreach ($paths as $namespace => $path) {
            $this->addPath($namespace, $path);
        }
        $config = $this->getConfig($this->paths, $mapType, $isDevMode);
        $config->addCustomStringFunction("REGEXP", "phpex\Driver\Regexp" . preg_replace("/_([a-z])/", '$1', ucfirst($configure["driver"])));
        $this->entityManager = EntityManager::create($configure, $config, $this->getPrefixEvent($configure["prefix"]));
    }
    private function getPrefixEvent($prefix) {
        $evm = new \Doctrine\Common\EventManager;
        $tablePrefix = new TablePrefix($prefix);
        $evm->addEventListener(\Doctrine\ORM\Events::loadClassMetadata, $tablePrefix);
        return $evm;
    }
    private function getConfig($paths, $mapType = "yml", $isDevMode = false) {
                $cache = new ArrayCache();
                $config = new Configuration();
        $config->setMetadataCacheImpl($cache);
        switch (strtolower($mapType)) {
            case "annotation":
                $locator = new phpexFileLocator($paths);
                $driver = new PHPDriver($locator);
                break;
            case "xml":
                $locator = new phpexFileLocator($paths, ".xml");
                $driver = new XmlDriver($locator);
                break;
            case "yml":
            default:
                $locator = new phpexFileLocator($paths, ".yml");
                $driver = new YamlDriver($locator);
        }
        $config->setMetadataDriverImpl($driver);
        $config->setQueryCacheImpl($cache);
        $proxies = main()->getRuntime() . "/roxies";
        if (!is_dir($proxies))
            mkdir($proxies, 777, true);
        $config->setProxyDir($proxies);
        $config->setProxyNamespace('runtime\cache\proxies');
        $config->setAutoGenerateProxyClasses($isDevMode);
        $config->setSQLLogger(new SQLLogger());
        return $config;
    }
    
    public function getManager() {
        return $this->entityManager;
    }
    public function execute($sql, $params = array(), $prefix = "") {
        $this->lastStatement = $stmt = $this->prepare($sql, $prefix);
        try {
            $result = $stmt->execute($params);
        } catch (\Exception $ex) {
            debug_throws("%d:'%s'", $stmt->errorCode(), $ex->getMessage());
        }
        return $result;
    }
    public function getLastStatement() {
        return $this->lastStatement;
    }
    
    public function prepare($sql, $prefix = "") {
        if (!$prefix)
            $prefix = C("database.default.prefix");
        $sql = preg_replace("/__(\w+)__/", $prefix . '$1', $sql);
        $conn = $this->getManager()->getConnection();
        return $conn->prepare($sql);
    }
}
}
namespace Doctrine\ORM\Query\AST{
abstract class Node
{
    
    public function dispatch($walker)
    {
        throw ASTException::noDispatchForNode($this);
    }
    
    public function __toString()
    {
        return $this->dump($this);
    }
    
    public function dump($obj)
    {
        static $ident = 0;
        $str = '';
        if ($obj instanceof Node) {
            $str .= get_class($obj) . '(' . PHP_EOL;
            $props = get_object_vars($obj);
            foreach ($props as $name => $prop) {
                $ident += 4;
                $str .= str_repeat(' ', $ident) . '"' . $name . '": '
                      . $this->dump($prop) . ',' . PHP_EOL;
                $ident -= 4;
            }
            $str .= str_repeat(' ', $ident) . ')';
        } else if (is_array($obj)) {
            $ident += 4;
            $str .= 'array(';
            $some = false;
            foreach ($obj as $k => $v) {
                $str .= PHP_EOL . str_repeat(' ', $ident) . '"'
                      . $k . '" => ' . $this->dump($v) . ',';
                $some = true;
            }
            $ident -= 4;
            $str .= ($some ? PHP_EOL . str_repeat(' ', $ident) : '') . ')';
        } else if (is_object($obj)) {
            $str .= 'instanceof(' . get_class($obj) . ')';
        } else {
            $str .= var_export($obj, true);
        }
        return $str;
    }
}
}
namespace Doctrine\ORM\Query\AST\Functions{
use Doctrine\ORM\Query\AST\Node;
abstract class FunctionNode extends Node
{
    
    public $name;
    
    public function __construct($name)
    {
        $this->name = $name;
    }
    
    abstract public function getSql(\Doctrine\ORM\Query\SqlWalker $sqlWalker);
    
    public function dispatch($sqlWalker)
    {
        return $sqlWalker->walkFunction($this);
    }
    
    abstract public function parse(\Doctrine\ORM\Query\Parser $parser);
}
}
namespace phpex\Driver{
use Doctrine\ORM\Query\AST\Functions\FunctionNode;
use Doctrine\ORM\Query\Lexer;
class RegexpOci8 extends FunctionNode {
    public $firstRegExExpression = null;
    public $secondRegExExpression = null;
    
    public function parse(\Doctrine\ORM\Query\Parser $parser) {
        $parser->match(Lexer::T_IDENTIFIER);
        $parser->match(Lexer::T_OPEN_PARENTHESIS);
        $this->firstRegExExpression = $parser->StringPrimary();
        $parser->match(Lexer::T_COMMA);
        $this->secondRegExExpression = $parser->StringPrimary();
        $parser->match(Lexer::T_CLOSE_PARENTHESIS);
    }
    
    public function getSql(\Doctrine\ORM\Query\SqlWalker $sqlWalker) {
        return 'REGEXP_LIKE(' . $this->firstRegExExpression->dispatch($sqlWalker) . ',' . $this->secondRegExExpression->dispatch($sqlWalker) . ')AND 1';
    }
}
}
namespace phpex\Driver{
use Doctrine\ORM\Query\AST\Functions\FunctionNode;
use Doctrine\ORM\Query\Lexer;
class RegexpPdomysql extends FunctionNode {
    public $firstRegExExpression = null;
    public $secondRegExExpression = null;
    
    public function parse(\Doctrine\ORM\Query\Parser $parser) {
        $parser->match(Lexer::T_IDENTIFIER);
        $parser->match(Lexer::T_OPEN_PARENTHESIS);
        $this->firstRegExExpression = $parser->StringPrimary();
        $parser->match(Lexer::T_COMMA);
        $this->secondRegExExpression = $parser->StringPrimary();
        $parser->match(Lexer::T_CLOSE_PARENTHESIS);
    }
    
    public function getSql(\Doctrine\ORM\Query\SqlWalker $sqlWalker) {
        return '(SELECT ' . $this->firstRegExExpression->dispatch($sqlWalker) . ' REGEXP ' . $this->secondRegExExpression->dispatch($sqlWalker) . ')';
    }
}
}
namespace Doctrine\DBAL\Logging{
interface SQLLogger
{
    
    public function startQuery($sql, array $params = null, array $types = null);
    
    public function stopQuery();
}
}
namespace phpex\Driver{
use Doctrine\DBAL\Logging\SQLLogger as ISQLLogger;
class SQLLogger implements ISQLLogger {
    private $sqls = array();
    public function startQuery($sql, array $params = null, array $types = null) {
        static $i = 0;
        $this->sqls[$i] = array($sql, $params, $types);
    }
    public function stopQuery() {
        
    }
    public function sql() {
        return $this->sqls;
    }
    public function lastSql() {
        end($this->sqls);
        $sql = current($this->sqls);
        reset($this->sqls);
        return $sql;
    }
}
}
namespace phpex\Driver{
use Doctrine\ORM\Event\LoadClassMetadataEventArgs;
class TablePrefix {
    protected $prefix = '';
    public function __construct($prefix) {
        $this->prefix = (string) $prefix;
    }
    public function loadClassMetadata(LoadClassMetadataEventArgs $eventArgs) {
        $classMetadata = $eventArgs->getClassMetadata();
        $classMetadata->setTableName($this->prefix . $classMetadata->getTableName());
        foreach ($classMetadata->getAssociationMappings() as $fieldName => $mapping) {
            if ($mapping['type'] == \Doctrine\ORM\Mapping\ClassMetadataInfo::MANY_TO_MANY) {
                $mappedTableName = $classMetadata->associationMappings[$fieldName]['joinTable']['name'];
                $classMetadata->associationMappings[$fieldName]['joinTable']['name'] = $this->prefix . $mappedTableName;
            }
        }
    }
}
}
namespace phpex\Error{
class ErrorHandler {
    public function register_shutdown_function($callable) {        
        if (is_callable($callable)) {
            register_shutdown_function($callable);
        }       
    }
    public function set_error_handler($callable) {
        if (is_callable($callable)) {
            set_error_handler($callable);
        }
    }
    public function set_exception_handler($callable) {
        if (is_callable($callable)) {
            set_exception_handler($callable);
        }
    }
}
}
namespace phpex\Error{
use Exception as BaseException;
class Exception extends BaseException {
    
    public $sourceCode;
    
    public $sourceName;
    
    public $sourceLine;
    public function setSource($code, $line, $file = NULL) {
        $this->sourceCode = (string) $code;
        $this->sourceLine = (int) $line;
        $this->sourceName = (string) $file;
        if (is_file($file)) {
            $this->message = rtrim($this->message, '.')
                    . ' in ' . dirtrim($file) . ($line ? ":$line" : '');
        }
        return $this;
    }
}
}
namespace phpex\Error{
use phpex\Foundation\Response;
class phpexError {
    static public $httpStatus = 500;
    static public $context = array();
    public static function fatalError() {
        if ($e = error_get_last()) {
            self::appError($e['type'], $e['message'], $e['file'], $e['line'], 1);
        }
    }
    static public function getFileSerial($filepath) {
        $file = main()->getRuntime() . "/FileSerial.log";
        $filepath = realpath($filepath);
        $serial = file_get_contents($file);
        $lists = explode("\r\n", $serial);
        $compare = md5($filepath);
        foreach ($lists as $line) {
            list($linecode, $md5code, $fileinfo) = explode("#", $line);
            if (!$linecode || !$md5code || !$fileinfo) {
                continue;
            }
            if ($md5code == $compare) {
                return $linecode;
            }
        }
        $linecode or $linecode = 0;
        $linecode++;
        file_put_contents($file, ltrim($serial) . "\r\n" . $linecode . "#" . $compare . "#" . $filepath);
        return $linecode;
    }
    static public function appError($errno, $errstr, $errfile, $errline, $type = 0) {
        $debug = main()->getDebug();
        self::$context = $context = array(
            'levels' => $errno,
            'code' => self::getFileSerial($errfile) . "-" . $errline . "-" . date("dH"),
        );
        switch ($errno) {
            case E_ERROR:
            case E_PARSE:
            case E_CORE_ERROR:
            case E_COMPILE_ERROR:
            case E_USER_ERROR:
                $errorStr = "$errstr " . $errfile . " in Line $errline.";
                if ($debug || $type == 1)
                    logger(\Monolog\Logger::ERROR, $errno)->addError($errorStr, $context);
                break;
            case E_USER_WARNING:
                $errorStr = "[$errno] $errstr " . $errfile . " in line: $errline .";
                if ($debug || $type == 1)
                    logger(\Monolog\Logger::WARNING, $errno)->addWarning($errorStr, $context);
                break;
            case E_STRICT:
            case E_USER_NOTICE:
            default:
                $errorStr = "[$errno] $errstr " . $errfile . " in line: $errline .";
                if ($debug || $type == 1)
                    logger(\Monolog\Logger::NOTICE, $errno)->addNotice($errorStr, $context);
                return;
        }
        self::halt($errorStr, $type);
    }
    public static function appException($e) {
        $error = array();
        $error['message'] = $e->getMessage();
        $trace = $e->getTrace();
        if ('E' == $trace[0]['function']) {
            $error['file'] = $trace[0]['file'];
            $error['line'] = $trace[0]['line'];
        } else {
            $error['file'] = $e->getFile();
            $error['line'] = $e->getLine();
        }
        $error['trace'] = $e->getTraceAsString();
        self::$context = $context = array(
            'levels' => E_ERROR,
            'code' => self::getFileSerial($error['file']) . "-" . $error['line'] . "-" . date("dH"),
        );
        $context["file"] = $error['file'];
        $context["line"] = $error['line'];
        logger(\Monolog\Logger::ERROR, E_ERROR)->addError($error['message'], $context);
        self::halt($error, 1);
    }
    public static function halt($error) {
        $env = main()->getEnv();
        $config = C("error");
        if (main()->getDebug()) {
            if (!is_array($error)) {
                $trace = debug_backtrace();
                $e['message'] = $error;
                $e['file'] = $trace[0]['file'];
                $e['class'] = isset($trace[0]['class']) ? $trace[0]['class'] : '';
                $e['function'] = isset($trace[0]['function']) ? $trace[0]['function'] : '';
                $e['line'] = $trace[0]['line'];
                $traceInfo = '';
                $time = date('y-m-d H:i:m');
                foreach ($trace as $t) {
                    $traceInfo .= '[' . $time . '] ';
                    if (isset($t['file']))
                        $traceInfo.= $t['file'];
                    if (isset($t['file']))
                        $traceInfo.= ' (' . $t['line'] . ') ';
                    if (isset($t['class']))
                        $traceInfo.= $t['class'];
                    if (isset($t['type']))
                        $traceInfo.= $t['type'];
                    if (isset($t['function']))
                        $traceInfo.= $t['function'];
                    $traceInfo .=' parameters (" ';
                    if (is_array($t['args']) && !empty($t['args'])) {
                        foreach ($t['args'] as $arg) {
                            $traceInfo .= is_object($arg) ? 'object(' . get_class($arg) . ') , ' : (is_scalar($arg) ? $arg . " , " : "array() , ");
                        }
                        $traceInfo = rtrim($traceInfo, ", ") . " ";
                    }
                    $traceInfo .='")<br/>';
                }
                $e['trace'] = $traceInfo;
            } else {
                $e = $error;
            }
        } else {
            if (isset($config['show_error_msg']) && $config['show_error_msg'])
                $e['message'] = is_array($error) ? $error['message'] : $error;
            else
                $e['message'] = isset($config['error_msg']) ? $config['error_msg'] : "";
        }
        $error_page = isset($config['error_page']) ? $config['error_page'] : null;
        if (Q()->isAjax()) {
            header(sprintf('HTTP/1.1 %d %s', 200, Response::$statusTexts[200]));
            echo json_encode(array("status" => "n", "info" => "抱歉，您访问的页面出现错误，跟踪代码：" . self::$context["levels"] . "-" . self::$context["code"]));
            exit;
        }
        if (!empty($error_page) && $env == "prod" && is_file($error_page)) {
            header(sprintf('HTTP/1.1 %d %s', self::$httpStatus, Response::$statusTexts[self::$httpStatus]));
            include $error_page;
            exit;
        }
        if (isset($config['tmpl_exception_file'][$env])) {
            header(sprintf('HTTP/1.1 %d %s', self::$httpStatus, Response::$statusTexts[self::$httpStatus]));
            include $config['tmpl_exception_file'][$env];
        } else {
            $server_admin = Q()->server->get("SERVER_ADMIN");
            $response = new Response("服务器内部错误，详情请联系:$server_admin", self::$httpStatus, array("Content-Type" => "text/html;charset=utf-8"));
            $response->send();
        }
        exit;
    }
}
}
namespace phpex\Event{
interface EventInterface {
    
    public function getName();
    
    public function setTimes(EventTime $eventTime);
    
    public function __construct(EventContainer $container);
}
}
namespace phpex\Event{
abstract class Event implements EventInterface {
    protected $eventTime;
    protected $container;
    private $basename;
    public function __construct(EventContainer $container) {
        $this->eventTime = new EventTime();
        $this->container = $container;
        $this->_initialize();
        $this->registerEvent($container);
    }
    protected function _initialize() {
        
    }
    private function registerEvent(EventContainer $container) {
        $this->setTimes($this->eventTime);
        $setTimes = $this->eventTime->getTimes();
        $rf = new \ReflectionObject($this);
        $methods = $rf->getMethods(\ReflectionMethod::IS_PUBLIC);
        foreach ($methods as $method) {
            $name = $method->getName();
            if ("on" == substr($name, 0, 2))
                $event = strtolower(substr($name, 2));
            else
                continue;
            $time = isset($setTimes[$event]) ? $setTimes[$event] : 0;
            $callback = array(&$this, $name);
            $container->register($this->getBaseame() . $event, $callback, $time);
        }
    }
    private function getBaseame() {
        if (null === $this->basename) {
            $basename = $this->getName()? : get_class($this);
            $basenameResolve = explode("\\", $basename);
            $basename = end($basenameResolve);
            $this->basename = strtolower(substr($basename,0,-5)) . ".";
        }     
        return $this->basename;
    }
}
}
namespace phpex\Event{
class EventContainer {
    
    private $event;
    public function __construct() {
        $this->event = new EventEmitter();
    }
    
    public function register($event, $callback, $time = 0) {
        if (!is_callable($callback) || !is_int($time))
            return FALSE;
        if (0 == $time) {
            $this->event->on($event, $callback);
            return true;
        } elseif (1 == $time) {
            $this->event->once($event, $callback);
            return true;
        } else {
            $this->event->many($event, $time, $callback);
            return true;
        }
        return false;
    }
    
    public function off($event, $callback = null) {
        $this->event->off($event, $callback);
    }
    
    public function offAll($event = null) {
        $this->event->removeAllListeners($event);
    }
    
    public function trigger($event, $args = null) {
        $args = (null === $args) ? array($event) : func_get_args();
        return call_user_func_array(array(&$this->event, "emit"), $args);
    }
    
    public function getResult($event = null) {
        return $this->event->getResult($event);
    }
    
    public function load($namespace, $path) {
        $files = glob($path . "/*Event.php");       
        if ($files) {
            foreach ($files as $file) {
                $classname = $namespace . "\\Listener\\Event\\" . rtrim(basename($file), ".php");
                $r = new \ReflectionClass($classname);
                if ($r->isSubclassOf('phpex\\Event\\Event') && !$r->isAbstract()) {
                    $r->newInstance($this);
                }
            }
        }
    }
}
}
namespace phpex\Event{
if (function_exists('FNMATCH')) {
    define('FNMATCH', true);
} else {
    define('FNMATCH', false);
}
class EventEmitter {
    
    protected $listeners = array();
    protected $result = array();
    protected $lastevent;
    
    public function emit($event, $args = null) {
        $event = strtolower($event);
        $args = (null === $args) ? array() : array_slice(func_get_args(), 1);
        $all_listeners = array();
        foreach ($this->listeners as $name => $listeners) {
            if (strpos($name, '*') === false || !self::match($name, $event)) {
                continue;
            }
            foreach ($this->listeners[$name] as &$listener) {
                $all_listeners[$name][] = & $listener;
            }
        }
        if (!empty($this->listeners[$event])) {
            foreach ($this->listeners[$event] as &$listener) {
                $all_listeners[$event][] = & $listener;
            }
        }
        $emitted = false;
                foreach ($all_listeners as $name => $listeners) {
            $this_args = $args;
            if (strpos($name, '*') !== false) {
                array_push($this_args, $event);
            }
            foreach ($listeners as &$listener) {
                if (is_callable($listener)) {
                                        $this->result[$event][$name] = call_user_func_array($listener, $this_args);
                    $emitted = true;
                } elseif (is_array($listener) && is_callable($listener[0])) {
                    if ($listener[1]['times'] > 0) {
                                                $this->result[$event][$name] = call_user_func_array($listener[0], $this_args);
                        $emitted = true;
                        $listener[1]['times'] --;
                    }
                }
            }
        }
        $this->lastevent = $event;
        $result = isset($this->result[$event]) ? $this->result[$event] : null;
        $eventResolve = explode(".", $event);
        if (1 == count($eventResolve)) {
            $eventname = $event;
        } else {
            $count = count($eventResolve);
            if (is_numeric($eventResolve[$count - 1])) {
                $eventResolve[$count - 1] = "*";
            }
            $eventname = join(".", $eventResolve);
        }       
        if (is_array($result) && 1 == count($result) && isset($result[$eventname])) {
            $this->result[$event] = $result[$eventname];
        }
        return $emitted;
    }
    public function getResult($event = null) {
        if (true === $event)
            return $this->result;
        if (null === $event) {
            $event = $this->lastevent;
        }
        return isset($this->result[$event]) ? $this->result[$event] : null;
    }
    
    public function on($event, $listener) {
        if (!is_callable($listener))
            return $this;
        foreach ((array) $event as $e) {
            $this->listeners[strtolower($e)][] = $listener;
        }
        return $this;
    }
    
    public function once($event, $listener) {
        if (!is_callable($listener))
            return $this;
        foreach ((array) $event as $e) {
            $this->listeners[strtolower($e)][] = array($listener, array('times' => 1));
        }
        return $this;
    }
    
    public function many($event, $times = 1, $listener) {
        if (!is_callable($listener))
            return $this;
        foreach ((array) $event as $e) {
            $this->listeners[strtolower($e)][] = array($listener, array('times' => $times));
        }
        return $this;
    }
    
    public function off($event, $listener = null) {
        foreach ((array) $event as $e) {
            $e = strtolower($e);
            if (!empty($this->listeners[$e])) {
                if (!is_callable($listener)) {
                    unset($this->listeners[$e]);
                    continue;
                }
                if (($key = array_search($listener, $this->listeners[$e])) !== false) {
                    unset($this->listeners[$e][$key]);
                }
            }
        }
        return $this;
    }
    
    public function listeners($event) {
        if (!empty($this->listeners[$event])) {
            return $this->listeners[$event];
        }
        return array();
    }
    
    public function addListener($event, $listener) {
        if (!is_callable($listener))
            return $this;
        return $this->on($event, $listener);
    }
    
    public function removeListener($event, $listener) {
        if (!is_callable($listener))
            return $this;
        return $this->off($event, $listener);
    }
    
    public function removeAllListeners($event = null) {
        if ($event === null) {
            $this->listeners = array();
        } else if (($event = strtolower($event)) && !empty($this->listeners[$event])) {
            $this->listeners[$event] = array();
        }        
        return $this;
    }
    
    protected static function match($pattern, $string) {
        if (FNMATCH) {
            return fnmatch($pattern, $string);
        } else {
            return preg_match("#^" . strtr(preg_quote($pattern, '#'), array('\*' => '.*', '\?' => '.')) . "$#i", $string);
        }
    }
}
}
namespace phpex\Event{
class EventTime {
    private $times = array();
    public function setTime($eventName, $time) {
        $this->times[strtolower($eventName)] = intval($time);
    }
    public function getTimes() {
        return $this->times;
    }
}
}
namespace phpex\Foundation{
class Cookie
{
    protected $name;
    protected $value;
    protected $domain;
    protected $expire;
    protected $path;
    protected $secure;
    protected $httpOnly;
    
    public function __construct($name, $value = null, $expire = 0, $path = '/', $domain = null, $secure = false, $httpOnly = false)
    {
                if (preg_match("/[=,; \t\r\n\013\014]/", $name)) {
            throw new \InvalidArgumentException(sprintf('The cookie name "%s" contains invalid characters.', $name));
        }
        if (empty($name)) {
            throw new \InvalidArgumentException('The cookie name cannot be empty.');
        }
                if ($expire instanceof \DateTime) {
            $expire = $expire->format('U');
        } elseif (!is_numeric($expire)) {
            $expire = strtotime($expire);
            if (false === $expire || -1 === $expire) {
                throw new \InvalidArgumentException('The cookie expiration time is not valid.');
            }
        }
        $this->name = $name;
        $this->value = $value;
        $this->domain = $domain;
        $this->expire = $expire;
        $this->path = empty($path) ? '/' : $path;
        $this->secure = (bool) $secure;
        $this->httpOnly = (bool) $httpOnly;
    }
    
    public function __toString()
    {
        $str = urlencode($this->getName()).'=';
        if ('' === (string) $this->getValue()) {
            $str .= 'deleted; expires='.gmdate("D, d-M-Y H:i:s T", time() - 31536001);
        } else {
            $str .= urlencode($this->getValue());
            if ($this->getExpiresTime() !== 0) {
                $str .= '; expires='.gmdate("D, d-M-Y H:i:s T", $this->getExpiresTime());
            }
        }
        if ($this->path) {
            $str .= '; path='.$this->path;
        }
        if ($this->getDomain()) {
            $str .= '; domain='.$this->getDomain();
        }
        if (true === $this->isSecure()) {
            $str .= '; secure';
        }
        if (true === $this->isHttpOnly()) {
            $str .= '; httponly';
        }
        return $str;
    }
    
    public function getName()
    {
        return $this->name;
    }
    
    public function getValue()
    {
        return $this->value;
    }
    
    public function getDomain()
    {
        return $this->domain;
    }
    
    public function getExpiresTime()
    {
        return $this->expire;
    }
    
    public function getPath()
    {
        return $this->path;
    }
    
    public function isSecure()
    {
        return $this->secure;
    }
    
    public function isHttpOnly()
    {
        return $this->httpOnly;
    }
    
    public function isCleared()
    {
        return $this->expire < time();
    }
}
}
namespace phpex\Foundation{
class ParameterBag implements \Iterator, \ArrayAccess {
    
    protected $parameters;
    
    public function __construct(array $parameters = array()) {
        $this->parameters = $parameters;
    }
    
    public function all() {
        return $this->parameters;
    }
    
    public function keys() {
        return array_keys($this->parameters);
    }
    
    public function replace(array $parameters = array()) {
        $this->parameters = $parameters;
    }
    
    public function add(array $parameters = array()) {
        $this->parameters = array_replace($this->parameters, $parameters);
    }
    
    public function get($path, $default = null, $deep = false) {
        if (!$deep || false === $pos = strpos($path, '[')) {
            return array_key_exists($path, $this->parameters) ? $this->parameters[$path] : $default;
        }
        $root = substr($path, 0, $pos);
        if (!array_key_exists($root, $this->parameters)) {
            return $default;
        }
        $value = $this->parameters[$root];
        $currentKey = null;
        for ($i = $pos, $c = strlen($path); $i < $c; $i++) {
            $char = $path[$i];
            if ('[' === $char) {
                if (null !== $currentKey) {
                    throw new \InvalidArgumentException(sprintf('Malformed path. Unexpected "[" at position %d.', $i));
                }
                $currentKey = '';
            } elseif (']' === $char) {
                if (null === $currentKey) {
                    throw new \InvalidArgumentException(sprintf('Malformed path. Unexpected "]" at position %d.', $i));
                }
                if (!is_array($value) || !array_key_exists($currentKey, $value)) {
                    return $default;
                }
                $value = $value[$currentKey];
                $currentKey = null;
            } else {
                if (null === $currentKey) {
                    throw new \InvalidArgumentException(sprintf('Malformed path. Unexpected "%s" at position %d.', $char, $i));
                }
                $currentKey .= $char;
            }
        }
        if (null !== $currentKey) {
            throw new \InvalidArgumentException(sprintf('Malformed path. Path must end with "]".'));
        }
        return $value;
    }
    
    public function set($key, $value) {
        $this->parameters[$key] = $value;
    }
    
    public function has($key) {
        return array_key_exists($key, $this->parameters);
    }
    
    public function remove($key) {
        unset($this->parameters[$key]);
    }
    
    public function getAlpha($key, $default = '', $deep = false) {
        return preg_replace('/[^[:alpha:]]/', '', $this->get($key, $default, $deep));
    }
    
    public function getAlnum($key, $default = '', $deep = false) {
        return preg_replace('/[^[:alnum:]]/', '', $this->get($key, $default, $deep));
    }
    
    public function getDigits($key, $default = '', $deep = false) {
                return str_replace(array('-', '+'), '', $this->filter($key, $default, $deep, FILTER_SANITIZE_NUMBER_INT));
    }
    
    public function getInt($key, $default = 0, $deep = false) {
        return (int) $this->get($key, $default, $deep);
    }
    
    public function filter($key, $default = null, $deep = false, $filter = FILTER_DEFAULT, $options = array()) {
        $value = $this->get($key, $default, $deep);
                if (!is_array($options) && $options) {
            $options = array('flags' => $options);
        }
                if (is_array($value) && !isset($options['flags'])) {
            $options['flags'] = FILTER_REQUIRE_ARRAY;
        }
        return filter_var($value, $filter, $options);
    }
    
    public function getIterator() {
        return new \ArrayIterator($this->parameters);
    }
    
    public function count() {
        return count($this->parameters);
    }
    public function current() {
        return current($this->parameters);
    }
    public function key() {
        return key($this->parameters);
    }
    public function next() {
        next($this->parameters);
    }
    public function rewind() {
        reset($this->parameters);
    }
    public function valid() {
        return key_exists($this->key(), $this->parameters);
    }
    public function offsetExists($offset) {
        return key_exists($offset, $this->parameters);
    }
    public function offsetGet($offset) {
        return key_exists($offset, $this->parameters) ? $this->parameters[$offset] : null;
    }
    public function offsetSet($offset, $value) {
        if (is_null($offset)) {
            $this->parameters[] = $value;
        } else {
            $this->parameters[$offset] = $value;
        }
    }
    public function offsetUnset($offset) {
        unset($this->parameters[$offset]);
    }
}
}
namespace phpex\Foundation{
use phpex\Foundation\File\UploadedFile;
class FileBag extends ParameterBag
{
    private static $fileKeys = array('error', 'name', 'size', 'tmp_name', 'type');
    
    public function __construct(array $parameters = array())
    {
        $this->replace($parameters);
    }
    
    public function replace(array $files = array())
    {
        $this->parameters = array();
        $this->add($files);
    }
    
    public function set($key, $value)
    {
        if (!is_array($value) && !$value instanceof UploadedFile) {
            throw new \InvalidArgumentException('An uploaded file must be an array or an instance of UploadedFile.');
        }
        parent::set($key, $this->convertFileInformation($value));
    }
    
    public function add(array $files = array())
    {
        foreach ($files as $key => $file) {
            $this->set($key, $file);
        }
    }
    
    protected function convertFileInformation($file)
    {
        if ($file instanceof UploadedFile) {
            return $file;
        }
        $file = $this->fixPhpFilesArray($file);
        if (is_array($file)) {
            $keys = array_keys($file);
            sort($keys);
            if ($keys == self::$fileKeys) {
                if (UPLOAD_ERR_NO_FILE == $file['error']) {
                    $file = null;
                } else {
                    $file = new UploadedFile($file['tmp_name'], $file['name'], $file['type'], $file['size'], $file['error']);
                }
            } else {
                $file = array_map(array($this, 'convertFileInformation'), $file);
            }
        }
        return $file;
    }
    
    protected function fixPhpFilesArray($data)
    {
        if (!is_array($data)) {
            return $data;
        }
        $keys = array_keys($data);
        sort($keys);
        if (self::$fileKeys != $keys || !isset($data['name']) || !is_array($data['name'])) {
            return $data;
        }
        $files = $data;
        foreach (self::$fileKeys as $k) {
            unset($files[$k]);
        }
        foreach (array_keys($data['name']) as $key) {
            $files[$key] = $this->fixPhpFilesArray(array(
                'error'    => $data['error'][$key],
                'name'     => $data['name'][$key],
                'type'     => $data['type'][$key],
                'tmp_name' => $data['tmp_name'][$key],
                'size'     => $data['size'][$key]
            ));
        }
        return $files;
    }
}
}
namespace phpex\Foundation{
class HeaderBag
{
    protected $headers = array();
    protected $cacheControl = array();
    
    public function __construct(array $headers = array())
    {
        foreach ($headers as $key => $values) {
            $this->set($key, $values);
        }
    }
    
    public function __toString()
    {
        if (!$this->headers) {
            return '';
        }
        $max = max(array_map('strlen', array_keys($this->headers))) + 1;
        $content = '';
        ksort($this->headers);
        foreach ($this->headers as $name => $values) {
            $name = implode('-', array_map('ucfirst', explode('-', $name)));
            foreach ($values as $value) {
                $content .= sprintf("%-{$max}s %s\r\n", $name.':', $value);
            }
        }
        return $content;
    }
    
    public function all()
    {
        return $this->headers;
    }
    
    public function keys()
    {
        return array_keys($this->headers);
    }
    
    public function replace(array $headers = array())
    {
        $this->headers = array();
        $this->add($headers);
    }
    
    public function add(array $headers)
    {
        foreach ($headers as $key => $values) {
            $this->set($key, $values);
        }
    }
    
    public function get($key, $default = null, $first = true)
    {
        $key = strtr(strtolower($key), '_', '-');
        if (!array_key_exists($key, $this->headers)) {
            if (null === $default) {
                return $first ? null : array();
            }
            return $first ? $default : array($default);
        }
        if ($first) {
            return count($this->headers[$key]) ? $this->headers[$key][0] : $default;
        }
        return $this->headers[$key];
    }
    
    public function set($key, $values, $replace = true)
    {
        $key = strtr(strtolower($key), '_', '-');
        $values = array_values((array) $values);
        if (true === $replace || !isset($this->headers[$key])) {
            $this->headers[$key] = $values;
        } else {
            $this->headers[$key] = array_merge($this->headers[$key], $values);
        }
        if ('cache-control' === $key) {
            $this->cacheControl = $this->parseCacheControl($values[0]);
        }
    }
    
    public function has($key)
    {
        return array_key_exists(strtr(strtolower($key), '_', '-'), $this->headers);
    }
    
    public function contains($key, $value)
    {
        return in_array($value, $this->get($key, null, false));
    }
    
    public function remove($key)
    {
        $key = strtr(strtolower($key), '_', '-');
        unset($this->headers[$key]);
        if ('cache-control' === $key) {
            $this->cacheControl = array();
        }
    }
    
    public function getDate($key, \DateTime $default = null)
    {
        if (null === $value = $this->get($key)) {
            return $default;
        }
        if (false === $date = \DateTime::createFromFormat(DATE_RFC2822, $value)) {
            throw new \RuntimeException(sprintf('The %s HTTP header is not parseable (%s).', $key, $value));
        }
        return $date;
    }
    public function addCacheControlDirective($key, $value = true)
    {
        $this->cacheControl[$key] = $value;
        $this->set('Cache-Control', $this->getCacheControlHeader());
    }
    public function hasCacheControlDirective($key)
    {
        return array_key_exists($key, $this->cacheControl);
    }
    public function getCacheControlDirective($key)
    {
        return array_key_exists($key, $this->cacheControl) ? $this->cacheControl[$key] : null;
    }
    public function removeCacheControlDirective($key)
    {
        unset($this->cacheControl[$key]);
        $this->set('Cache-Control', $this->getCacheControlHeader());
    }
    
    public function getIterator()
    {
        return new \ArrayIterator($this->headers);
    }
    
    public function count()
    {
        return count($this->headers);
    }
    protected function getCacheControlHeader()
    {
        $parts = array();
        ksort($this->cacheControl);
        foreach ($this->cacheControl as $key => $value) {
            if (true === $value) {
                $parts[] = $key;
            } else {
                if (preg_match('#[^a-zA-Z0-9._-]#', $value)) {
                    $value = '"'.$value.'"';
                }
                $parts[] = "$key=$value";
            }
        }
        return implode(', ', $parts);
    }
    
    protected function parseCacheControl($header)
    {
        $cacheControl = array();
        preg_match_all('#([a-zA-Z][a-zA-Z_-]*)\s*(?:=(?:"([^"]*)"|([^ \t",;]*)))?#', $header, $matches, PREG_SET_ORDER);
        foreach ($matches as $match) {
            $cacheControl[strtolower($match[1])] = isset($match[3]) ? $match[3] : (isset($match[2]) ? $match[2] : true);
        }
        return $cacheControl;
    }
}
}
namespace phpex\Foundation{
use phpex\Foundation\Session\SessionInterface;
class Request {
    const HEADER_CLIENT_IP = 'client_ip';
    const HEADER_CLIENT_HOST = 'client_host';
    const HEADER_CLIENT_PROTO = 'client_proto';
    const HEADER_CLIENT_PORT = 'client_port';
    protected static $trustedProxies = array();
    
    protected static $trustedHostPatterns = array();
    
    protected static $trustedHosts = array();
    
    protected static $trustedHeaders = array(
        self::HEADER_CLIENT_IP => 'X_FORWARDED_FOR',
        self::HEADER_CLIENT_HOST => 'X_FORWARDED_HOST',
        self::HEADER_CLIENT_PROTO => 'X_FORWARDED_PROTO',
        self::HEADER_CLIENT_PORT => 'X_FORWARDED_PORT',
    );
    protected static $httpMethodParameterOverride = false;
    
    public $attr;
    
    public $post;
    
    public $get;
    
    public $server;
    
    public $files;
    
    public $cookies;
    
    public $headers;
    
    protected $content;
    
    protected $languages;
    
    protected $charsets;
    
    protected $encodings;
    
    protected $acceptableContentTypes;
    
    protected $pathInfo;
    
    protected $requestUri;
    
    protected $baseUrl;
    
    protected $basePath;
    
    protected $method;
    
    protected $format;
    
    protected $session;
    
    protected $locale;
    
    protected $defaultLocale = 'zh';
    
    protected static $formats;
    protected static $requestFactory;
    
    public function __construct(array $query = array(), array $request = array(), array $attributes = array(), array $cookies = array(), array $files = array(), array $server = array(), $content = null) {
        $this->initialize($query, $request, $attributes, $cookies, $files, $server, $content);
    }
    
    public function initialize(array $query = array(), array $request = array(), array $attributes = array(), array $cookies = array(), array $files = array(), array $server = array(), $content = null) {
        $this->post = new ParameterBag($request);
        $this->get = new ParameterBag($query);
        $this->attr = new ParameterBag($attributes);
        $this->cookies = new ParameterBag($cookies);
        $this->files = new FileBag($files);
        $this->server = new ServerBag($server);
        $this->headers = new HeaderBag($this->server->getHeaders());
        $this->content = $content;
        $this->languages = null;
        $this->charsets = null;
        $this->encodings = null;
        $this->acceptableContentTypes = null;
        $this->pathInfo = null;
        $this->postUri = null;
        $this->baseUrl = null;
        $this->basePath = null;
        $this->method = null;
        $this->format = null;
    }
    
    public static function createFromGlobals() {
        $request = self::createRequestFromFactory($_GET, $_POST, array(), $_COOKIE, $_FILES, $_SERVER);
        if (0 === strpos($request->headers->get('CONTENT_TYPE'), 'application/x-www-form-urlencoded') && in_array(strtoupper($request->server->get('REQUEST_METHOD', 'GET')), array('PUT', 'DELETE', 'PATCH'))
        ) {
            parse_str($request->getContent(), $data);
            $request->request = new ParameterBag($data);
        }
        return $request;
    }
    
    public static function create($uri, $method = 'GET', $parameters = array(), $cookies = array(), $files = array(), $server = array(), $content = null) {
        $server = array_replace(array(
            'SERVER_NAME' => 'localhost',
            'SERVER_PORT' => 80,
            'HTTP_HOST' => 'localhost',
            'HTTP_USER_AGENT' => 'Symfony/2.X',
            'HTTP_ACCEPT' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'HTTP_ACCEPT_LANGUAGE' => 'en-us,en;q=0.5',
            'HTTP_ACCEPT_CHARSET' => 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',
            'REMOTE_ADDR' => '127.0.0.1',
            'SCRIPT_NAME' => '',
            'SCRIPT_FILENAME' => '',
            'SERVER_PROTOCOL' => 'HTTP/1.1',
            'REQUEST_TIME' => time(),
                ), $server);
        $server['PATH_INFO'] = '';
        $server['REQUEST_METHOD'] = strtoupper($method);
        $components = parse_url($uri);
        if (isset($components['host'])) {
            $server['SERVER_NAME'] = $components['host'];
            $server['HTTP_HOST'] = $components['host'];
        }
        if (isset($components['scheme'])) {
            if ('https' === $components['scheme']) {
                $server['HTTPS'] = 'on';
                $server['SERVER_PORT'] = 443;
            } else {
                unset($server['HTTPS']);
                $server['SERVER_PORT'] = 80;
            }
        }
        if (isset($components['port'])) {
            $server['SERVER_PORT'] = $components['port'];
            $server['HTTP_HOST'] = $server['HTTP_HOST'] . ':' . $components['port'];
        }
        if (isset($components['user'])) {
            $server['PHP_AUTH_USER'] = $components['user'];
        }
        if (isset($components['pass'])) {
            $server['PHP_AUTH_PW'] = $components['pass'];
        }
        if (!isset($components['path'])) {
            $components['path'] = '/';
        }
        switch (strtoupper($method)) {
            case 'POST':
            case 'PUT':
            case 'DELETE':
                if (!isset($server['CONTENT_TYPE'])) {
                    $server['CONTENT_TYPE'] = 'application/x-www-form-urlencoded';
                }
            case 'PATCH':
                $request = $parameters;
                $query = array();
                break;
            default:
                $request = array();
                $query = $parameters;
                break;
        }
        $queryString = '';
        if (isset($components['query'])) {
            parse_str(html_entity_decode($components['query']), $qs);
            if ($query) {
                $query = array_replace($qs, $query);
                $queryString = http_build_query($query, '', '&');
            } else {
                $query = $qs;
                $queryString = $components['query'];
            }
        } elseif ($query) {
            $queryString = http_build_query($query, '', '&');
        }
        $server['REQUEST_URI'] = $components['path'] . ('' !== $queryString ? '?' . $queryString : '');
        $server['QUERY_STRING'] = $queryString;
        return self::createRequestFromFactory($query, $request, array(), $cookies, $files, $server, $content);
    }
    
    public static function setFactory($callable) {
        self::$requestFactory = $callable;
    }
    
    public function duplicate(array $query = null, array $request = null, array $attributes = null, array $cookies = null, array $files = null, array $server = null) {
        $dup = clone $this;
        if ($query !== null) {
            $dup->query = new ParameterBag($query);
        }
        if ($request !== null) {
            $dup->request = new ParameterBag($request);
        }
        if ($attributes !== null) {
            $dup->attributes = new ParameterBag($attributes);
        }
        if ($cookies !== null) {
            $dup->cookies = new ParameterBag($cookies);
        }
        if ($files !== null) {
            $dup->files = new FileBag($files);
        }
        if ($server !== null) {
            $dup->server = new ServerBag($server);
            $dup->headers = new HeaderBag($dup->server->getHeaders());
        }
        $dup->languages = null;
        $dup->charsets = null;
        $dup->encodings = null;
        $dup->acceptableContentTypes = null;
        $dup->pathInfo = null;
        $dup->requestUri = null;
        $dup->baseUrl = null;
        $dup->basePath = null;
        $dup->method = null;
        $dup->format = null;
        if (!$dup->get('_format') && $this->get('_format')) {
            $dup->attributes->set('_format', $this->get('_format'));
        }
        if (!$dup->getRequestFormat(null)) {
            $dup->setRequestFormat($format = $this->getRequestFormat(null));
        }
        return $dup;
    }
    
    public function __clone() {
        $this->get = clone $this->get;
        $this->post = clone $this->post;
        $this->attr = clone $this->attr;
        $this->cookies = clone $this->cookies;
        $this->files = clone $this->files;
        $this->server = clone $this->server;
        $this->headers = clone $this->headers;
    }
    
    public function __toString() {
        return
                sprintf('%s %s %s', $this->getMethod(), $this->getRequestUri(), $this->server->get('SERVER_PROTOCOL')) . "\r\n" .
                $this->headers . "\r\n" .
                $this->getContent();
    }
    
    public function overrideGlobals() {
        $_GET = $this->get->all();
        $_POST = $this->post->all();
        $_SERVER = $this->server->all();
        $_COOKIE = $this->cookies->all();
        foreach ($this->headers->all() as $key => $value) {
            $key = strtoupper(str_replace('-', '_', $key));
            if (in_array($key, array('CONTENT_TYPE', 'CONTENT_LENGTH'))) {
                $_SERVER[$key] = implode(', ', $value);
            } else {
                $_SERVER['HTTP_' . $key] = implode(', ', $value);
            }
        }
        $request = array('g' => $_GET, 'p' => $_POST, 'c' => $_COOKIE);
        $requestOrder = ini_get('request_order') ? : ini_get('variables_order');
        $requestOrder = preg_replace('#[^cgp]#', '', strtolower($requestOrder)) ? : 'gp';
        $_REQUEST = array();
        foreach (str_split($requestOrder) as $order) {
            $_REQUEST = array_merge($_REQUEST, $request[$order]);
        }
    }
    
    public static function setTrustedProxies(array $proxies) {
        self::$trustedProxies = $proxies;
    }
    
    public static function getTrustedProxies() {
        return self::$trustedProxies;
    }
    
    public static function setTrustedHosts(array $hostPatterns) {
        self::$trustedHostPatterns = array_map(function ($hostPattern) {
            return sprintf('{%s}i', str_replace('}', '\\}', $hostPattern));
        }, $hostPatterns);
                self::$trustedHosts = array();
    }
    
    public static function getTrustedHosts() {
        return self::$trustedHostPatterns;
    }
    
    public static function setTrustedHeaderName($key, $value) {
        if (!array_key_exists($key, self::$trustedHeaders)) {
            throw new \InvalidArgumentException(sprintf('Unable to set the trusted header name for key "%s".', $key));
        }
        self::$trustedHeaders[$key] = $value;
    }
    
    public static function getTrustedHeaderName($key) {
        if (!array_key_exists($key, self::$trustedHeaders)) {
            throw new \InvalidArgumentException(sprintf('Unable to get the trusted header name for key "%s".', $key));
        }
        return self::$trustedHeaders[$key];
    }
    
    public static function normalizeQueryString($qs) {
        if ('' == $qs) {
            return '';
        }
        $parts = array();
        $order = array();
        foreach (explode('&', $qs) as $param) {
            if ('' === $param || '=' === $param[0]) {
                                                                continue;
            }
            $keyValuePair = explode('=', $param, 2);
                                                $parts[] = isset($keyValuePair[1]) ?
                    rawurlencode(urldecode($keyValuePair[0])) . '=' . rawurlencode(urldecode($keyValuePair[1])) :
                    rawurlencode(urldecode($keyValuePair[0]));
            $order[] = urldecode($keyValuePair[0]);
        }
        array_multisort($order, SORT_ASC, $parts);
        return implode('&', $parts);
    }
    
    public static function enableHttpMethodParameterOverride() {
        self::$httpMethodParameterOverride = true;
    }
    
    public static function getHttpMethodParameterOverride() {
        return self::$httpMethodParameterOverride;
    }
    
    public function get($key, $default = null, $deep = false) {
        return $this->get->get($key, $this->attr->get($key, $this->post->get($key, $default, $deep), $deep), $deep);
    }
    
    public function getSession() {
        return $this->session;
    }
    
    public function hasPreviousSession() {
                return $this->hasSession() && $this->cookies->has($this->session->getName());
    }
    
    public function hasSession() {
        return null !== $this->session;
    }
    
    public function setSession(Session $session) {
        $this->session = $session;
    }
    
    public function getClientIps() {
        $ip = $this->server->get('REMOTE_ADDR');
        if (!self::$trustedProxies) {
            return array($ip);
        }
        if (!self::$trustedHeaders[self::HEADER_CLIENT_IP] || !$this->headers->has(self::$trustedHeaders[self::HEADER_CLIENT_IP])) {
            return array($ip);
        }
        $clientIps = array_map('trim', explode(',', $this->headers->get(self::$trustedHeaders[self::HEADER_CLIENT_IP])));
        $clientIps[] = $ip; 
        $ip = $clientIps[0];                 foreach ($clientIps as $key => $clientIp) {
            if (IpUtils::checkIp($clientIp, self::$trustedProxies)) {
                unset($clientIps[$key]);
            }
        }
                return $clientIps ? array_reverse($clientIps) : array($ip);
    }
    
    public function getClientIp() {
        $ipAddresses = $this->getClientIps();
        return $ipAddresses[0];
    }
    
    public function getScriptName() {
        return $this->server->get('SCRIPT_NAME', $this->server->get('ORIG_SCRIPT_NAME', ''));
    }
    
    public function getPathInfo() {
        if (null === $this->pathInfo) {
            $this->pathInfo = $this->preparePathInfo();
        }
        return $this->pathInfo;
    }
    
    public function getBasePath() {
        if (null === $this->basePath) {
            $this->basePath = $this->prepareBasePath();
        }
        return $this->basePath;
    }
    
    public function getBaseUrl() {
        if (null === $this->baseUrl) {
            $this->baseUrl = $this->prepareBaseUrl();
        }
        return $this->baseUrl;
    }
    
    public function getScheme() {
        return $this->isSecure() ? 'https' : 'http';
    }
    
    public function getPort() {
        if (self::$trustedProxies) {
            if (self::$trustedHeaders[self::HEADER_CLIENT_PORT] && $port = $this->headers->get(self::$trustedHeaders[self::HEADER_CLIENT_PORT])) {
                return $port;
            }
            if (self::$trustedHeaders[self::HEADER_CLIENT_PROTO] && 'https' === $this->headers->get(self::$trustedHeaders[self::HEADER_CLIENT_PROTO], 'http')) {
                return 443;
            }
        }
        if ($host = $this->headers->get('HOST')) {
            if (false !== $pos = strrpos($host, ':')) {
                return intval(substr($host, $pos + 1));
            }
            return 'https' === $this->getScheme() ? 443 : 80;
        }
        return $this->server->get('SERVER_PORT');
    }
    
    public function getUser() {
        return $this->server->get('PHP_AUTH_USER');
    }
    
    public function getPassword() {
        return $this->server->get('PHP_AUTH_PW');
    }
    
    public function getUserInfo() {
        $userinfo = $this->getUser();
        $pass = $this->getPassword();
        if ('' != $pass) {
            $userinfo .= ":$pass";
        }
        return $userinfo;
    }
    
    public function getHttpHost() {
        $scheme = $this->getScheme();
        $port = $this->getPort();
        if (('http' == $scheme && $port == 80) || ('https' == $scheme && $port == 443)) {
            return $this->getHost();
        }
        return $this->getHost() . ':' . $port;
    }
    
    public function getRequestUri() {
        if (null === $this->postUri) {
            $this->postUri = $this->prepareRequestUri();
        }
        return $this->postUri;
    }
    
    public function getSchemeAndHttpHost() {
        return $this->getScheme() . '://' . $this->getHttpHost();
    }
    
    public function getUri() {
        return $this->getSchemeAndHttpHost() . $this->server->get("REQUEST_URI");
    }
    
    public function getUriForPath($path) {
        return $this->getSchemeAndHttpHost() . $this->getBaseUrl() . $path;
    }
    
    public function getQueryString() {
        $qs = static::normalizeQueryString($this->server->get('QUERY_STRING'));
        return '' === $qs ? null : $qs;
    }
    
    public function isSecure() {
        if (self::$trustedProxies && self::$trustedHeaders[self::HEADER_CLIENT_PROTO] && $proto = $this->headers->get(self::$trustedHeaders[self::HEADER_CLIENT_PROTO])) {
            return in_array(strtolower(current(explode(',', $proto))), array('https', 'on', 'ssl', '1'));
        }
        return 'on' == strtolower($this->server->get('HTTPS')) || 1 == $this->server->get('HTTPS') || $this->server->get('SERVER_PORT') == 443;
    }
    
    public function getHost() {
        if (self::$trustedProxies && self::$trustedHeaders[self::HEADER_CLIENT_HOST] && $host = $this->headers->get(self::$trustedHeaders[self::HEADER_CLIENT_HOST])) {
            $elements = explode(',', $host);
            $host = $elements[count($elements) - 1];
        } elseif (!$host = $this->headers->get('HOST')) {
            if (!$host = $this->server->get('SERVER_NAME')) {
                $host = $this->server->get('SERVER_ADDR', '');
            }
        }
                        $host = strtolower(preg_replace('/:\d+$/', '', trim($host)));
                        if ($host && !preg_match('/^\[?(?:[a-zA-Z0-9-:\]_]+\.?)+$/', $host)) {
            throw new \UnexpectedValueException(sprintf('Invalid Host "%s"', $host));
        }
        if (count(self::$trustedHostPatterns) > 0) {
            
            if (in_array($host, self::$trustedHosts)) {
                return $host;
            }
            foreach (self::$trustedHostPatterns as $pattern) {
                if (preg_match($pattern, $host)) {
                    self::$trustedHosts[] = $host;
                    return $host;
                }
            }
            throw new \UnexpectedValueException(sprintf('Untrusted Host "%s"', $host));
        }
        return $host;
    }
    
    public function setMethod($method) {
        $this->method = null;
        $this->server->set('REQUEST_METHOD', $method);
    }
    
    public function getMethod() {
        if (null === $this->method) {
            $this->method = strtoupper($this->server->get('REQUEST_METHOD', 'GET'));
            if ('POST' === $this->method) {
                if ($method = $this->headers->get('X-HTTP-METHOD-OVERRIDE')) {
                    $this->method = strtoupper($method);
                } elseif (self::$httpMethodParameterOverride) {
                    $this->method = strtoupper($this->post->get('_method', $this->get->get('_method', 'POST')));
                }
            }
        }
        return $this->method;
    }
    
    public function getRealMethod() {
        return strtoupper($this->server->get('REQUEST_METHOD', 'GET'));
    }
    
    public function getMimeType($format) {
        if (null === static::$formats) {
            static::initializeFormats();
        }
        return isset(static::$formats[$format]) ? static::$formats[$format][0] : null;
    }
    
    public function getFormat($mimeType) {
        if (false !== $pos = strpos($mimeType, ';')) {
            $mimeType = substr($mimeType, 0, $pos);
        }
        if (null === static::$formats) {
            static::initializeFormats();
        }
        foreach (static::$formats as $format => $mimeTypes) {
            if (in_array($mimeType, (array) $mimeTypes)) {
                return $format;
            }
        }
        return null;
    }
    
    public function setFormat($format, $mimeTypes) {
        if (null === static::$formats) {
            static::initializeFormats();
        }
        static::$formats[$format] = is_array($mimeTypes) ? $mimeTypes : array($mimeTypes);
    }
    
    public function getRequestFormat($default = 'html') {
        if (null === $this->format) {
            $this->format = $this->get('_format', $default);
        }
        return $this->format;
    }
    
    public function setRequestFormat($format) {
        $this->format = $format;
    }
    
    public function getContentType() {
        return $this->getFormat($this->headers->get('CONTENT_TYPE'));
    }
    
    public function setDefaultLocale($locale) {
        $this->defaultLocale = $locale;
        if (null === $this->locale) {
            $this->setPhpDefaultLocale($locale);
        }
    }
    
    public function setLocale($locale) {
        $this->setPhpDefaultLocale($this->locale = $locale);
    }
    
    public function getLocale() {
        return null === $this->locale ? $this->defaultLocale : $this->locale;
    }
    
    public function isMethod($method) {
        return $this->getMethod() === strtoupper($method);
    }
    
    public function isPost() {
        return "POST" === $this->getRealMethod();
    }
    
    public function isGet() {
        return "GET" === $this->getRealMethod();
    }
    public function isAjax() {
        return $this->server->has("HTTP_X_REQUESTED_WITH") && strtolower($this->server->get("HTTP_X_REQUESTED_WITH")) == "xmlhttprequest";
    }
    
    public function isMethodSafe() {
        return in_array($this->getMethod(), array('GET', 'HEAD'));
    }
    
    public function getContent($asResource = false) {
        if (false === $this->content || (true === $asResource && null !== $this->content)) {
            throw new \LogicException('getContent() can only be called once when using the resource return type.');
        }
        if (true === $asResource) {
            $this->content = false;
            return fopen('php://input', 'rb');
        }
        if (null === $this->content) {
            $this->content = file_get_contents('php://input');
        }
        return $this->content;
    }
    
    public function getETags() {
        return preg_split('/\s*,\s*/', $this->headers->get('if_none_match'), null, PREG_SPLIT_NO_EMPTY);
    }
    
    public function isNoCache() {
        return $this->headers->hasCacheControlDirective('no-cache') || 'no-cache' == $this->headers->get('Pragma');
    }
    
    public function getPreferredLanguage(array $locales = null) {
        $preferredLanguages = $this->getLanguages();
        if (empty($locales)) {
            return isset($preferredLanguages[0]) ? $preferredLanguages[0] : null;
        }
        if (!$preferredLanguages) {
            return $locales[0];
        }
        $extendedPreferredLanguages = array();
        foreach ($preferredLanguages as $language) {
            $extendedPreferredLanguages[] = $language;
            if (false !== $position = strpos($language, '_')) {
                $superLanguage = substr($language, 0, $position);
                if (!in_array($superLanguage, $preferredLanguages)) {
                    $extendedPreferredLanguages[] = $superLanguage;
                }
            }
        }
        $preferredLanguages = array_values(array_intersect($extendedPreferredLanguages, $locales));
        return isset($preferredLanguages[0]) ? $preferredLanguages[0] : $locales[0];
    }
    
    public function getLanguages() {
        if (null !== $this->languages) {
            return $this->languages;
        }
        $languages = AcceptHeader::fromString($this->headers->get('Accept-Language'))->all();
        $this->languages = array();
        foreach (array_keys($languages) as $lang) {
            if (strstr($lang, '-')) {
                $codes = explode('-', $lang);
                if ($codes[0] == 'i') {
                                                                                if (count($codes) > 1) {
                        $lang = $codes[1];
                    }
                } else {
                    for ($i = 0, $max = count($codes); $i < $max; $i++) {
                        if ($i == 0) {
                            $lang = strtolower($codes[0]);
                        } else {
                            $lang .= '_' . strtoupper($codes[$i]);
                        }
                    }
                }
            }
            $this->languages[] = $lang;
        }
        return $this->languages;
    }
    
    public function getCharsets() {
        if (null !== $this->charsets) {
            return $this->charsets;
        }
        return $this->charsets = array_keys(AcceptHeader::fromString($this->headers->get('Accept-Charset'))->all());
    }
    
    public function getEncodings() {
        if (null !== $this->encodings) {
            return $this->encodings;
        }
        return $this->encodings = array_keys(AcceptHeader::fromString($this->headers->get('Accept-Encoding'))->all());
    }
    
    public function getAcceptableContentTypes() {
        if (null !== $this->acceptableContentTypes) {
            return $this->acceptableContentTypes;
        }
        return $this->acceptableContentTypes = array_keys(AcceptHeader::fromString($this->headers->get('Accept'))->all());
    }
    
    public function isXmlHttpRequest() {
        return 'XMLHttpRequest' == $this->headers->get('X-Requested-With');
    }
    
    protected function prepareRequestUri() {
        $requestUri = '';
        if ($this->headers->has('X_ORIGINAL_URL')) {
                        $requestUri = $this->headers->get('X_ORIGINAL_URL');
            $this->headers->remove('X_ORIGINAL_URL');
            $this->server->remove('HTTP_X_ORIGINAL_URL');
            $this->server->remove('UNENCODED_URL');
            $this->server->remove('IIS_WasUrlRewritten');
        } elseif ($this->headers->has('X_REWRITE_URL')) {
                        $requestUri = $this->headers->get('X_REWRITE_URL');
            $this->headers->remove('X_REWRITE_URL');
        } elseif ($this->server->get('IIS_WasUrlRewritten') == '1' && $this->server->get('UNENCODED_URL') != '') {
                        $requestUri = $this->server->get('UNENCODED_URL');
            $this->server->remove('UNENCODED_URL');
            $this->server->remove('IIS_WasUrlRewritten');
        } elseif ($this->server->has('REQUEST_URI')) {
            $requestUri = $this->server->get('REQUEST_URI');
                        $schemeAndHttpHost = $this->getSchemeAndHttpHost();
            if (strpos($requestUri, $schemeAndHttpHost) === 0) {
                $requestUri = substr($requestUri, strlen($schemeAndHttpHost));
            }
        } elseif ($this->server->has('ORIG_PATH_INFO')) {
                        $requestUri = $this->server->get('ORIG_PATH_INFO');
            if ('' != $this->server->get('QUERY_STRING')) {
                $requestUri .= '?' . $this->server->get('QUERY_STRING');
            }
            $this->server->remove('ORIG_PATH_INFO');
        }
                $this->server->set('REQUEST_URI', $requestUri);
        return $requestUri;
    }
    
    protected function prepareBaseUrl() {
        $filename = basename($this->server->get('SCRIPT_FILENAME'));
        if (basename($this->server->get('SCRIPT_NAME')) === $filename) {
            $baseUrl = $this->server->get('SCRIPT_NAME');
        } elseif (basename($this->server->get('PHP_SELF')) === $filename) {
            $baseUrl = $this->server->get('PHP_SELF');
        } elseif (basename($this->server->get('ORIG_SCRIPT_NAME')) === $filename) {
            $baseUrl = $this->server->get('ORIG_SCRIPT_NAME');         } else {
                                    $path = $this->server->get('PHP_SELF', '');
            $file = $this->server->get('SCRIPT_FILENAME', '');
            $segs = explode('/', trim($file, '/'));
            $segs = array_reverse($segs);
            $index = 0;
            $last = count($segs);
            $baseUrl = '';
            do {
                $seg = $segs[$index];
                $baseUrl = '/' . $seg . $baseUrl;
                ++$index;
            } while ($last > $index && (false !== $pos = strpos($path, $baseUrl)) && 0 != $pos);
        }
                $requestUri = $this->getRequestUri();
        if ($baseUrl && false !== $prefix = $this->getUrlencodedPrefix($requestUri, $baseUrl)) {
                        return $prefix;
        }
        if ($baseUrl && false !== $prefix = $this->getUrlencodedPrefix($requestUri, dirname($baseUrl))) {
                        return rtrim($prefix, '/');
        }
        $truncatedRequestUri = $requestUri;
        if (false !== $pos = strpos($requestUri, '?')) {
            $truncatedRequestUri = substr($requestUri, 0, $pos);
        }
        $basename = basename($baseUrl);
        if (empty($basename) || !strpos(rawurldecode($truncatedRequestUri), $basename)) {
                        return '';
        }
                                if (strlen($requestUri) >= strlen($baseUrl) && (false !== $pos = strpos($requestUri, $baseUrl)) && $pos !== 0) {
            $baseUrl = substr($requestUri, 0, $pos + strlen($baseUrl));
        }
        return rtrim($baseUrl, '/');
    }
    
    protected function prepareBasePath() {
        $filename = basename($this->server->get('SCRIPT_FILENAME'));
        $baseUrl = $this->getBaseUrl();
        if (empty($baseUrl)) {
            return '';
        }
        if (basename($baseUrl) === $filename) {
            $basePath = dirname($baseUrl);
        } else {
            $basePath = $baseUrl;
        }
        if ('\\' === DIRECTORY_SEPARATOR) {
            $basePath = str_replace('\\', '/', $basePath);
        }
        return rtrim($basePath, '/');
    }
    
    protected function preparePathInfo() {
        $baseUrl = $this->getBaseUrl();
        if (null === ($requestUri = $this->getRequestUri())) {
            return '/';
        }
        $pathInfo = '/';
                if ($pos = strpos($requestUri, '?')) {
            $requestUri = substr($requestUri, 0, $pos);
        }
        if (null !== $baseUrl && false === $pathInfo = substr($requestUri, strlen($baseUrl))) {
                        return '/';
        } elseif (null === $baseUrl) {
            return $requestUri;
        }
        return (string) $pathInfo;
    }
    
    protected static function initializeFormats() {
        static::$formats = array(
            'html' => array('text/html', 'application/xhtml+xml'),
            'txt' => array('text/plain'),
            'js' => array('application/javascript', 'application/x-javascript', 'text/javascript'),
            'css' => array('text/css'),
            'json' => array('application/json', 'application/x-json'),
            'xml' => array('text/xml', 'application/xml', 'application/x-xml'),
            'rdf' => array('application/rdf+xml'),
            'atom' => array('application/atom+xml'),
            'rss' => array('application/rss+xml'),
        );
    }
    
    private function setPhpDefaultLocale($locale) {
                                try {
            if (class_exists('Locale', false)) {
                \Locale::setDefault($locale);
            }
        } catch (\Exception $e) {
            
        }
    }
    
    private function getUrlencodedPrefix($string, $prefix) {
        if (0 !== strpos(rawurldecode($string), $prefix)) {
            return false;
        }
        $len = strlen($prefix);
        if (preg_match("#^(%[[:xdigit:]]{2}|.){{$len}}#", $string, $match)) {
            return $match[0];
        }
        return false;
    }
    private static function createRequestFromFactory(array $query = array(), array $request = array(), array $attributes = array(), array $cookies = array(), array $files = array(), array $server = array(), $content = null) {
        if (self::$requestFactory) {
            $request = call_user_func(self::$requestFactory, $query, $request, $attributes, $cookies, $files, $server, $content);
            if (!$request instanceof Request) {
                throw new \LogicException('The Request factory must return an instance of Symfony\Component\Foundation\Request.');
            }
            return $request;
        }
        return new static($query, $request, $attributes, $cookies, $files, $server, $content);
    }
}
}
namespace phpex\Foundation{
class Response
{
    const HTTP_CONTINUE = 100;
    const HTTP_SWITCHING_PROTOCOLS = 101;
    const HTTP_PROCESSING = 102;                const HTTP_OK = 200;
    const HTTP_CREATED = 201;
    const HTTP_ACCEPTED = 202;
    const HTTP_NON_AUTHORITATIVE_INFORMATION = 203;
    const HTTP_NO_CONTENT = 204;
    const HTTP_RESET_CONTENT = 205;
    const HTTP_PARTIAL_CONTENT = 206;
    const HTTP_MULTI_STATUS = 207;              const HTTP_ALREADY_REPORTED = 208;          const HTTP_IM_USED = 226;                   const HTTP_MULTIPLE_CHOICES = 300;
    const HTTP_MOVED_PERMANENTLY = 301;
    const HTTP_FOUND = 302;
    const HTTP_SEE_OTHER = 303;
    const HTTP_NOT_MODIFIED = 304;
    const HTTP_USE_PROXY = 305;
    const HTTP_RESERVED = 306;
    const HTTP_TEMPORARY_REDIRECT = 307;
    const HTTP_PERMANENTLY_REDIRECT = 308;      const HTTP_BAD_REQUEST = 400;
    const HTTP_UNAUTHORIZED = 401;
    const HTTP_PAYMENT_REQUIRED = 402;
    const HTTP_FORBIDDEN = 403;
    const HTTP_NOT_FOUND = 404;
    const HTTP_METHOD_NOT_ALLOWED = 405;
    const HTTP_NOT_ACCEPTABLE = 406;
    const HTTP_PROXY_AUTHENTICATION_REQUIRED = 407;
    const HTTP_REQUEST_TIMEOUT = 408;
    const HTTP_CONFLICT = 409;
    const HTTP_GONE = 410;
    const HTTP_LENGTH_REQUIRED = 411;
    const HTTP_PRECONDITION_FAILED = 412;
    const HTTP_REQUEST_ENTITY_TOO_LARGE = 413;
    const HTTP_REQUEST_URI_TOO_LONG = 414;
    const HTTP_UNSUPPORTED_MEDIA_TYPE = 415;
    const HTTP_REQUESTED_RANGE_NOT_SATISFIABLE = 416;
    const HTTP_EXPECTATION_FAILED = 417;
    const HTTP_I_AM_A_TEAPOT = 418;                                                   const HTTP_UNPROCESSABLE_ENTITY = 422;                                            const HTTP_LOCKED = 423;                                                          const HTTP_FAILED_DEPENDENCY = 424;                                               const HTTP_RESERVED_FOR_WEBDAV_ADVANCED_COLLECTIONS_EXPIRED_PROPOSAL = 425;       const HTTP_UPGRADE_REQUIRED = 426;                                                const HTTP_PRECONDITION_REQUIRED = 428;                                           const HTTP_TOO_MANY_REQUESTS = 429;                                               const HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE = 431;                                 const HTTP_INTERNAL_SERVER_ERROR = 500;
    const HTTP_NOT_IMPLEMENTED = 501;
    const HTTP_BAD_GATEWAY = 502;
    const HTTP_SERVICE_UNAVAILABLE = 503;
    const HTTP_GATEWAY_TIMEOUT = 504;
    const HTTP_VERSION_NOT_SUPPORTED = 505;
    const HTTP_VARIANT_ALSO_NEGOTIATES_EXPERIMENTAL = 506;                            const HTTP_INSUFFICIENT_STORAGE = 507;                                            const HTTP_LOOP_DETECTED = 508;                                                   const HTTP_NOT_EXTENDED = 510;                                                    const HTTP_NETWORK_AUTHENTICATION_REQUIRED = 511;                             
    
    public $headers;
    
    protected $content;
    
    protected $version;
    
    protected $statusCode;
    
    protected $statusText;
    
    protected $charset;
    
    public static $statusTexts = array(
        100 => 'Continue',
        101 => 'Switching Protocols',
        102 => 'Processing',                    200 => 'OK',
        201 => 'Created',
        202 => 'Accepted',
        203 => 'Non-Authoritative Information',
        204 => 'No Content',
        205 => 'Reset Content',
        206 => 'Partial Content',
        207 => 'Multi-Status',                  208 => 'Already Reported',              226 => 'IM Used',                       300 => 'Multiple Choices',
        301 => 'Moved Permanently',
        302 => 'Found',
        303 => 'See Other',
        304 => 'Not Modified',
        305 => 'Use Proxy',
        306 => 'Reserved',
        307 => 'Temporary Redirect',
        308 => 'Permanent Redirect',            400 => 'Bad Request',
        401 => 'Unauthorized',
        402 => 'Payment Required',
        403 => 'Forbidden',
        404 => 'Not Found',
        405 => 'Method Not Allowed',
        406 => 'Not Acceptable',
        407 => 'Proxy Authentication Required',
        408 => 'Request Timeout',
        409 => 'Conflict',
        410 => 'Gone',
        411 => 'Length Required',
        412 => 'Precondition Failed',
        413 => 'Request Entity Too Large',
        414 => 'Request-URI Too Long',
        415 => 'Unsupported Media Type',
        416 => 'Requested Range Not Satisfiable',
        417 => 'Expectation Failed',
        418 => 'I\'m a teapot',                                                       422 => 'Unprocessable Entity',                                                423 => 'Locked',                                                              424 => 'Failed Dependency',                                                   425 => 'Reserved for WebDAV advanced collections expired proposal',           426 => 'Upgrade Required',                                                    428 => 'Precondition Required',                                               429 => 'Too Many Requests',                                                   431 => 'Request Header Fields Too Large',                                     500 => 'Internal Server Error',
        501 => 'Not Implemented',
        502 => 'Bad Gateway',
        503 => 'Service Unavailable',
        504 => 'Gateway Timeout',
        505 => 'HTTP Version Not Supported',
        506 => 'Variant Also Negotiates (Experimental)',                              507 => 'Insufficient Storage',                                                508 => 'Loop Detected',                                                       510 => 'Not Extended',                                                        511 => 'Network Authentication Required',                                 );
    
    public function __construct($content = '', $status = 200, $headers = array())
    {
        $this->headers = new ResponseHeaderBag($headers);
        $this->setContent($content);
        $this->setStatusCode($status);
        $this->setProtocolVersion('1.0');
        if (!$this->headers->has('Date')) {
            $this->setDate(new \DateTime(null, new \DateTimeZone('UTC')));
        }
    }
    
    public static function create($content = '', $status = 200, $headers = array())
    {
        return new static($content, $status, $headers);
    }
    
    public function __toString()
    {
        return
            sprintf('HTTP/%s %s %s', $this->version, $this->statusCode, $this->statusText)."\r\n".
            $this->headers."\r\n".
            $this->getContent();
    }
    
    public function __clone()
    {
        $this->headers = clone $this->headers;
    }
    
    public function prepare(Request $request)
    {
        $headers = $this->headers;
        if ($this->isInformational() || in_array($this->statusCode, array(204, 304))) {
            $this->setContent(null);
        }
                if (!$headers->has('Content-Type')) {
            $format = $request->getRequestFormat();
            if (null !== $format && $mimeType = $request->getMimeType($format)) {
                $headers->set('Content-Type', $mimeType);
            }
        }
                $charset = $this->charset ?: 'UTF-8';
        if (!$headers->has('Content-Type')) {
            $headers->set('Content-Type', 'text/html; charset='.$charset);
        } elseif (0 === stripos($headers->get('Content-Type'), 'text/') && false === stripos($headers->get('Content-Type'), 'charset')) {
                        $headers->set('Content-Type', $headers->get('Content-Type').'; charset='.$charset);
        }
                if ($headers->has('Transfer-Encoding')) {
            $headers->remove('Content-Length');
        }
        if ($request->isMethod('HEAD')) {
                        $length = $headers->get('Content-Length');
            $this->setContent(null);
            if ($length) {
                $headers->set('Content-Length', $length);
            }
        }
                if ('HTTP/1.0' != $request->server->get('SERVER_PROTOCOL')) {
            $this->setProtocolVersion('1.1');
        }
                if ('1.0' == $this->getProtocolVersion() && 'no-cache' == $this->headers->get('Cache-Control')) {
            $this->headers->set('pragma', 'no-cache');
            $this->headers->set('expires', -1);
        }
        $this->ensureIEOverSSLCompatibility($request);
        return $this;
    }
    
    public function sendHeaders()
    {
                if (headers_sent()) {
            return $this;
        }
                header(sprintf('HTTP/%s %s %s', $this->version, $this->statusCode, $this->statusText), true, $this->statusCode);
                foreach ($this->headers->allPreserveCase() as $name => $values) {            
            foreach ($values as $value) {
                header($name.': '.$value);
            }
        }
                foreach ($this->headers->getCookies() as $cookie) {
            setcookie($cookie->getName(), $cookie->getValue(), $cookie->getExpiresTime(), $cookie->getPath(), $cookie->getDomain(), $cookie->isSecure(), $cookie->isHttpOnly());
        }
        return $this;
    }
    
    public function sendContent()
    {
        echo $this->content;
        return $this;
    }
    
    public function send()
    {
        $this->sendHeaders();
        $this->sendContent();
        if (function_exists('fastcgi_finish_request')) {
            fastcgi_finish_request();
        } elseif ('cli' !== PHP_SAPI) {
                                    $previous = null;
            $obStatus = ob_get_status(1);
            while (($level = ob_get_level()) > 0 && $level !== $previous) {
                $previous = $level;
                if ($obStatus[$level - 1]) {
                    if (version_compare(PHP_VERSION, '5.4', '>=')) {
                        if (isset($obStatus[$level - 1]['flags']) && ($obStatus[$level - 1]['flags'] & PHP_OUTPUT_HANDLER_REMOVABLE)) {
                            ob_end_flush();
                        }
                    } else {
                        if (isset($obStatus[$level - 1]['del']) && $obStatus[$level - 1]['del']) {
                            ob_end_flush();
                        }
                    }
                }
            }
            flush();
        }
        return $this;
    }
    
    public function setContent($content)
    {
        if (null !== $content && !is_string($content) && !is_numeric($content) && !is_callable(array($content, '__toString'))) {
            throw new \UnexpectedValueException(sprintf('The Response content must be a string or object implementing __toString(), "%s" given.', gettype($content)));
        }
        $this->content = (string) $content;
        return $this;
    }
    
    public function getContent()
    {
        return $this->content;
    }
    
    public function setProtocolVersion($version)
    {
        $this->version = $version;
        return $this;
    }
    
    public function getProtocolVersion()
    {
        return $this->version;
    }
    
    public function setStatusCode($code, $text = null)
    {
        $this->statusCode = $code = (int) $code;
        if ($this->isInvalid()) {
            throw new \InvalidArgumentException(sprintf('The HTTP status code "%s" is not valid.', $code));
        }
        if (null === $text) {
            $this->statusText = isset(self::$statusTexts[$code]) ? self::$statusTexts[$code] : '';
            return $this;
        }
        if (false === $text) {
            $this->statusText = '';
            return $this;
        }
        $this->statusText = $text;
        return $this;
    }
    
    public function getStatusCode()
    {
        return $this->statusCode;
    }
    
    public function setCharset($charset)
    {
        $this->charset = $charset;
        return $this;
    }
    
    public function getCharset()
    {
        return $this->charset;
    }
    
    public function isCacheable()
    {
        if (!in_array($this->statusCode, array(200, 203, 300, 301, 302, 404, 410))) {
            return false;
        }
        if ($this->headers->hasCacheControlDirective('no-store') || $this->headers->getCacheControlDirective('private')) {
            return false;
        }
        return $this->isValidateable() || $this->isFresh();
    }
    
    public function isFresh()
    {
        return $this->getTtl() > 0;
    }
    
    public function isValidateable()
    {
        return $this->headers->has('Last-Modified') || $this->headers->has('ETag');
    }
    
    public function setPrivate()
    {
        $this->headers->removeCacheControlDirective('public');
        $this->headers->addCacheControlDirective('private');
        return $this;
    }
    
    public function setPublic()
    {
        $this->headers->addCacheControlDirective('public');
        $this->headers->removeCacheControlDirective('private');
        return $this;
    }
    
    public function mustRevalidate()
    {
        return $this->headers->hasCacheControlDirective('must-revalidate') || $this->headers->has('proxy-revalidate');
    }
    
    public function getDate()
    {
        return $this->headers->getDate('Date', new \DateTime());
    }
    
    public function setDate(\DateTime $date)
    {
        $date->setTimezone(new \DateTimeZone('UTC'));
        $this->headers->set('Date', $date->format('D, d M Y H:i:s').' GMT');
        return $this;
    }
    
    public function getAge()
    {
        if (null !== $age = $this->headers->get('Age')) {
            return (int) $age;
        }
        return max(time() - $this->getDate()->format('U'), 0);
    }
    
    public function expire()
    {
        if ($this->isFresh()) {
            $this->headers->set('Age', $this->getMaxAge());
        }
        return $this;
    }
    
    public function getExpires()
    {
        try {
            return $this->headers->getDate('Expires');
        } catch (\RuntimeException $e) {
                        return \DateTime::createFromFormat(DATE_RFC2822, 'Sat, 01 Jan 00 00:00:00 +0000');
        }
    }
    
    public function setExpires(\DateTime $date = null)
    {
        if (null === $date) {
            $this->headers->remove('Expires');
        } else {
            $date = clone $date;
            $date->setTimezone(new \DateTimeZone('UTC'));
            $this->headers->set('Expires', $date->format('D, d M Y H:i:s').' GMT');
        }
        return $this;
    }
    
    public function getMaxAge()
    {
        if ($this->headers->hasCacheControlDirective('s-maxage')) {
            return (int) $this->headers->getCacheControlDirective('s-maxage');
        }
        if ($this->headers->hasCacheControlDirective('max-age')) {
            return (int) $this->headers->getCacheControlDirective('max-age');
        }
        if (null !== $this->getExpires()) {
            return $this->getExpires()->format('U') - $this->getDate()->format('U');
        }
        return null;
    }
    
    public function setMaxAge($value)
    {
        $this->headers->addCacheControlDirective('max-age', $value);
        return $this;
    }
    
    public function setSharedMaxAge($value)
    {
        $this->setPublic();
        $this->headers->addCacheControlDirective('s-maxage', $value);
        return $this;
    }
    
    public function getTtl()
    {
        if (null !== $maxAge = $this->getMaxAge()) {
            return $maxAge - $this->getAge();
        }
        return null;
    }
    
    public function setTtl($seconds)
    {
        $this->setSharedMaxAge($this->getAge() + $seconds);
        return $this;
    }
    
    public function setClientTtl($seconds)
    {
        $this->setMaxAge($this->getAge() + $seconds);
        return $this;
    }
    
    public function getLastModified()
    {
        return $this->headers->getDate('Last-Modified');
    }
    
    public function setLastModified(\DateTime $date = null)
    {
        if (null === $date) {
            $this->headers->remove('Last-Modified');
        } else {
            $date = clone $date;
            $date->setTimezone(new \DateTimeZone('UTC'));
            $this->headers->set('Last-Modified', $date->format('D, d M Y H:i:s').' GMT');
        }
        return $this;
    }
    
    public function getEtag()
    {
        return $this->headers->get('ETag');
    }
    
    public function setEtag($etag = null, $weak = false)
    {
        if (null === $etag) {
            $this->headers->remove('Etag');
        } else {
            if (0 !== strpos($etag, '"')) {
                $etag = '"'.$etag.'"';
            }
            $this->headers->set('ETag', (true === $weak ? 'W/' : '').$etag);
        }
        return $this;
    }
    
    public function setCache(array $options)
    {
        if ($diff = array_diff(array_keys($options), array('etag', 'last_modified', 'max_age', 's_maxage', 'private', 'public'))) {
            throw new \InvalidArgumentException(sprintf('Response does not support the following options: "%s".', implode('", "', array_values($diff))));
        }
        if (isset($options['etag'])) {
            $this->setEtag($options['etag']);
        }
        if (isset($options['last_modified'])) {
            $this->setLastModified($options['last_modified']);
        }
        if (isset($options['max_age'])) {
            $this->setMaxAge($options['max_age']);
        }
        if (isset($options['s_maxage'])) {
            $this->setSharedMaxAge($options['s_maxage']);
        }
        if (isset($options['public'])) {
            if ($options['public']) {
                $this->setPublic();
            } else {
                $this->setPrivate();
            }
        }
        if (isset($options['private'])) {
            if ($options['private']) {
                $this->setPrivate();
            } else {
                $this->setPublic();
            }
        }
        return $this;
    }
    
    public function setNotModified()
    {
        $this->setStatusCode(304);        
        $this->setContent(null);
                foreach (array('Allow', 'Content-Encoding', 'Content-Language', 'Content-Length', 'Content-MD5', 'Content-Type', 'Last-Modified') as $header) {
            $this->headers->remove($header);
        }
        return $this;
    }
    
    public function hasVary()
    {
        return null !== $this->headers->get('Vary');
    }
    
    public function getVary()
    {
        if (!$vary = $this->headers->get('Vary')) {
            return array();
        }
        return is_array($vary) ? $vary : preg_split('/[\s,]+/', $vary);
    }
    
    public function setVary($headers, $replace = true)
    {
        $this->headers->set('Vary', $headers, $replace);
        return $this;
    }
    
    public function isNotModified(Request $request)
    {
        if (!$request->isMethodSafe()) {           
            return false;
        }
        $lastModified = $request->headers->get('If-Modified-Since');
        $notModified = false;
        if ($etags = $request->getEtags()) {            
            $notModified = (in_array($this->getEtag(), $etags) || in_array('*', $etags)) && (!$lastModified || $this->headers->get('Last-Modified') == $lastModified);
        } elseif ($lastModified) {
            $notModified = $lastModified == $this->headers->get('Last-Modified');
        }
        if ($notModified) {
            $this->setNotModified();
        }
        return $notModified;
    }
        
    public function isInvalid()
    {
        return $this->statusCode < 100 || $this->statusCode >= 600;
    }
    
    public function isInformational()
    {
        return $this->statusCode >= 100 && $this->statusCode < 200;
    }
    
    public function isSuccessful()
    {
        return $this->statusCode >= 200 && $this->statusCode < 300;
    }
    
    public function isRedirection()
    {
        return $this->statusCode >= 300 && $this->statusCode < 400;
    }
    
    public function isClientError()
    {
        return $this->statusCode >= 400 && $this->statusCode < 500;
    }
    
    public function isServerError()
    {
        return $this->statusCode >= 500 && $this->statusCode < 600;
    }
    
    public function isOk()
    {
        return 200 === $this->statusCode;
    }
    
    public function isForbidden()
    {
        return 403 === $this->statusCode;
    }
    
    public function isNotFound()
    {
        return 404 === $this->statusCode;
    }
    
    public function isRedirect($location = null)
    {
        return in_array($this->statusCode, array(201, 301, 302, 303, 307, 308)) && (null === $location ?: $location == $this->headers->get('Location'));
    }
    
    public function isEmpty()
    {
        return in_array($this->statusCode, array(201, 204, 304));
    }
    
    protected function ensureIEOverSSLCompatibility(Request $request)
    {
        if (false !== stripos($this->headers->get('Content-Disposition'), 'attachment') && preg_match('/MSIE (.*?);/i', $request->server->get('HTTP_USER_AGENT'), $match) == 1 && true === $request->isSecure()) {
            if (intval(preg_replace("/(MSIE )(.*?);/", "$2", $match[0])) < 9) {
                $this->headers->remove('Cache-Control');
            }
        }
    }
}
}
namespace phpex\Foundation{
class ResponseHeaderBag extends HeaderBag
{
    const COOKIES_FLAT           = 'flat';
    const COOKIES_ARRAY          = 'array';
    const DISPOSITION_ATTACHMENT = 'attachment';
    const DISPOSITION_INLINE     = 'inline';
    
    protected $computedCacheControl = array();
    
    protected $cookies              = array();
    
    protected $headerNames          = array();
    
    public function __construct(array $headers = array())
    {
        parent::__construct($headers);
        if (!isset($this->headers['cache-control'])) {
            $this->set('Cache-Control', '');
        }
    }
    
    public function __toString()
    {
        $cookies = '';
        foreach ($this->getCookies() as $cookie) {
            $cookies .= 'Set-Cookie: '.$cookie."\r\n";
        }
        ksort($this->headerNames);
        return parent::__toString().$cookies;
    }
    
    public function allPreserveCase()
    {
        return array_combine($this->headerNames, $this->headers);
    }
    
    public function replace(array $headers = array())
    {
        $this->headerNames = array();
        parent::replace($headers);
        if (!isset($this->headers['cache-control'])) {
            $this->set('Cache-Control', '');
        }
    }
    
    public function set($key, $values, $replace = true)
    {
        parent::set($key, $values, $replace);
        $uniqueKey = strtr(strtolower($key), '_', '-');
        $this->headerNames[$uniqueKey] = $key;
                if (in_array($uniqueKey, array('cache-control', 'etag', 'last-modified', 'expires'))) {
            $computed = $this->computeCacheControlValue();
            $this->headers['cache-control'] = array($computed);
            $this->headerNames['cache-control'] = 'Cache-Control';
            $this->computedCacheControl = $this->parseCacheControl($computed);
        }
    }
    
    public function remove($key)
    {
        parent::remove($key);
        $uniqueKey = strtr(strtolower($key), '_', '-');
        unset($this->headerNames[$uniqueKey]);
        if ('cache-control' === $uniqueKey) {
            $this->computedCacheControl = array();
        }
    }
    
    public function hasCacheControlDirective($key)
    {
        return array_key_exists($key, $this->computedCacheControl);
    }
    
    public function getCacheControlDirective($key)
    {
        return array_key_exists($key, $this->computedCacheControl) ? $this->computedCacheControl[$key] : null;
    }
    
    public function setCookie(Cookie $cookie)
    {
        $this->cookies[$cookie->getDomain()][$cookie->getPath()][$cookie->getName()] = $cookie;
    }
    
    public function removeCookie($name, $path = '/', $domain = null)
    {
        if (null === $path) {
            $path = '/';
        }
        unset($this->cookies[$domain][$path][$name]);
        if (empty($this->cookies[$domain][$path])) {
            unset($this->cookies[$domain][$path]);
            if (empty($this->cookies[$domain])) {
                unset($this->cookies[$domain]);
            }
        }
    }
    
    public function getCookies($format = self::COOKIES_FLAT)
    {
        if (!in_array($format, array(self::COOKIES_FLAT, self::COOKIES_ARRAY))) {
            throw new \InvalidArgumentException(sprintf('Format "%s" invalid (%s).', $format, implode(', ', array(self::COOKIES_FLAT, self::COOKIES_ARRAY))));
        }
        if (self::COOKIES_ARRAY === $format) {
            return $this->cookies;
        }
        $flattenedCookies = array();
        foreach ($this->cookies as $path) {
            foreach ($path as $cookies) {
                foreach ($cookies as $cookie) {
                    $flattenedCookies[] = $cookie;
                }
            }
        }
        return $flattenedCookies;
    }
    
    public function clearCookie($name, $path = '/', $domain = null)
    {
        $this->setCookie(new Cookie($name, null, 1, $path, $domain));
    }
    
    public function makeDisposition($disposition, $filename, $filenameFallback = '')
    {
        if (!in_array($disposition, array(self::DISPOSITION_ATTACHMENT, self::DISPOSITION_INLINE))) {
            throw new \InvalidArgumentException(sprintf('The disposition must be either "%s" or "%s".', self::DISPOSITION_ATTACHMENT, self::DISPOSITION_INLINE));
        }
        if ('' == $filenameFallback) {
            $filenameFallback = $filename;
        }
                if (!preg_match('/^[\x20-\x7e]*$/', $filenameFallback)) {
            throw new \InvalidArgumentException('The filename fallback must only contain ASCII characters.');
        }
                if (false !== strpos($filenameFallback, '%')) {
            throw new \InvalidArgumentException('The filename fallback cannot contain the "%" character.');
        }
                if (false !== strpos($filename, '/') || false !== strpos($filename, '\\') || false !== strpos($filenameFallback, '/') || false !== strpos($filenameFallback, '\\')) {
            throw new \InvalidArgumentException('The filename and the fallback cannot contain the "/" and "\\" characters.');
        }
        $output = sprintf('%s; filename="%s"', $disposition, str_replace('"', '\\"', $filenameFallback));
        if ($filename !== $filenameFallback) {
            $output .= sprintf("; filename*=utf-8''%s", rawurlencode($filename));
        }
        return $output;
    }
    
    protected function computeCacheControlValue()
    {
        if (!$this->cacheControl && !$this->has('ETag') && !$this->has('Last-Modified') && !$this->has('Expires')) {
            return 'no-cache';
        }
        if (!$this->cacheControl) {
                        return 'private, must-revalidate';
        }
        $header = $this->getCacheControlHeader();
        if (isset($this->cacheControl['public']) || isset($this->cacheControl['private'])) {
            return $header;
        }
                if (!isset($this->cacheControl['s-maxage'])) {
            return $header.', private';
        }
        return $header;
    }
}
}
namespace phpex\Foundation{
class ServerBag extends ParameterBag
{
    
    public function getHeaders()
    {
        $headers = array();
        $contentHeaders = array('CONTENT_LENGTH' => true, 'CONTENT_MD5' => true, 'CONTENT_TYPE' => true);
        foreach ($this->parameters as $key => $value) {
            if (0 === strpos($key, 'HTTP_')) {
                $headers[substr($key, 5)] = $value;
            }
                        elseif (isset($contentHeaders[$key])) {
                $headers[$key] = $value;
            }
        }
        if (isset($this->parameters['PHP_AUTH_USER'])) {
            $headers['PHP_AUTH_USER'] = $this->parameters['PHP_AUTH_USER'];
            $headers['PHP_AUTH_PW'] = isset($this->parameters['PHP_AUTH_PW']) ? $this->parameters['PHP_AUTH_PW'] : '';
        } else {
            
            $authorizationHeader = null;
            if (isset($this->parameters['HTTP_AUTHORIZATION'])) {
                $authorizationHeader = $this->parameters['HTTP_AUTHORIZATION'];
            } elseif (isset($this->parameters['REDIRECT_HTTP_AUTHORIZATION'])) {
                $authorizationHeader = $this->parameters['REDIRECT_HTTP_AUTHORIZATION'];
            }
            if (null !== $authorizationHeader) {
                if (0 === stripos($authorizationHeader, 'basic')) {
                                        $exploded = explode(':', base64_decode(substr($authorizationHeader, 6)));
                    if (count($exploded) == 2) {
                        list($headers['PHP_AUTH_USER'], $headers['PHP_AUTH_PW']) = $exploded;
                    }
                } elseif (empty($this->parameters['PHP_AUTH_DIGEST']) && (0 === stripos($authorizationHeader, 'digest'))) {
                                        $headers['PHP_AUTH_DIGEST'] = $authorizationHeader;
                    $this->parameters['PHP_AUTH_DIGEST'] = $authorizationHeader;
                }
            }
        }
                if (isset($headers['PHP_AUTH_USER'])) {
            $headers['AUTHORIZATION'] = 'Basic '.base64_encode($headers['PHP_AUTH_USER'].':'.$headers['PHP_AUTH_PW']);
        } elseif (isset($headers['PHP_AUTH_DIGEST'])) {
            $headers['AUTHORIZATION'] = $headers['PHP_AUTH_DIGEST'];
        }
        return $headers;
    }
}
}
namespace phpex\Foundation{
class Session extends ParameterBag {
    protected $started = false;
    
    public function start() {
        if ($this->started)
            return;
        session_start();
        $this->parameters = $_SESSION;
        $this->started = true;
    }
    public function isStarted() {
        if (isset($_SESSION)) {
            $this->started = true;
            $this->parameters = $_SESSION;
        }
        return $this->started;
    }
    
    function clear() {
        $this->parameters = $_SESSION = array();
        session_destroy();
    }
    function __construct(array $parameters = array()) {
        ini_set('session.auto_start', 0);
                $this->setCookieDomain($parameters["cookie_domain"]);
        $this->name($parameters["session_name"]);
        $this->path($parameters["session_path"]);
        $this->setCallback($parameters["session_callback"]);
        if ($parameters["session_auto_start"])
            $this->start();
        parent::__construct(array());
    }
    
    function session_id($session_id = null) {
        return !is_null($session_id) ? session_id($session_id) : session_id();
    }
    
    function setCookieDomain($sessionDomain = null) {
        $return = ini_get('session.cookie_domain');
        if (!empty($sessionDomain)) {
            ini_set('session.cookie_domain', $sessionDomain);         }
        return $return;
    }
    function detectID() {
        if (session_id() != '') {
            return session_id();
        }
        if ($this->useCookies()) {
            if (isset($_COOKIE[$this->name()])) {
                return $_COOKIE[$this->name()];
            }
        } else {
            if (isset($_GET[$this->name()])) {
                return $_GET[$this->name()];
            }
            if (isset($_POST[$this->name()])) {
                return $_POST[$this->name()];
            }
        }
        return null;
    }
    
    public function useCookies($useCookies = null) {
        $return = ini_get('session.use_cookies') ? true : false;
        if (isset($useCookies)) {
            ini_set('session.use_cookies', $useCookies ? 1 : 0);
        }
        return $return;
    }
    
    function name($name = null) {
        return isset($name) ? session_name($name) : session_name();
    }
    
    public function path($path = null) {
        empty($path)or is_dir($path) or mkdir($path, 0777, true);
        return !empty($path) ? session_save_path($path) : session_save_path();
    }
    
    public function setCallback($callback = null) {
        $return = ini_get('unserialize_callback_func');
        if (!empty($callback)) {
            ini_set('unserialize_callback_func', $callback);
        }
        return $return;
    }
    public function save() {
        $_SESSION = $this->parameters;
    }
    public function __destruct() {
        $this->save();
    }
    public function set($key, $value) {
        parent::set($key, $value);
        return $this;
    }
    public function remove($key) {
        parent::remove($key);
        return $this;
    }
    function switchSession($sessionName) {
        session_write_close();
        Q()->getSession()->name($sessionName);
        if (Q()->cookies->has($sessionName)) {
            $this->session_id(Q()->cookies->get($sessionName));
        } else {
            $this->session_id(substr(sha1(mt_rand()), 0, 32));
        }
        session_start();
        $this->parameters = $_SESSION;
    }
    function switchAppSession($appName) {
        if (ins()->has("app." . ucfirst($appName))) {
            
            $app = ins()->get("app." . ucfirst($appName));
        } else {
            $trace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS);
            throws("App 不存在", $trace[0]["file"], $trace[0]["line"], $trace[1]["class"] . "::" . $trace[1]["function"]);
        }
        $this->switchSession($app->getSessionName());
    }
}
}
namespace phpex\Foundation\File{
use phpex\Foundation\File\Exception\FileException;
use phpex\Foundation\File\Exception\FileNotFoundException;
use phpex\Foundation\File\MimeType\MimeTypeGuesser;
use phpex\Foundation\File\MimeType\ExtensionGuesser;
class File extends \SplFileInfo
{
    
    public function __construct($path, $checkPath = true)
    {
        if ($checkPath && !is_file($path)) {
            throw new FileNotFoundException($path);
        }
        parent::__construct($path);
    }
    
    public function guessExtension()
    {
        $type = $this->getMimeType();
        $guesser = ExtensionGuesser::getInstance();
        return $guesser->guess($type);
    }
    
    public function getMimeType()
    {
        $guesser = MimeTypeGuesser::getInstance();
        return $guesser->guess($this->getPathname());
    }
    
    public function getExtension()
    {
        return pathinfo($this->getBasename(), PATHINFO_EXTENSION);
    }
    
    public function move($directory, $name = null)
    {
        $target = $this->getTargetFile($directory, $name);
        if (!@rename($this->getPathname(), $target)) {
            $error = error_get_last();
            throw new FileException(sprintf('Could not move the file "%s" to "%s" (%s)', $this->getPathname(), $target, strip_tags($error['message'])));
        }
        @chmod($target, 0666 & ~umask());
        return $target;
    }
    protected function getTargetFile($directory, $name = null)
    {
        if (!is_dir($directory)) {
            if (false === @mkdir($directory, 0777, true)) {
                throw new FileException(sprintf('Unable to create the "%s" directory', $directory));
            }
        } elseif (!is_writable($directory)) {
            throw new FileException(sprintf('Unable to write in the "%s" directory', $directory));
        }
        $target = rtrim($directory, '/\\').DIRECTORY_SEPARATOR.(null === $name ? $this->getBasename() : $this->getName($name));
        return new File($target, false);
    }
    
    protected function getName($name)
    {
        $originalName = str_replace('\\', '/', $name);
        $pos = strrpos($originalName, '/');
        $originalName = false === $pos ? $originalName : substr($originalName, $pos + 1);
        return $originalName;
    }
}
}
namespace phpex\Foundation\File{
use phpex\Foundation\File\Exception\FileException;
use phpex\Foundation\File\Exception\FileNotFoundException;
use phpex\Foundation\File\MimeType\ExtensionGuesser;
class UploadedFile extends File
{
    
    private $test = false;
    
    private $originalName;
    
    private $mimeType;
    
    private $size;
    
    private $error;
    
    public function __construct($path, $originalName, $mimeType = null, $size = null, $error = null, $test = false)
    {
        $this->originalName = $this->getName($originalName);
        $this->mimeType = $mimeType ?: 'application/octet-stream';
        $this->size = $size;
        $this->error = $error ?: UPLOAD_ERR_OK;
        $this->test = (bool) $test;
        parent::__construct($path, UPLOAD_ERR_OK === $this->error);
    }
    
    public function getClientOriginalName()
    {
        return $this->originalName;
    }
    
    public function getClientOriginalExtension()
    {
        return pathinfo($this->originalName, PATHINFO_EXTENSION);
    }
    
    public function getClientMimeType()
    {
        return $this->mimeType;
    }
    
    public function guessClientExtension()
    {
        $type = $this->getClientMimeType();
        $guesser = ExtensionGuesser::getInstance();
        return $guesser->guess($type);
    }
    
    public function getClientSize()
    {
        return $this->size;
    }
    
    public function getError()
    {
        return $this->error;
    }
    
    public function isValid()
    {
        $isOk = $this->error === UPLOAD_ERR_OK;
        return $this->test ? $isOk : $isOk && is_uploaded_file($this->getPathname());
    }
    
    public function move($directory, $name = null)
    {
        if ($this->isValid()) {
            if ($this->test) {
                return parent::move($directory, $name);
            }
            $target = $this->getTargetFile($directory, $name);
            if (!@move_uploaded_file($this->getPathname(), $target)) {
                $error = error_get_last();
                throw new FileException(sprintf('Could not move the file "%s" to "%s" (%s)', $this->getPathname(), $target, strip_tags($error['message'])));
            }
            @chmod($target, 0666 & ~umask());
            return $target;
        }
        throw new FileException($this->getErrorMessage());
    }
    
    public static function getMaxFilesize()
    {
        $iniMax = strtolower(ini_get('upload_max_filesize'));
        if ('' === $iniMax) {
            return PHP_INT_MAX;
        }
        $max = ltrim($iniMax, '+');
        if (0 === strpos($max, '0x')) {
            $max = intval($max, 16);
        } elseif (0 === strpos($max, '0')) {
            $max = intval($max, 8);
        } else {
            $max = intval($max);
        }
        switch (substr($iniMax, -1)) {
            case 't': $max *= 1024;
            case 'g': $max *= 1024;
            case 'm': $max *= 1024;
            case 'k': $max *= 1024;
        }
        return $max;
    }
    
    public function getErrorMessage()
    {
        static $errors = array(
            UPLOAD_ERR_INI_SIZE   => 'The file "%s" exceeds your upload_max_filesize ini directive (limit is %d kb).',
            UPLOAD_ERR_FORM_SIZE  => 'The file "%s" exceeds the upload limit defined in your form.',
            UPLOAD_ERR_PARTIAL    => 'The file "%s" was only partially uploaded.',
            UPLOAD_ERR_NO_FILE    => 'No file was uploaded.',
            UPLOAD_ERR_CANT_WRITE => 'The file "%s" could not be written on disk.',
            UPLOAD_ERR_NO_TMP_DIR => 'File could not be uploaded: missing temporary directory.',
            UPLOAD_ERR_EXTENSION  => 'File upload was stopped by a PHP extension.',
        );
        $errorCode = $this->error;
        $maxFilesize = $errorCode === UPLOAD_ERR_INI_SIZE ? self::getMaxFilesize() / 1024 : 0;
        $message = isset($errors[$errorCode]) ? $errors[$errorCode] : 'The file "%s" was not uploaded due to an unknown error.';
        return sprintf($message, $this->getClientOriginalName(), $maxFilesize);
    }
}
}
namespace phpex\Foundation\File\Exception{
class FileException extends \RuntimeException
{
}
}
namespace phpex\Foundation\File\Exception{
class AccessDeniedException extends FileException
{
    
    public function __construct($path)
    {
        parent::__construct(sprintf('The file %s could not be accessed', $path));
    }
}
}
namespace phpex\Foundation\File\Exception{
class FileNotFoundException extends FileException
{
    
    public function __construct($path)
    {
        parent::__construct(sprintf('The file "%s" does not exist', $path));
    }
}
}
namespace phpex\Foundation\File\Exception{
class UnexpectedTypeException extends FileException
{
    public function __construct($value, $expectedType)
    {
        parent::__construct(sprintf('Expected argument of type %s, %s given', $expectedType, is_object($value) ? get_class($value) : gettype($value)));
    }
}
}
namespace phpex\Foundation\File\Exception{
class UploadException extends FileException
{
}
}
namespace phpex\Foundation\File\MimeType{
interface ExtensionGuesserInterface
{
    
    public function guess($mimeType);
}
}
namespace phpex\Foundation\File\MimeType{
class ExtensionGuesser implements ExtensionGuesserInterface
{
    
    private static $instance = null;
    
    protected $guessers = array();
    
    public static function getInstance()
    {
        if (null === self::$instance) {
            self::$instance = new self();
        }
        return self::$instance;
    }
    
    private function __construct()
    {
        $this->register(new MimeTypeExtensionGuesser());
    }
    
    public function register(ExtensionGuesserInterface $guesser)
    {
        array_unshift($this->guessers, $guesser);
    }
    
    public function guess($mimeType)
    {
        foreach ($this->guessers as $guesser) {
            if (null !== $extension = $guesser->guess($mimeType)) {
                return $extension;
            }
        }
    }
}
}
namespace phpex\Foundation\File\MimeType{
use phpex\Foundation\File\Exception\FileNotFoundException;
use phpex\Foundation\File\Exception\AccessDeniedException;
interface MimeTypeGuesserInterface
{
    
    public function guess($path);
}
}
namespace phpex\Foundation\File\MimeType{
use phpex\Foundation\File\Exception\FileNotFoundException;
use phpex\Foundation\File\Exception\AccessDeniedException;
class FileBinaryMimeTypeGuesser implements MimeTypeGuesserInterface
{
    private $cmd;
    
    public function __construct($cmd = 'file -b --mime %s 2>/dev/null')
    {
        $this->cmd = $cmd;
    }
    
    public static function isSupported()
    {
        return !defined('PHP_WINDOWS_VERSION_BUILD') && function_exists('passthru') && function_exists('escapeshellarg');
    }
    
    public function guess($path)
    {
        if (!is_file($path)) {
            throw new FileNotFoundException($path);
        }
        if (!is_readable($path)) {
            throw new AccessDeniedException($path);
        }
        if (!self::isSupported()) {
            return;
        }
        ob_start();
                passthru(sprintf($this->cmd, escapeshellarg($path)), $return);
        if ($return > 0) {
            ob_end_clean();
            return;
        }
        $type = trim(ob_get_clean());
        if (!preg_match('#^([a-z0-9\-]+/[a-z0-9\-\.]+)#i', $type, $match)) {
                        return;
        }
        return $match[1];
    }
}
}
namespace phpex\Foundation\File\MimeType{
use phpex\Foundation\File\Exception\FileNotFoundException;
use phpex\Foundation\File\Exception\AccessDeniedException;
class FileinfoMimeTypeGuesser implements MimeTypeGuesserInterface
{
    private $magicFile;
    
    public function __construct($magicFile = null)
    {
        $this->magicFile = $magicFile;
    }
    
    public static function isSupported()
    {
        return function_exists('finfo_open');
    }
    
    public function guess($path)
    {
        if (!is_file($path)) {
            throw new FileNotFoundException($path);
        }
        if (!is_readable($path)) {
            throw new AccessDeniedException($path);
        }
        if (!self::isSupported()) {
            return;
        }
        if (!$finfo = new \finfo(FILEINFO_MIME_TYPE, $this->magicFile)) {
            return;
        }
        return $finfo->file($path);
    }
}
}
namespace phpex\Foundation\File\MimeType{
class MimeTypeExtensionGuesser implements ExtensionGuesserInterface
{
    
    protected $defaultExtensions = array(
        'application/andrew-inset' => 'ez',
        'application/applixware' => 'aw',
        'application/atom+xml' => 'atom',
        'application/atomcat+xml' => 'atomcat',
        'application/atomsvc+xml' => 'atomsvc',
        'application/ccxml+xml' => 'ccxml',
        'application/cdmi-capability' => 'cdmia',
        'application/cdmi-container' => 'cdmic',
        'application/cdmi-domain' => 'cdmid',
        'application/cdmi-object' => 'cdmio',
        'application/cdmi-queue' => 'cdmiq',
        'application/cu-seeme' => 'cu',
        'application/davmount+xml' => 'davmount',
        'application/docbook+xml' => 'dbk',
        'application/dssc+der' => 'dssc',
        'application/dssc+xml' => 'xdssc',
        'application/ecmascript' => 'ecma',
        'application/emma+xml' => 'emma',
        'application/epub+zip' => 'epub',
        'application/exi' => 'exi',
        'application/font-tdpfr' => 'pfr',
        'application/gml+xml' => 'gml',
        'application/gpx+xml' => 'gpx',
        'application/gxf' => 'gxf',
        'application/hyperstudio' => 'stk',
        'application/inkml+xml' => 'ink',
        'application/ipfix' => 'ipfix',
        'application/java-archive' => 'jar',
        'application/java-serialized-object' => 'ser',
        'application/java-vm' => 'class',
        'application/javascript' => 'js',
        'application/json' => 'json',
        'application/jsonml+json' => 'jsonml',
        'application/lost+xml' => 'lostxml',
        'application/mac-binhex40' => 'hqx',
        'application/mac-compactpro' => 'cpt',
        'application/mads+xml' => 'mads',
        'application/marc' => 'mrc',
        'application/marcxml+xml' => 'mrcx',
        'application/mathematica' => 'ma',
        'application/mathml+xml' => 'mathml',
        'application/mbox' => 'mbox',
        'application/mediaservercontrol+xml' => 'mscml',
        'application/metalink+xml' => 'metalink',
        'application/metalink4+xml' => 'meta4',
        'application/mets+xml' => 'mets',
        'application/mods+xml' => 'mods',
        'application/mp21' => 'm21',
        'application/mp4' => 'mp4s',
        'application/msword' => 'doc',
        'application/mxf' => 'mxf',
        'application/octet-stream' => 'bin',
        'application/oda' => 'oda',
        'application/oebps-package+xml' => 'opf',
        'application/ogg' => 'ogx',
        'application/omdoc+xml' => 'omdoc',
        'application/onenote' => 'onetoc',
        'application/oxps' => 'oxps',
        'application/patch-ops-error+xml' => 'xer',
        'application/pdf' => 'pdf',
        'application/pgp-encrypted' => 'pgp',
        'application/pgp-signature' => 'asc',
        'application/pics-rules' => 'prf',
        'application/pkcs10' => 'p10',
        'application/pkcs7-mime' => 'p7m',
        'application/pkcs7-signature' => 'p7s',
        'application/pkcs8' => 'p8',
        'application/pkix-attr-cert' => 'ac',
        'application/pkix-cert' => 'cer',
        'application/pkix-crl' => 'crl',
        'application/pkix-pkipath' => 'pkipath',
        'application/pkixcmp' => 'pki',
        'application/pls+xml' => 'pls',
        'application/postscript' => 'ai',
        'application/prs.cww' => 'cww',
        'application/pskc+xml' => 'pskcxml',
        'application/rdf+xml' => 'rdf',
        'application/reginfo+xml' => 'rif',
        'application/relax-ng-compact-syntax' => 'rnc',
        'application/resource-lists+xml' => 'rl',
        'application/resource-lists-diff+xml' => 'rld',
        'application/rls-services+xml' => 'rs',
        'application/rpki-ghostbusters' => 'gbr',
        'application/rpki-manifest' => 'mft',
        'application/rpki-roa' => 'roa',
        'application/rsd+xml' => 'rsd',
        'application/rss+xml' => 'rss',
        'application/rtf' => 'rtf',
        'application/sbml+xml' => 'sbml',
        'application/scvp-cv-request' => 'scq',
        'application/scvp-cv-response' => 'scs',
        'application/scvp-vp-request' => 'spq',
        'application/scvp-vp-response' => 'spp',
        'application/sdp' => 'sdp',
        'application/set-payment-initiation' => 'setpay',
        'application/set-registration-initiation' => 'setreg',
        'application/shf+xml' => 'shf',
        'application/smil+xml' => 'smi',
        'application/sparql-query' => 'rq',
        'application/sparql-results+xml' => 'srx',
        'application/srgs' => 'gram',
        'application/srgs+xml' => 'grxml',
        'application/sru+xml' => 'sru',
        'application/ssdl+xml' => 'ssdl',
        'application/ssml+xml' => 'ssml',
        'application/tei+xml' => 'tei',
        'application/thraud+xml' => 'tfi',
        'application/timestamped-data' => 'tsd',
        'application/vnd.3gpp.pic-bw-large' => 'plb',
        'application/vnd.3gpp.pic-bw-small' => 'psb',
        'application/vnd.3gpp.pic-bw-var' => 'pvb',
        'application/vnd.3gpp2.tcap' => 'tcap',
        'application/vnd.3m.post-it-notes' => 'pwn',
        'application/vnd.accpac.simply.aso' => 'aso',
        'application/vnd.accpac.simply.imp' => 'imp',
        'application/vnd.acucobol' => 'acu',
        'application/vnd.acucorp' => 'atc',
        'application/vnd.adobe.air-application-installer-package+zip' => 'air',
        'application/vnd.adobe.formscentral.fcdt' => 'fcdt',
        'application/vnd.adobe.fxp' => 'fxp',
        'application/vnd.adobe.xdp+xml' => 'xdp',
        'application/vnd.adobe.xfdf' => 'xfdf',
        'application/vnd.ahead.space' => 'ahead',
        'application/vnd.airzip.filesecure.azf' => 'azf',
        'application/vnd.airzip.filesecure.azs' => 'azs',
        'application/vnd.amazon.ebook' => 'azw',
        'application/vnd.americandynamics.acc' => 'acc',
        'application/vnd.amiga.ami' => 'ami',
        'application/vnd.android.package-archive' => 'apk',
        'application/vnd.anser-web-certificate-issue-initiation' => 'cii',
        'application/vnd.anser-web-funds-transfer-initiation' => 'fti',
        'application/vnd.antix.game-component' => 'atx',
        'application/vnd.apple.installer+xml' => 'mpkg',
        'application/vnd.apple.mpegurl' => 'm3u8',
        'application/vnd.aristanetworks.swi' => 'swi',
        'application/vnd.astraea-software.iota' => 'iota',
        'application/vnd.audiograph' => 'aep',
        'application/vnd.blueice.multipass' => 'mpm',
        'application/vnd.bmi' => 'bmi',
        'application/vnd.businessobjects' => 'rep',
        'application/vnd.chemdraw+xml' => 'cdxml',
        'application/vnd.chipnuts.karaoke-mmd' => 'mmd',
        'application/vnd.cinderella' => 'cdy',
        'application/vnd.claymore' => 'cla',
        'application/vnd.cloanto.rp9' => 'rp9',
        'application/vnd.clonk.c4group' => 'c4g',
        'application/vnd.cluetrust.cartomobile-config' => 'c11amc',
        'application/vnd.cluetrust.cartomobile-config-pkg' => 'c11amz',
        'application/vnd.commonspace' => 'csp',
        'application/vnd.contact.cmsg' => 'cdbcmsg',
        'application/vnd.cosmocaller' => 'cmc',
        'application/vnd.crick.clicker' => 'clkx',
        'application/vnd.crick.clicker.keyboard' => 'clkk',
        'application/vnd.crick.clicker.palette' => 'clkp',
        'application/vnd.crick.clicker.template' => 'clkt',
        'application/vnd.crick.clicker.wordbank' => 'clkw',
        'application/vnd.criticaltools.wbs+xml' => 'wbs',
        'application/vnd.ctc-posml' => 'pml',
        'application/vnd.cups-ppd' => 'ppd',
        'application/vnd.curl.car' => 'car',
        'application/vnd.curl.pcurl' => 'pcurl',
        'application/vnd.dart' => 'dart',
        'application/vnd.data-vision.rdz' => 'rdz',
        'application/vnd.dece.data' => 'uvf',
        'application/vnd.dece.ttml+xml' => 'uvt',
        'application/vnd.dece.unspecified' => 'uvx',
        'application/vnd.dece.zip' => 'uvz',
        'application/vnd.denovo.fcselayout-link' => 'fe_launch',
        'application/vnd.dna' => 'dna',
        'application/vnd.dolby.mlp' => 'mlp',
        'application/vnd.dpgraph' => 'dpg',
        'application/vnd.dreamfactory' => 'dfac',
        'application/vnd.ds-keypoint' => 'kpxx',
        'application/vnd.dvb.ait' => 'ait',
        'application/vnd.dvb.service' => 'svc',
        'application/vnd.dynageo' => 'geo',
        'application/vnd.ecowin.chart' => 'mag',
        'application/vnd.enliven' => 'nml',
        'application/vnd.epson.esf' => 'esf',
        'application/vnd.epson.msf' => 'msf',
        'application/vnd.epson.quickanime' => 'qam',
        'application/vnd.epson.salt' => 'slt',
        'application/vnd.epson.ssf' => 'ssf',
        'application/vnd.eszigno3+xml' => 'es3',
        'application/vnd.ezpix-album' => 'ez2',
        'application/vnd.ezpix-package' => 'ez3',
        'application/vnd.fdf' => 'fdf',
        'application/vnd.fdsn.mseed' => 'mseed',
        'application/vnd.fdsn.seed' => 'seed',
        'application/vnd.flographit' => 'gph',
        'application/vnd.fluxtime.clip' => 'ftc',
        'application/vnd.framemaker' => 'fm',
        'application/vnd.frogans.fnc' => 'fnc',
        'application/vnd.frogans.ltf' => 'ltf',
        'application/vnd.fsc.weblaunch' => 'fsc',
        'application/vnd.fujitsu.oasys' => 'oas',
        'application/vnd.fujitsu.oasys2' => 'oa2',
        'application/vnd.fujitsu.oasys3' => 'oa3',
        'application/vnd.fujitsu.oasysgp' => 'fg5',
        'application/vnd.fujitsu.oasysprs' => 'bh2',
        'application/vnd.fujixerox.ddd' => 'ddd',
        'application/vnd.fujixerox.docuworks' => 'xdw',
        'application/vnd.fujixerox.docuworks.binder' => 'xbd',
        'application/vnd.fuzzysheet' => 'fzs',
        'application/vnd.genomatix.tuxedo' => 'txd',
        'application/vnd.geogebra.file' => 'ggb',
        'application/vnd.geogebra.tool' => 'ggt',
        'application/vnd.geometry-explorer' => 'gex',
        'application/vnd.geonext' => 'gxt',
        'application/vnd.geoplan' => 'g2w',
        'application/vnd.geospace' => 'g3w',
        'application/vnd.gmx' => 'gmx',
        'application/vnd.google-earth.kml+xml' => 'kml',
        'application/vnd.google-earth.kmz' => 'kmz',
        'application/vnd.grafeq' => 'gqf',
        'application/vnd.groove-account' => 'gac',
        'application/vnd.groove-help' => 'ghf',
        'application/vnd.groove-identity-message' => 'gim',
        'application/vnd.groove-injector' => 'grv',
        'application/vnd.groove-tool-message' => 'gtm',
        'application/vnd.groove-tool-template' => 'tpl',
        'application/vnd.groove-vcard' => 'vcg',
        'application/vnd.hal+xml' => 'hal',
        'application/vnd.handheld-entertainment+xml' => 'zmm',
        'application/vnd.hbci' => 'hbci',
        'application/vnd.hhe.lesson-player' => 'les',
        'application/vnd.hp-hpgl' => 'hpgl',
        'application/vnd.hp-hpid' => 'hpid',
        'application/vnd.hp-hps' => 'hps',
        'application/vnd.hp-jlyt' => 'jlt',
        'application/vnd.hp-pcl' => 'pcl',
        'application/vnd.hp-pclxl' => 'pclxl',
        'application/vnd.hydrostatix.sof-data' => 'sfd-hdstx',
        'application/vnd.ibm.minipay' => 'mpy',
        'application/vnd.ibm.modcap' => 'afp',
        'application/vnd.ibm.rights-management' => 'irm',
        'application/vnd.ibm.secure-container' => 'sc',
        'application/vnd.iccprofile' => 'icc',
        'application/vnd.igloader' => 'igl',
        'application/vnd.immervision-ivp' => 'ivp',
        'application/vnd.immervision-ivu' => 'ivu',
        'application/vnd.insors.igm' => 'igm',
        'application/vnd.intercon.formnet' => 'xpw',
        'application/vnd.intergeo' => 'i2g',
        'application/vnd.intu.qbo' => 'qbo',
        'application/vnd.intu.qfx' => 'qfx',
        'application/vnd.ipunplugged.rcprofile' => 'rcprofile',
        'application/vnd.irepository.package+xml' => 'irp',
        'application/vnd.is-xpr' => 'xpr',
        'application/vnd.isac.fcs' => 'fcs',
        'application/vnd.jam' => 'jam',
        'application/vnd.jcp.javame.midlet-rms' => 'rms',
        'application/vnd.jisp' => 'jisp',
        'application/vnd.joost.joda-archive' => 'joda',
        'application/vnd.kahootz' => 'ktz',
        'application/vnd.kde.karbon' => 'karbon',
        'application/vnd.kde.kchart' => 'chrt',
        'application/vnd.kde.kformula' => 'kfo',
        'application/vnd.kde.kivio' => 'flw',
        'application/vnd.kde.kontour' => 'kon',
        'application/vnd.kde.kpresenter' => 'kpr',
        'application/vnd.kde.kspread' => 'ksp',
        'application/vnd.kde.kword' => 'kwd',
        'application/vnd.kenameaapp' => 'htke',
        'application/vnd.kidspiration' => 'kia',
        'application/vnd.kinar' => 'kne',
        'application/vnd.koan' => 'skp',
        'application/vnd.kodak-descriptor' => 'sse',
        'application/vnd.las.las+xml' => 'lasxml',
        'application/vnd.llamagraphics.life-balance.desktop' => 'lbd',
        'application/vnd.llamagraphics.life-balance.exchange+xml' => 'lbe',
        'application/vnd.lotus-1-2-3' => '123',
        'application/vnd.lotus-approach' => 'apr',
        'application/vnd.lotus-freelance' => 'pre',
        'application/vnd.lotus-notes' => 'nsf',
        'application/vnd.lotus-organizer' => 'org',
        'application/vnd.lotus-screencam' => 'scm',
        'application/vnd.lotus-wordpro' => 'lwp',
        'application/vnd.macports.portpkg' => 'portpkg',
        'application/vnd.mcd' => 'mcd',
        'application/vnd.medcalcdata' => 'mc1',
        'application/vnd.mediastation.cdkey' => 'cdkey',
        'application/vnd.mfer' => 'mwf',
        'application/vnd.mfmp' => 'mfm',
        'application/vnd.micrografx.flo' => 'flo',
        'application/vnd.micrografx.igx' => 'igx',
        'application/vnd.mif' => 'mif',
        'application/vnd.mobius.daf' => 'daf',
        'application/vnd.mobius.dis' => 'dis',
        'application/vnd.mobius.mbk' => 'mbk',
        'application/vnd.mobius.mqy' => 'mqy',
        'application/vnd.mobius.msl' => 'msl',
        'application/vnd.mobius.plc' => 'plc',
        'application/vnd.mobius.txf' => 'txf',
        'application/vnd.mophun.application' => 'mpn',
        'application/vnd.mophun.certificate' => 'mpc',
        'application/vnd.mozilla.xul+xml' => 'xul',
        'application/vnd.ms-artgalry' => 'cil',
        'application/vnd.ms-cab-compressed' => 'cab',
        'application/vnd.ms-excel' => 'xls',
        'application/vnd.ms-excel.addin.macroenabled.12' => 'xlam',
        'application/vnd.ms-excel.sheet.binary.macroenabled.12' => 'xlsb',
        'application/vnd.ms-excel.sheet.macroenabled.12' => 'xlsm',
        'application/vnd.ms-excel.template.macroenabled.12' => 'xltm',
        'application/vnd.ms-fontobject' => 'eot',
        'application/vnd.ms-htmlhelp' => 'chm',
        'application/vnd.ms-ims' => 'ims',
        'application/vnd.ms-lrm' => 'lrm',
        'application/vnd.ms-officetheme' => 'thmx',
        'application/vnd.ms-pki.seccat' => 'cat',
        'application/vnd.ms-pki.stl' => 'stl',
        'application/vnd.ms-powerpoint' => 'ppt',
        'application/vnd.ms-powerpoint.addin.macroenabled.12' => 'ppam',
        'application/vnd.ms-powerpoint.presentation.macroenabled.12' => 'pptm',
        'application/vnd.ms-powerpoint.slide.macroenabled.12' => 'sldm',
        'application/vnd.ms-powerpoint.slideshow.macroenabled.12' => 'ppsm',
        'application/vnd.ms-powerpoint.template.macroenabled.12' => 'potm',
        'application/vnd.ms-project' => 'mpp',
        'application/vnd.ms-word.document.macroenabled.12' => 'docm',
        'application/vnd.ms-word.template.macroenabled.12' => 'dotm',
        'application/vnd.ms-works' => 'wps',
        'application/vnd.ms-wpl' => 'wpl',
        'application/vnd.ms-xpsdocument' => 'xps',
        'application/vnd.mseq' => 'mseq',
        'application/vnd.musician' => 'mus',
        'application/vnd.muvee.style' => 'msty',
        'application/vnd.mynfc' => 'taglet',
        'application/vnd.neurolanguage.nlu' => 'nlu',
        'application/vnd.nitf' => 'ntf',
        'application/vnd.noblenet-directory' => 'nnd',
        'application/vnd.noblenet-sealer' => 'nns',
        'application/vnd.noblenet-web' => 'nnw',
        'application/vnd.nokia.n-gage.data' => 'ngdat',
        'application/vnd.nokia.n-gage.symbian.install' => 'n-gage',
        'application/vnd.nokia.radio-preset' => 'rpst',
        'application/vnd.nokia.radio-presets' => 'rpss',
        'application/vnd.novadigm.edm' => 'edm',
        'application/vnd.novadigm.edx' => 'edx',
        'application/vnd.novadigm.ext' => 'ext',
        'application/vnd.oasis.opendocument.chart' => 'odc',
        'application/vnd.oasis.opendocument.chart-template' => 'otc',
        'application/vnd.oasis.opendocument.database' => 'odb',
        'application/vnd.oasis.opendocument.formula' => 'odf',
        'application/vnd.oasis.opendocument.formula-template' => 'odft',
        'application/vnd.oasis.opendocument.graphics' => 'odg',
        'application/vnd.oasis.opendocument.graphics-template' => 'otg',
        'application/vnd.oasis.opendocument.image' => 'odi',
        'application/vnd.oasis.opendocument.image-template' => 'oti',
        'application/vnd.oasis.opendocument.presentation' => 'odp',
        'application/vnd.oasis.opendocument.presentation-template' => 'otp',
        'application/vnd.oasis.opendocument.spreadsheet' => 'ods',
        'application/vnd.oasis.opendocument.spreadsheet-template' => 'ots',
        'application/vnd.oasis.opendocument.text' => 'odt',
        'application/vnd.oasis.opendocument.text-master' => 'odm',
        'application/vnd.oasis.opendocument.text-template' => 'ott',
        'application/vnd.oasis.opendocument.text-web' => 'oth',
        'application/vnd.olpc-sugar' => 'xo',
        'application/vnd.oma.dd2+xml' => 'dd2',
        'application/vnd.openofficeorg.extension' => 'oxt',
        'application/vnd.openxmlformats-officedocument.presentationml.presentation' => 'pptx',
        'application/vnd.openxmlformats-officedocument.presentationml.slide' => 'sldx',
        'application/vnd.openxmlformats-officedocument.presentationml.slideshow' => 'ppsx',
        'application/vnd.openxmlformats-officedocument.presentationml.template' => 'potx',
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' => 'xlsx',
        'application/vnd.openxmlformats-officedocument.spreadsheetml.template' => 'xltx',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document' => 'docx',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.template' => 'dotx',
        'application/vnd.osgeo.mapguide.package' => 'mgp',
        'application/vnd.osgi.dp' => 'dp',
        'application/vnd.osgi.subsystem' => 'esa',
        'application/vnd.palm' => 'pdb',
        'application/vnd.pawaafile' => 'paw',
        'application/vnd.pg.format' => 'str',
        'application/vnd.pg.osasli' => 'ei6',
        'application/vnd.picsel' => 'efif',
        'application/vnd.pmi.widget' => 'wg',
        'application/vnd.pocketlearn' => 'plf',
        'application/vnd.powerbuilder6' => 'pbd',
        'application/vnd.previewsystems.box' => 'box',
        'application/vnd.proteus.magazine' => 'mgz',
        'application/vnd.publishare-delta-tree' => 'qps',
        'application/vnd.pvi.ptid1' => 'ptid',
        'application/vnd.quark.quarkxpress' => 'qxd',
        'application/vnd.realvnc.bed' => 'bed',
        'application/vnd.recordare.musicxml' => 'mxl',
        'application/vnd.recordare.musicxml+xml' => 'musicxml',
        'application/vnd.rig.cryptonote' => 'cryptonote',
        'application/vnd.rim.cod' => 'cod',
        'application/vnd.rn-realmedia' => 'rm',
        'application/vnd.rn-realmedia-vbr' => 'rmvb',
        'application/vnd.route66.link66+xml' => 'link66',
        'application/vnd.sailingtracker.track' => 'st',
        'application/vnd.seemail' => 'see',
        'application/vnd.sema' => 'sema',
        'application/vnd.semd' => 'semd',
        'application/vnd.semf' => 'semf',
        'application/vnd.shana.informed.formdata' => 'ifm',
        'application/vnd.shana.informed.formtemplate' => 'itp',
        'application/vnd.shana.informed.interchange' => 'iif',
        'application/vnd.shana.informed.package' => 'ipk',
        'application/vnd.simtech-mindmapper' => 'twd',
        'application/vnd.smaf' => 'mmf',
        'application/vnd.smart.teacher' => 'teacher',
        'application/vnd.solent.sdkm+xml' => 'sdkm',
        'application/vnd.spotfire.dxp' => 'dxp',
        'application/vnd.spotfire.sfs' => 'sfs',
        'application/vnd.stardivision.calc' => 'sdc',
        'application/vnd.stardivision.draw' => 'sda',
        'application/vnd.stardivision.impress' => 'sdd',
        'application/vnd.stardivision.math' => 'smf',
        'application/vnd.stardivision.writer' => 'sdw',
        'application/vnd.stardivision.writer-global' => 'sgl',
        'application/vnd.stepmania.package' => 'smzip',
        'application/vnd.stepmania.stepchart' => 'sm',
        'application/vnd.sun.xml.calc' => 'sxc',
        'application/vnd.sun.xml.calc.template' => 'stc',
        'application/vnd.sun.xml.draw' => 'sxd',
        'application/vnd.sun.xml.draw.template' => 'std',
        'application/vnd.sun.xml.impress' => 'sxi',
        'application/vnd.sun.xml.impress.template' => 'sti',
        'application/vnd.sun.xml.math' => 'sxm',
        'application/vnd.sun.xml.writer' => 'sxw',
        'application/vnd.sun.xml.writer.global' => 'sxg',
        'application/vnd.sun.xml.writer.template' => 'stw',
        'application/vnd.sus-calendar' => 'sus',
        'application/vnd.svd' => 'svd',
        'application/vnd.symbian.install' => 'sis',
        'application/vnd.syncml+xml' => 'xsm',
        'application/vnd.syncml.dm+wbxml' => 'bdm',
        'application/vnd.syncml.dm+xml' => 'xdm',
        'application/vnd.tao.intent-module-archive' => 'tao',
        'application/vnd.tcpdump.pcap' => 'pcap',
        'application/vnd.tmobile-livetv' => 'tmo',
        'application/vnd.trid.tpt' => 'tpt',
        'application/vnd.triscape.mxs' => 'mxs',
        'application/vnd.trueapp' => 'tra',
        'application/vnd.ufdl' => 'ufd',
        'application/vnd.uiq.theme' => 'utz',
        'application/vnd.umajin' => 'umj',
        'application/vnd.unity' => 'unityweb',
        'application/vnd.uoml+xml' => 'uoml',
        'application/vnd.vcx' => 'vcx',
        'application/vnd.visio' => 'vsd',
        'application/vnd.visionary' => 'vis',
        'application/vnd.vsf' => 'vsf',
        'application/vnd.wap.wbxml' => 'wbxml',
        'application/vnd.wap.wmlc' => 'wmlc',
        'application/vnd.wap.wmlscriptc' => 'wmlsc',
        'application/vnd.webturbo' => 'wtb',
        'application/vnd.wolfram.player' => 'nbp',
        'application/vnd.wordperfect' => 'wpd',
        'application/vnd.wqd' => 'wqd',
        'application/vnd.wt.stf' => 'stf',
        'application/vnd.xara' => 'xar',
        'application/vnd.xfdl' => 'xfdl',
        'application/vnd.yamaha.hv-dic' => 'hvd',
        'application/vnd.yamaha.hv-script' => 'hvs',
        'application/vnd.yamaha.hv-voice' => 'hvp',
        'application/vnd.yamaha.openscoreformat' => 'osf',
        'application/vnd.yamaha.openscoreformat.osfpvg+xml' => 'osfpvg',
        'application/vnd.yamaha.smaf-audio' => 'saf',
        'application/vnd.yamaha.smaf-phrase' => 'spf',
        'application/vnd.yellowriver-custom-menu' => 'cmp',
        'application/vnd.zul' => 'zir',
        'application/vnd.zzazz.deck+xml' => 'zaz',
        'application/voicexml+xml' => 'vxml',
        'application/widget' => 'wgt',
        'application/winhlp' => 'hlp',
        'application/wsdl+xml' => 'wsdl',
        'application/wspolicy+xml' => 'wspolicy',
        'application/x-7z-compressed' => '7z',
        'application/x-abiword' => 'abw',
        'application/x-ace-compressed' => 'ace',
        'application/x-apple-diskimage' => 'dmg',
        'application/x-authorware-bin' => 'aab',
        'application/x-authorware-map' => 'aam',
        'application/x-authorware-seg' => 'aas',
        'application/x-bcpio' => 'bcpio',
        'application/x-bittorrent' => 'torrent',
        'application/x-blorb' => 'blb',
        'application/x-bzip' => 'bz',
        'application/x-bzip2' => 'bz2',
        'application/x-cbr' => 'cbr',
        'application/x-cdlink' => 'vcd',
        'application/x-cfs-compressed' => 'cfs',
        'application/x-chat' => 'chat',
        'application/x-chess-pgn' => 'pgn',
        'application/x-conference' => 'nsc',
        'application/x-cpio' => 'cpio',
        'application/x-csh' => 'csh',
        'application/x-debian-package' => 'deb',
        'application/x-dgc-compressed' => 'dgc',
        'application/x-director' => 'dir',
        'application/x-doom' => 'wad',
        'application/x-dtbncx+xml' => 'ncx',
        'application/x-dtbook+xml' => 'dtb',
        'application/x-dtbresource+xml' => 'res',
        'application/x-dvi' => 'dvi',
        'application/x-envoy' => 'evy',
        'application/x-eva' => 'eva',
        'application/x-font-bdf' => 'bdf',
        'application/x-font-ghostscript' => 'gsf',
        'application/x-font-linux-psf' => 'psf',
        'application/x-font-otf' => 'otf',
        'application/x-font-pcf' => 'pcf',
        'application/x-font-snf' => 'snf',
        'application/x-font-ttf' => 'ttf',
        'application/x-font-type1' => 'pfa',
        'application/x-font-woff' => 'woff',
        'application/x-freearc' => 'arc',
        'application/x-futuresplash' => 'spl',
        'application/x-gca-compressed' => 'gca',
        'application/x-glulx' => 'ulx',
        'application/x-gnumeric' => 'gnumeric',
        'application/x-gramps-xml' => 'gramps',
        'application/x-gtar' => 'gtar',
        'application/x-hdf' => 'hdf',
        'application/x-install-instructions' => 'install',
        'application/x-iso9660-image' => 'iso',
        'application/x-java-jnlp-file' => 'jnlp',
        'application/x-latex' => 'latex',
        'application/x-lzh-compressed' => 'lzh',
        'application/x-mie' => 'mie',
        'application/x-mobipocket-ebook' => 'prc',
        'application/x-ms-application' => 'application',
        'application/x-ms-shortcut' => 'lnk',
        'application/x-ms-wmd' => 'wmd',
        'application/x-ms-wmz' => 'wmz',
        'application/x-ms-xbap' => 'xbap',
        'application/x-msaccess' => 'mdb',
        'application/x-msbinder' => 'obd',
        'application/x-mscardfile' => 'crd',
        'application/x-msclip' => 'clp',
        'application/x-msdownload' => 'exe',
        'application/x-msmediaview' => 'mvb',
        'application/x-msmetafile' => 'wmf',
        'application/x-msmoney' => 'mny',
        'application/x-mspublisher' => 'pub',
        'application/x-msschedule' => 'scd',
        'application/x-msterminal' => 'trm',
        'application/x-mswrite' => 'wri',
        'application/x-netcdf' => 'nc',
        'application/x-nzb' => 'nzb',
        'application/x-pkcs12' => 'p12',
        'application/x-pkcs7-certificates' => 'p7b',
        'application/x-pkcs7-certreqresp' => 'p7r',
        'application/x-rar-compressed' => 'rar',
        'application/x-rar' => 'rar',
        'application/x-research-info-systems' => 'ris',
        'application/x-sh' => 'sh',
        'application/x-shar' => 'shar',
        'application/x-shockwave-flash' => 'swf',
        'application/x-silverlight-app' => 'xap',
        'application/x-sql' => 'sql',
        'application/x-stuffit' => 'sit',
        'application/x-stuffitx' => 'sitx',
        'application/x-subrip' => 'srt',
        'application/x-sv4cpio' => 'sv4cpio',
        'application/x-sv4crc' => 'sv4crc',
        'application/x-t3vm-image' => 't3',
        'application/x-tads' => 'gam',
        'application/x-tar' => 'tar',
        'application/x-tcl' => 'tcl',
        'application/x-tex' => 'tex',
        'application/x-tex-tfm' => 'tfm',
        'application/x-texinfo' => 'texinfo',
        'application/x-tgif' => 'obj',
        'application/x-ustar' => 'ustar',
        'application/x-wais-source' => 'src',
        'application/x-x509-ca-cert' => 'der',
        'application/x-xfig' => 'fig',
        'application/x-xliff+xml' => 'xlf',
        'application/x-xpinstall' => 'xpi',
        'application/x-xz' => 'xz',
        'application/x-zmachine' => 'z1',
        'application/xaml+xml' => 'xaml',
        'application/xcap-diff+xml' => 'xdf',
        'application/xenc+xml' => 'xenc',
        'application/xhtml+xml' => 'xhtml',
        'application/xml' => 'xml',
        'application/xml-dtd' => 'dtd',
        'application/xop+xml' => 'xop',
        'application/xproc+xml' => 'xpl',
        'application/xslt+xml' => 'xslt',
        'application/xspf+xml' => 'xspf',
        'application/xv+xml' => 'mxml',
        'application/yang' => 'yang',
        'application/yin+xml' => 'yin',
        'application/zip' => 'zip',
        'audio/adpcm' => 'adp',
        'audio/basic' => 'au',
        'audio/midi' => 'mid',
        'audio/mp4' => 'mp4a',
        'audio/mpeg' => 'mpga',
        'audio/ogg' => 'oga',
        'audio/s3m' => 's3m',
        'audio/silk' => 'sil',
        'audio/vnd.dece.audio' => 'uva',
        'audio/vnd.digital-winds' => 'eol',
        'audio/vnd.dra' => 'dra',
        'audio/vnd.dts' => 'dts',
        'audio/vnd.dts.hd' => 'dtshd',
        'audio/vnd.lucent.voice' => 'lvp',
        'audio/vnd.ms-playready.media.pya' => 'pya',
        'audio/vnd.nuera.ecelp4800' => 'ecelp4800',
        'audio/vnd.nuera.ecelp7470' => 'ecelp7470',
        'audio/vnd.nuera.ecelp9600' => 'ecelp9600',
        'audio/vnd.rip' => 'rip',
        'audio/webm' => 'weba',
        'audio/x-aac' => 'aac',
        'audio/x-aiff' => 'aif',
        'audio/x-caf' => 'caf',
        'audio/x-flac' => 'flac',
        'audio/x-matroska' => 'mka',
        'audio/x-mpegurl' => 'm3u',
        'audio/x-ms-wax' => 'wax',
        'audio/x-ms-wma' => 'wma',
        'audio/x-pn-realaudio' => 'ram',
        'audio/x-pn-realaudio-plugin' => 'rmp',
        'audio/x-wav' => 'wav',
        'audio/xm' => 'xm',
        'chemical/x-cdx' => 'cdx',
        'chemical/x-cif' => 'cif',
        'chemical/x-cmdf' => 'cmdf',
        'chemical/x-cml' => 'cml',
        'chemical/x-csml' => 'csml',
        'chemical/x-xyz' => 'xyz',
        'image/bmp' => 'bmp',
        'image/x-ms-bmp' => 'bmp',
        'image/cgm' => 'cgm',
        'image/g3fax' => 'g3',
        'image/gif' => 'gif',
        'image/ief' => 'ief',
        'image/jpeg' => 'jpeg',
        'image/ktx' => 'ktx',
        'image/png' => 'png',
        'image/prs.btif' => 'btif',
        'image/sgi' => 'sgi',
        'image/svg+xml' => 'svg',
        'image/tiff' => 'tiff',
        'image/vnd.adobe.photoshop' => 'psd',
        'image/vnd.dece.graphic' => 'uvi',
        'image/vnd.dvb.subtitle' => 'sub',
        'image/vnd.djvu' => 'djvu',
        'image/vnd.dwg' => 'dwg',
        'image/vnd.dxf' => 'dxf',
        'image/vnd.fastbidsheet' => 'fbs',
        'image/vnd.fpx' => 'fpx',
        'image/vnd.fst' => 'fst',
        'image/vnd.fujixerox.edmics-mmr' => 'mmr',
        'image/vnd.fujixerox.edmics-rlc' => 'rlc',
        'image/vnd.ms-modi' => 'mdi',
        'image/vnd.ms-photo' => 'wdp',
        'image/vnd.net-fpx' => 'npx',
        'image/vnd.wap.wbmp' => 'wbmp',
        'image/vnd.xiff' => 'xif',
        'image/webp' => 'webp',
        'image/x-3ds' => '3ds',
        'image/x-cmu-raster' => 'ras',
        'image/x-cmx' => 'cmx',
        'image/x-freehand' => 'fh',
        'image/x-icon' => 'ico',
        'image/x-mrsid-image' => 'sid',
        'image/x-pcx' => 'pcx',
        'image/x-pict' => 'pic',
        'image/x-portable-anymap' => 'pnm',
        'image/x-portable-bitmap' => 'pbm',
        'image/x-portable-graymap' => 'pgm',
        'image/x-portable-pixmap' => 'ppm',
        'image/x-rgb' => 'rgb',
        'image/x-tga' => 'tga',
        'image/x-xbitmap' => 'xbm',
        'image/x-xpixmap' => 'xpm',
        'image/x-xwindowdump' => 'xwd',
        'message/rfc822' => 'eml',
        'model/iges' => 'igs',
        'model/mesh' => 'msh',
        'model/vnd.collada+xml' => 'dae',
        'model/vnd.dwf' => 'dwf',
        'model/vnd.gdl' => 'gdl',
        'model/vnd.gtw' => 'gtw',
        'model/vnd.mts' => 'mts',
        'model/vnd.vtu' => 'vtu',
        'model/vrml' => 'wrl',
        'model/x3d+binary' => 'x3db',
        'model/x3d+vrml' => 'x3dv',
        'model/x3d+xml' => 'x3d',
        'text/cache-manifest' => 'appcache',
        'text/calendar' => 'ics',
        'text/css' => 'css',
        'text/csv' => 'csv',
        'text/html' => 'html',
        'text/n3' => 'n3',
        'text/plain' => 'txt',
        'text/prs.lines.tag' => 'dsc',
        'text/richtext' => 'rtx',
        'text/sgml' => 'sgml',
        'text/tab-separated-values' => 'tsv',
        'text/troff' => 't',
        'text/turtle' => 'ttl',
        'text/uri-list' => 'uri',
        'text/vcard' => 'vcard',
        'text/vnd.curl' => 'curl',
        'text/vnd.curl.dcurl' => 'dcurl',
        'text/vnd.curl.scurl' => 'scurl',
        'text/vnd.curl.mcurl' => 'mcurl',
        'text/vnd.dvb.subtitle' => 'sub',
        'text/vnd.fly' => 'fly',
        'text/vnd.fmi.flexstor' => 'flx',
        'text/vnd.graphviz' => 'gv',
        'text/vnd.in3d.3dml' => '3dml',
        'text/vnd.in3d.spot' => 'spot',
        'text/vnd.sun.j2me.app-descriptor' => 'jad',
        'text/vnd.wap.wml' => 'wml',
        'text/vnd.wap.wmlscript' => 'wmls',
        'text/x-asm' => 's',
        'text/x-c' => 'c',
        'text/x-fortran' => 'f',
        'text/x-pascal' => 'p',
        'text/x-java-source' => 'java',
        'text/x-opml' => 'opml',
        'text/x-nfo' => 'nfo',
        'text/x-setext' => 'etx',
        'text/x-sfv' => 'sfv',
        'text/x-uuencode' => 'uu',
        'text/x-vcalendar' => 'vcs',
        'text/x-vcard' => 'vcf',
        'video/3gpp' => '3gp',
        'video/3gpp2' => '3g2',
        'video/h261' => 'h261',
        'video/h263' => 'h263',
        'video/h264' => 'h264',
        'video/jpeg' => 'jpgv',
        'video/jpm' => 'jpm',
        'video/mj2' => 'mj2',
        'video/mp4' => 'mp4',
        'video/mpeg' => 'mpeg',
        'video/ogg' => 'ogv',
        'video/quicktime' => 'qt',
        'video/vnd.dece.hd' => 'uvh',
        'video/vnd.dece.mobile' => 'uvm',
        'video/vnd.dece.pd' => 'uvp',
        'video/vnd.dece.sd' => 'uvs',
        'video/vnd.dece.video' => 'uvv',
        'video/vnd.dvb.file' => 'dvb',
        'video/vnd.fvt' => 'fvt',
        'video/vnd.mpegurl' => 'mxu',
        'video/vnd.ms-playready.media.pyv' => 'pyv',
        'video/vnd.uvvu.mp4' => 'uvu',
        'video/vnd.vivo' => 'viv',
        'video/webm' => 'webm',
        'video/x-f4v' => 'f4v',
        'video/x-fli' => 'fli',
        'video/x-flv' => 'flv',
        'video/x-m4v' => 'm4v',
        'video/x-matroska' => 'mkv',
        'video/x-mng' => 'mng',
        'video/x-ms-asf' => 'asf',
        'video/x-ms-vob' => 'vob',
        'video/x-ms-wm' => 'wm',
        'video/x-ms-wmv' => 'wmv',
        'video/x-ms-wmx' => 'wmx',
        'video/x-ms-wvx' => 'wvx',
        'video/x-msvideo' => 'avi',
        'video/x-sgi-movie' => 'movie',
        'video/x-smv' => 'smv',
        'x-conference/x-cooltalk' => 'ice',
    );
    
    public function guess($mimeType)
    {
        return isset($this->defaultExtensions[$mimeType]) ? $this->defaultExtensions[$mimeType] : null;
    }
}
}
namespace phpex\Foundation\File\MimeType{
use phpex\Foundation\File\Exception\FileNotFoundException;
use phpex\Foundation\File\Exception\AccessDeniedException;
class MimeTypeGuesser implements MimeTypeGuesserInterface
{
    
    private static $instance = null;
    
    protected $guessers = array();
    
    public static function getInstance()
    {
        if (null === self::$instance) {
            self::$instance = new self();
        }
        return self::$instance;
    }
    
    private function __construct()
    {
        if (FileBinaryMimeTypeGuesser::isSupported()) {
            $this->register(new FileBinaryMimeTypeGuesser());
        }
        if (FileinfoMimeTypeGuesser::isSupported()) {
            $this->register(new FileinfoMimeTypeGuesser());
        }
    }
    
    public function register(MimeTypeGuesserInterface $guesser)
    {
        array_unshift($this->guessers, $guesser);
    }
    
    public function guess($path)
    {
        if (!is_file($path)) {
            throw new FileNotFoundException($path);
        }
        if (!is_readable($path)) {
            throw new AccessDeniedException($path);
        }
        if (!$this->guessers) {
            throw new \LogicException('Unable to guess the mime type as no guessers are available (Did you enable the php_fileinfo extension?)');
        }
        foreach ($this->guessers as $guesser) {
            if (null !== $mimeType = $guesser->guess($path)) {
                return $mimeType;
            }
        }
    }
}
}
namespace phpex\Helper\Search{
interface ElementInterface {
    public function __construct($field, $label);
    public function bindSearch(Search $search);
    public function getName();
    public function getExpr();
    public function setHtmlAttr(array $attrs = array());
    public function setParameters(array &$arameters);
    public function getHtml();
    public function getValue();
}
}
namespace phpex\Helper\Search{
use phpex\Helper\Search\RichElement\BaseElement;
use phpex\Helper\Search\RichElement\Choice;
use phpex\Helper\Search\RichElement\Coin;
use phpex\Helper\Search\RichElement\Date;
use phpex\Helper\Search\RichElement\DateTime;
use phpex\Helper\Search\RichElement\Multi;
use phpex\Helper\Search\RichElement\Time;
use phpex\DModel\DModel;
use phpex\Library\Controller;
class RichSearch {
    
    private $fields = array();
    private $data = array();
    private $controller;
    private $header = "";
    private $footer = "";
    private $autoButton = true;
    private $prefix = "";
    public function __construct(Controller $controller, $prefix = "") {
        $this->controller = $controller;
        $this->prefix = $prefix;
    }
    public function addCoin($key, $label) {
        return $this->fields[$key] = new Coin($key, $label, $this->prefix);
    }
    public function addChoice($key, $label) {
        return $this->fields[$key] = new Choice($key, $label, $this->prefix);
    }
    public function addMulti($key, $label) {
        return $this->fields[$key] = new Multi($key, $label, $this->prefix);
    }
    public function addDate($key, $label) {
        return $this->fields[$key] = new Date($key, $label, $this->prefix);
    }
    public function addTime($key, $label) {
        return $this->fields[$key] = new Time($key, $label, $this->prefix);
    }
    public function addDateTime($key, $label) {
        return $this->fields[$key] = new DateTime($key, $label, $this->prefix);
    }
    public function setData($data) {
        $this->data = $data;
        return $this;
    }
    public function bindData($data) {
        return $this->setData($data);
    }
    private function queryData() {
        if (!isset($_SERVER['QUERY_STRING'])) return array();
        parse_str($_SERVER['QUERY_STRING'], $data);
        return $data;
    }
    public function build(&$where = "", &$searchForm = "", &$parameters = array()) {
        if (!$this->data) {
            $this->data = $this->queryData();
        }
        foreach ($this->fields as $field) {
            $field->setData($this->data);
            $filesWhere = $field->where();
            $where .= $filesWhere ? $filesWhere . ' AND ' : '';
            $searchForm .= $field->form() . "\n";
            $tempParameters = $field->parameter();
            foreach ($tempParameters as $pKey => $pVal) {
                $parameters[$pKey] = $pVal;
            }
        }
        $searchForm = $this->header . '<table class="rich-search">' . $searchForm . $this->submit() . '</table>' . $this->footer;
        $where = substr($where, 0, -5);
        $this->controller->assign($this->prefix . "searchForm", $searchForm);
    }
    private function submit() {
        if ($this->autoButton === true)
            return "";
    }
    public function autoSubmit($submit = true) {
        $this->autoButton = $submit;
        return $this;
    }
    public function setHeader($header) {
        $this->header = $header;
        return $this;
    }
    public function setFooter($footer) {
        $this->footer = $footer;
        return $this;
    }
    public function fetch(DModel $dModel, $scalar = false) {
        $this->build($where, $searchForm, $parameters);
        $dModel->andWhere($where)->setParameter($parameters, null, false);
        return $dModel->getArray($scalar);
    }
    public function getValue($key) {
        if (!isset($this->fields[$key])) return null;
        $this->fields[$key]->setData($this->data);
        return $this->fields[$key]->getValues();
    }
}
}
namespace phpex\Helper\Search{
class Search {
    private $data = array();
    private $fields = array();
    private $options = array();
    private $submited = false;
    private $buttons = array();
    private $label_type = "label";
    private $label_types = array("label", "placeholder");
    public function labelType($label_type) {
        $this->label_type = in_array($label_type, $this->label_types) ? $label_type : "label";
    }
    
    protected $controller;
    public function __construct($controller) {
        $this->controller = $controller;
    }
    public function optoins(array $options = array()) {
        $this->options = array_merge($this->options, $options);
    }
    public function getOptions() {
        return $this->options;
    }
    public function clear() {
        $this->data = array();
        $this->fields = array();
        $this->options = array();
        $this->submited = false;
    }
    public function addSubmit($label = "搜索") {
        if (!$this->submited) {
            $this->submited = true;
            $this->buttons[] = array("type" => "submit", "label" => $label);
        }
    }
    public function addExport($field = "excel", $label = "导出到excel") {
        $this->buttons[] = array("type" => "export", "name" => "__export__" . $field, "label" => $label);
    }
    public function addKeyword($field, $label = "关键词", $like = true) {
        $input_name = str_replace(array(",", "."), array("_", ""), $field);
        $this->fields[] = array("name" => $input_name, "type" => "key", "fields" => explode(",", $field), "label" => $label, 'like' => $like);
    }
    public function addChoiceKeyword($fields, $choiceName = "choice_keyword", $like = true) {
        $input_name = str_replace(array(",", "."), array("_", ""), $choiceName);
        $this->fields[] = array("name" => $input_name, "type" => "choiceKeyword", "fields" => $fields, 'like' => $like);
    }
    public function addDateRange($field, $label = "日期") {
        $input_name = str_replace(array(",", "."), array("_", ""), $field);
        $this->fields[] = array("name" => $input_name, "type" => "daterange", "field" => $field, "label" => $label);
        return $this;
    }
    public function addTimeRange($field, $label = "时间") {
        $input_name = str_replace(array(",", "."), array("_", ""), $field);
        $this->fields[] = array("name" => $input_name, "type" => "timerange", "field" => $field, "label" => $label);
    }
    public function addSelect($field, $label = "类型", array $options = array(), $empty = false, $default = false, $isnull = false) {
        $input_name = str_replace(array(",", "."), array("_", ""), $field);
        $this->fields[] = array("name" => $input_name, "type" => "select", "field" => $field, "label" => $label, "options" => $options, "empty" => $empty, "default" => $default, "isnull" => $isnull);
    }
    public function addSelectTree($field, $label = "树类型", array $options = array(), $empty = false, $default = false, $isnull = false) {
        $input_name = str_replace(array(",", "."), array("_", ""), $field);
        $this->fields[] = array("name" => $input_name, "type" => "select_tree", "field" => $field, "label" => $label, "options" => $options, "empty" => $empty, "default" => $default, "isnull" => $isnull);
    }
    public function addSelectOptions($field, $label = "类型", $options = "", $default = false) {
        $input_name = str_replace(array(",", "."), array("_", ""), $field);
        $this->fields[] = array("name" => $input_name, "type" => "select_options", "field" => $field, "label" => $label, "options" => $options, "default" => $default);
    }
    public function bindData(array $data) {
        $this->data = $data;
    }
    
    public function build(&$where = "", &$searchForm = "", &$parameters = array()) {
        $where = $where ? $where . " AND " : "";
        $this->addSubmit();
        foreach ($this->fields as $field) {
            switch ($field["type"]) {
                case "key":
                    $value = $this->likeValue($field["name"], $data);
                    if (isset($this->data[$field["name"] . "_eq"])) {
                        $value = $data;
                    }
                    if ($value) {
                        $where .= "( ";
                        $join = "";
                        $join_str = isset($this->data[$field["name"] . "_eq"]) && $field["like"] == false ? " = " : " LIKE ";
                        foreach ($field["fields"] as $f) {
                            $where .= $join . $f . $join_str . ":" . str_replace(".", "_", $f);
                            $parameters[str_replace(".", "_", $f)] = $value;
                            $join = " OR ";
                        }
                        $where .= " ) AND ";
                    }
                    if ($this->label_type == "label") {
                        $searchForm .= "&nbsp;" . $field["label"] . "：<input class='search-keyword' style=\"width:100px;\" name=\"{$field["name"]}\" type=\"text\" value=\"{$data}\" />";
                    } elseif ($this->label_type == "placeholder") {
                        $searchForm .= "&nbsp;<input class='search-keyword' style=\"width:100px;\" name=\"{$field["name"]}\" type=\"text\" value=\"{$data}\" placeholder=\"{$field["label"]}\" />";
                    }
                    if ($field["like"] == false) {
                        if (isset($this->data[$field["name"] . "_eq"])) {
                            $searchForm .= "&nbsp;<label><input name=\"{$field["name"]}_eq\" type=\"checkbox\" checked value=\"1\" />精准</label>&nbsp;&nbsp;";
                        } else {
                            $searchForm .= "&nbsp;<label><input name=\"{$field["name"]}_eq\" type=\"checkbox\" value=\"1\" />精准</label>&nbsp;&nbsp;";
                        }
                    } else {
                        $searchForm .= "";
                    }
                    break;
                case "daterange":
                case "timerange":
                    $values = $this->betweenDate($field["name"], $start, $end);
                    $params_f = str_replace(".", "_", $field["field"]);
                    if ($field["type"] == 'daterange' && $values) {
                        $vals[0] = $values[0] ? $values[0] . " 00:00:01" : "";
                        $vals[1] = $values[1] ? $values[1] . " 23:59:59" : "";
                    } else {
                        $vals = $values;
                    }
                    if (2 == count($vals)) {
                        $where .= "( " . $field["field"] . " BETWEEN :" . $params_f . "_start AND :" . $params_f . "_end) AND ";
                        $parameters[$params_f . "_start"] = $vals[0];
                        $parameters[$params_f . "_end"] = $vals[1];
                    } elseif (isset($vals[0])) {
                        $where .= "( " . $field["field"] . " >= :" . $params_f . "_start) AND ";
                        $parameters[$params_f . "_start"] = $vals[0];
                        $vals[1] = "";
                    } elseif (isset($vals[1])) {
                        $where .= "( " . $field["field"] . " <= :" . $vals[1] . "_end) AND ";
                        $parameters[$params_f . "_end"] = $vals[0];
                        $vals[0] = "";
                    } else {
                        $vals[0] = $vals[1] = "";
                    }
                    $format = $field["type"] == "daterange" ? "YYYY-MM-DD" : "YYYY-MM-DD hh:mm:ss";
                    if ($this->label_type == "label") {
                        $searchForm .= "&nbsp;" . $field["label"] . "：<input class=\"laydate laydate-icon\""
                            . " date-max=\"{$end}\"  type=\"text\"  style=\"width:130px;\" name=\"{$start}\" id=\"{$start}\" format=\"{$format}\" value=\"{$values[0]}\">";
                        $searchForm .= "&nbsp;-&nbsp;<input style=\"width:130px;\" class=\"laydate laydate-icon\""
                            . " date-min=\"{$start}\" type=\"text\" name=\"{$end}\" id=\"{$end}\" format=\"{$format}\" value=\"{$values[1]}\">";
                    } elseif ($this->label_type == "placeholder") {
                        $searchForm .= "&nbsp;<input class=\"laydate laydate-icon\""
                            . " date-max=\"{$end}\"  type=\"text\"  style=\"width:130px;\" name=\"{$start}\" id=\"{$start}\" format=\"{$format}\" value=\"{$values[0]}\" placeholder=\"开始{$field["label"]}\">";
                        $searchForm .= "&nbsp;-&nbsp;<input style=\"width:130px;\" class=\"laydate laydate-icon\""
                            . " date-min=\"{$start}\" type=\"text\" name=\"{$end}\" id=\"{$end}\" format=\"{$format}\" value=\"{$values[1]}\" placeholder=\"{$field["label"]}\">";
                    }
                    break;
                case "select":
                    $value = $this->selectOptions($field["name"], $field["options"], $field["default"]);
                    if ("" !== $value) {
                        if (false === $field["isnull"] || $field["isnull"] != $value)
                            $where .= "( " . $field["field"] . " = :" . str_replace(".", "_", $field["field"]) . ") AND ";
                        else
                            $where .= "( " . $field["field"] . " = :" . str_replace(".", "_", $field["field"]) . " OR " . $field["field"] . " IS NULL  ) AND ";
                        $parameters[str_replace(".", "_", $field["field"])] = $value;
                    }
                    if ($this->label_type == "label") {
                        $searchForm .= "&nbsp;" . $field["label"] . "：<select style=\"min-width:80px\" name=\"{$field["name"]}\">";
                    } elseif ($this->label_type == "placeholder") {
                        $searchForm .= "&nbsp;<select style=\"min-width:80px\" name=\"{$field["name"]}\" placeholder=\"{$field["label"]}\">";
                    }
                    if ($field["empty"]) {
                        $searchForm .= "<option value=\"\">{$field['empty']}</option>";
                    }
                    foreach ($field["options"] as $key => $option) {
                        $selected = (strval($value) === strval($key)) ? " selected=\"selected\" " : "";
                        $searchForm .= "<option value=\"{$key}\"{$selected}>{$option}</option>";
                    }
                    $searchForm .= "</select>";
                    break;
                case "select_tree":
                    $value = $this->selectTreeOptions($field["name"], $field["options"], $field["default"]);
                    if ("" !== $value[0]) {
                        $typeid = empty($value[1]) ? '=' : "in";
                        if (false === $field["isnull"] || $field["isnull"] != $value[0])
                            $where .= "( " . $field["field"] . " {$typeid} (:" . str_replace(".", "_", $field["field"]) . ")) AND ";
                        else
                            $where .= "( " . $field["field"] . " {$typeid} (:" . str_replace(".", "_", $field["field"]) . ") OR " . $field["field"] . " IS NULL  ) AND ";
                        $parameters[str_replace(".", "_", $field["field"])] = empty($value[1]) ? $value[0] : array_merge(array($value[0]), $value[1]);
                    }
                    if ($this->label_type == "label") {
                        $searchForm .= "&nbsp;" . $field["label"] . "：<select style=\"min-width:80px\" name=\"{$field["name"]}\">";
                    } elseif ($this->label_type == "placeholder") {
                        $searchForm .= "&nbsp;<select style=\"min-width:80px\" name=\"{$field["name"]}\" placeholder=\"{$field["label"]}\">";
                    }
                    if ($field["empty"]) {
                        $searchForm .= "<option value=\"\">{$field['empty']}</option>";
                    }
                    foreach ($field["options"] as $key => $option) {
                        $selected = (strval($value[0]) === strval($key)) ? " selected=\"selected\" " : "";
                        $searchForm .= "<option value=\"{$key}\"{$selected}>{$option[0]}</option>";
                    }
                    $searchForm .= "</select>";
                    break;
                case "select_options":
                    $value = $this->selectOptions($field["name"], $field["options"], $field["default"]);
                    if ("" !== $value) {
                        if (false === $field["isnull"] || $field["isnull"] != $value)
                            $where .= "( " . $field["field"] . " = :" . str_replace(".", "_", $field["field"]) . ") AND ";
                        else
                            $where .= "( " . $field["field"] . " = :" . str_replace(".", "_", $field["field"]) . " OR " . $field["field"] . " IS NULL  ) AND ";
                        $parameters[str_replace(".", "_", $field["field"])] = $value;
                    }
                    if ($this->label_type == "label") {
                        $searchForm .= "&nbsp;" . $field["label"] . "：<select style=\"min-width:80px\" name=\"{$field["name"]}\">";
                    } elseif ($this->label_type == "placeholder") {
                        $searchForm .= "&nbsp;<select style=\"min-width:80px\" name=\"{$field["name"]}\" placeholder=\"{$field["label"]}\">";
                    }
                    $searchForm .= $field["options"];
                    $searchForm .= "</select>";
                    break;
                case "choiceKeyword":
                    $value = $this->likeValue($field["name"] . "_val", $data);
                    if (isset($this->data[$field["name"] . "_eq"])) {
                        $value = $data;
                    }
                    $fieldName = $this->data[$field["name"] . "_name"];
                    $fields = explode(",", $fieldName);
                    if ($value) {
                        $where .= "( ";
                        $join = "";
                        $join_str = isset($this->data[$field["name"] . "_eq"]) && $field["like"] == false ? " = " : " LIKE ";
                        foreach ($fields as $f) {
                            $where .= $join . $f . $join_str . ":" . str_replace(".", "_", $f);
                            $parameters[str_replace(".", "_", $f)] = $value;
                            $join = " OR ";
                        }
                        $where .= " ) AND ";
                    }
                    $searchForm .= "&nbsp;<select style=\"min-width:80px\" name=\"{$field["name"]}_name\">";
                    if ($field["empty"]) {
                        $searchForm .= "<option value=\"\">{$field['empty']}</option>";
                    }
                    foreach ($field["fields"] as $key => $option) {
                        $selected = (strval($fieldName) === strval($key)) ? " selected=\"selected\" " : "";
                        $searchForm .= "<option value=\"{$key}\"{$selected}>{$option}</option>";
                    }
                    $searchForm .= "</select>";
                    $searchForm .= "&nbsp;<input style=\"width:100px;\" name=\"{$field["name"]}_val\" type=\"text\" value=\"{$data}\" />";
                    if ($field["like"] == false) {
                        if (isset($this->data[$field["name"] . "_eq"])) {
                            $searchForm .= "&nbsp;<label><input name=\"{$field["name"]}_eq\" type=\"checkbox\" checked value=\"1\" />精准</label>&nbsp;&nbsp;";
                        } else {
                            $searchForm .= "&nbsp;<label><input name=\"{$field["name"]}_eq\" type=\"checkbox\" value=\"1\" />精准</label>&nbsp;&nbsp;";
                        }
                    } else {
                        $searchForm .= "";
                    }
                    break;
            }
        }
        $buttonstr = "";
        foreach ($this->buttons as $button) {
            switch ($button["type"]) {
                case "submit":
                    $buttonstr = "&nbsp;<input type=\"submit\" class=\"btn min green\" value=\"{$button["label"]}\" />&nbsp;" . $buttonstr;
                    break;
                case "export":
                    $url = $_SERVER['REQUEST_URI'];
                    $p = $button["name"];
                    if (preg_match("/([\?&]$p\=).+/", $url)) {
                        $url = preg_replace("/([\?&]$p\=).+/", '\\1__PAGE__', $url);
                    } elseif (preg_match("/\?/", $url)) {
                        $url .= "&" . http_build_query(array($p => $button["label"]));
                    } else {
                        $url .= "?" . http_build_query(array($p => $button["label"]));
                    }
                    $buttonstr .= "&nbsp;<input type=\"button\" onclick=\"location.href='$url'\" class=\"btn min green\" name=\"{$button["name"]}\" value=\"{$button["label"]}\" />&nbsp;";
                    break;
            }
        }
        $searchForm = $this->header() . $searchForm . $buttonstr . $this->footer();
        $where = substr($where, 0, -5);
        $this->controller->assign("searchForm", $searchForm);
    }
    public function header() {
        $form = "<form ";
        foreach ($this->options as $option => $attr) {
            if ($option == "element" && is_scalar($attr))
                continue;
            $form .= $option . '="' . htmlspecialchars($attr, ENT_QUOTES, 'UTF-8') . '" ';
        }
        return trim($form) . ">";
    }
    public function footer() {
        return "</form>";
    }
    private function likeValue($name, &$data) {
        $data = "";
        if (isset($this->data[$name]) && !empty($this->data[$name])) {
            $data = $this->data[$name];
            return "%" . trim($this->data[$name]) . "%";
        }
        return "";
    }
    private function betweenDate($name, &$start, &$end) {
        $start = $name . "_start";
        $end = $name . "_end";
        $values = array();
        if (isset($this->data[$start]) && !empty($this->data[$start])) {
            $values[0] = trim($this->data[$start]);
        }
        if (isset($this->data[$end]) && !empty($this->data[$end])) {
            $values[1] = trim($this->data[$end]);
        }
        return $values;
    }
    private function selectOptions($name, $options, $default) {
        if (isset($this->data[$name]) && isset($options[$this->data[$name]])) {
            return $this->data[$name];
        }
        return false === $default ? "" : $default;
    }
    private function selectTreeOptions($name, $options, $default) {
        if (isset($this->data[$name]) && isset($options[$this->data[$name]])) {
            $items = $this->findTreeOptions($options, $this->data[$name]);
            return array($this->data[$name], $items);
        }
        return false === $default ? array("", array()) : $this->selectTreeOptions($default, $options, false);
    }
    private function findTreeOptions($options, $id) {
        $items = array();
        foreach ($options as $oid => $row) {
            if ($row[1] == $id) {
                $items[] = $oid;
                $items = array_merge($items, $this->findTreeOptions($options, $oid));
            }
        }
        return $items;
    }
    public function getData($key) {
        $name = str_replace(array(",", "."), array("_", ""), $key);
        foreach ($this->fields as $field) {
            if ($field["name"] != $name)
                continue;
            switch ($field["type"]) {
                case "key":
                    $this->likeValue($name, $data);
                    return $data;
                case "daterange":
                    $this->betweenDate($name, $start, $end);
                    return array($start, $end);
                case "select":
                case "select_options":
                    return $this->selectOptions($name, $field["options"], $field["default"]);
            }
        }
        return null;
    }
}
}
namespace phpex\Helper\Search{
class SelectSearch implements ElementInterface {
    protected $field, $label, $name, $search;
    public function __construct($field, $label, $name = "") {
        $this->field = $field;
        $this->label = $label;
        $this->name = $name ? str_replace(array(",", "."), array("_", ""), $name) : str_replace(array(",", "."), array("_", ""), $field);
    }
    public function getExpr() {
        
    }
    public function getHtml() {
        
    }
    public function getName() {
        return $this->name;
    }
    public function getValue() {
        
    }
    public function setHtmlAttr(array $attrs = array()) {
        
    }
    public function setParameters(array &$arameters) {
        
    }
    public function bindSearch(Search $search) {
        $this->search = $search;
    }
}
}
namespace phpex\Util\Xml{
class XmlParse {
    static function xmlLoad($input) {
        $xmlDOM = simplexml_load_file($input, "SimpleXMLElement", LIBXML_NOCDATA);
        return self::parserecursive($xmlDOM);
    }
    static function xmlLoadString($input) {
        $xmlDOM = simplexml_load_string($input, "SimpleXMLElement", LIBXML_NOCDATA);
        return self::parserecursive($xmlDOM);
    }
    static function parserecursive($xmlARR) {
        return json_decode(json_encode($xmlARR), TRUE);
    }
    static function dump(array $array, $dom = 0, $item = 0) {
        if (!$dom) {
            $dom = new \DOMDocument("1.0");
        }
        if (!$item) {
            $item = $dom->createElement("root");
            $dom->appendChild($item);
        }
        foreach ($array as $key => $val) {
            $itemx = $dom->createElement(is_string($key) ? $key : "item");
            $item->appendChild($itemx);
            if (!is_array($val)) {
                $text = $dom->createTextNode($val);
                $itemx->appendChild($text);
            } else {
                self::dump($val, $dom, $itemx);
            }
        }
        return $dom->saveXML();
    }
}
}
namespace phpex\Util\ORG{
class Express {
    private $expressname = array(); 
    function __construct() {
        $this->expressname = $this->expressname();
    }
    
    private function getcontent($url) {
        $ch = curl_init();
        $timeout = 5;
        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, $timeout);
        $file_contents = curl_exec($ch);
        curl_close($ch);
        return $file_contents;
    }
    
    private function expressname() {
        $result = $this->getcontent("http://www.kuaidi100.com/");        
        preg_match_all("/data\-code\=\"(?P<name>\w+)\"\>\<span\>(?P<title>.*)\<\/span>/iU", $result, $data);
        $name = array();
        foreach ($data['title'] as $k => $v) {
            $name[$v] = $data['name'][$k];
        }
        return $name;
    }
    public function getAllExpressName() {
        return $this->expressname;
    }
    
    private function json_array($json) {
        if ($json) {
            foreach ((array) $json as $k => $v) {
                $data[$k] = !is_string($v) ? $this->json_array($v) : $v;
            }
            return $data;
        }
    }
    
    public function getorder($name, $order) {
        $keywords = $this->expressname[$name];
        $result = $this->getcontent("http://www.kuaidi100.com/query?type={$keywords}&postid={$order}");
        $result = json_decode($result);
        $data = $this->json_array($result);
        return $data;
    }
}
}
namespace phpex\Util\ORG{
class FileTypeValidation {
    private static $fileFormats = array(
        'jp2' => '0000000C6A502020',
        '3gp' => '0000002066747970',
        '3gp5' => '0000001866747970',
        'm4a' => '00000020667479704D3441',
        'ico' => '00000100',
        'spl' => '00000100',
        'vob' => '000001BA',
        'cur' => '00000200',
        'wb2' => '00000200',
        'wk1' => '0000020006040600',
        'wk3' => '00001A0000100400',
        'wk4' => '00001A0002100400',
        'wk5' => '00001A0002100400',
        '123' => '00001A00051004',
        'qxd' => '00004D4D585052',
        'mdf' => '010F0000',
        'tr1' => '0110',
        'rgb' => '01DA01010003',
        'drw' => '07',
        'dss' => '02647373',
        'dat' => 'A90D000000000000',
        'db3' => '03',
        'qph' => '03000000',
        'adx' => '80000020031204',
        'db4' => '04',
        'n' => 'FFFE0000',
        'a' => 'FFFE0000',
        'skf' => '07534B46',
        'dtd' => '0764743264647464',
        'db' => 'D0CF11E0A1B11AE1',
        'pcx' => '0A050101',
        'mp' => '0CED',
        'doc' => 'D0CF11E0A1B11AE1',
        'nri' => '0E4E65726F49534F',
        'wks' => 'FF00020004040554',
        'pf' => '1100000053434341',
        'ntf' => '4E49544630',
        'nsf' => '4E45534D1A01',
        'arc' => '41724301',
        'pak' => '5041434B',
        'eth' => '1A350100',
        'mkv' => '1A45DFA393428288',
        'ws' => '1D7D',
        'gz' => '1F8B08',
        'tar.z' => '1FA0',
        'ain' => '2112',
        'lib' => '213C617263683E0A',
        'msi' => 'D0CF11E0A1B11AE1',
        'vmdk' => '4B444D',
        'dsp' => '23204D6963726F73',
        'amr' => '2321414D52',
        'hdr' => '49536328',
        'sav' => '24464C3240282329',
        'eps' => 'C5D0D3C6',
        'pdf' => '25504446',
        'fdf' => '25504446',
        'hqx' => '2854686973206669',
        'log' => '2A2A2A2020496E73',
        'ivr' => '2E524543',
        'rm' => '2E524D46',
        'rmvb' => '2E524D46',
        'ra' => '2E7261FD00',
        'au' => '646E732E',
        'cat' => '30',
        'evt' => '300000004C664C65',
        'asf' => '3026B2758E66CF11',
        'wma' => '3026B2758E66CF11',
        'wmv' => '3026B2758E66CF11',
        'wri' => 'BE000000AB',
        '7z' => '377ABCAF271C',
        'psd' => '38425053',
        'sle' => '414376',
        'asx' => '3C',
        'xdr' => '3C',
        'dci' => '3C21646F63747970',
        'manifest' => '3C3F786D6C2076657273696F6E3D',
        'xml' => '3C3F786D6C2076657273696F6E3D22312E30223F3E',
        'msc' => 'D0CF11E0A1B11AE1',
        'fm' => '3C4D616B65724669',
        'mif' => '56657273696F6E20',
        'gid' => '4C4E0200',
        'hlp' => '4C4E0200',
        'dwg' => '41433130',
        'syw' => '414D594F',
        'abi' => '414F4C494E444558',
        'aby' => '414F4C4442',
        'bag' => '414F4C2046656564',
        'idx' => '5000000020000000',
        'ind' => '414F4C494458',
        'pfc' => '414F4C564D313030',
        'org' => '414F4C564D313030',
        'vcf' => '424547494E3A5643',
        'bin' => '424C4932323351',
        'bmp' => '424D',
        'dib' => '424D',
        'prc' => '424F4F4B4D4F4249',
        'bz2' => '425A68',
        'tar.bz2' => '425A68',
        'tbz2' => '425A68',
        'tb2' => '425A68',
        'rtd' => '43232B44A4434DA5',
        'cbd' => '434246494C45',
        'iso' => '4344303031',
        'clb' => '434F4D2B',
        'cpt' => '43505446494C45',
        'cru' => '43525553482076',
        'swf' => '465753',
        'ctf' => '436174616C6F6720',
        'dms' => '444D5321',
        'adf' => '5245564E554D3A2C',
        'dvr' => '445644',
        'ifo' => '445644',
        'cdr' => '52494646',
        'vcd' => '454E545259564344',
        'mdi' => '4550',
        'e01' => '4C5646090D0AFF00',
        'evtx' => '456C6646696C6500',
        'qbb' => '458600000600',
        'cpe' => '464158434F564552',
        'flv' => '464C56',
        'aiff' => '464F524D00',
        'eml' => '582D',
        'gif' => '47494638',
        'pat' => '47504154',
        'gx2' => '475832',
        'sh3' => '4848474231',
        'tif' => '4D4D002B',
        'tiff' => '4D4D002B',
        'mp3' => '494433',
        'koz' => '49443303000000',
        'crw' => '49491A0000004845',
        'cab' => '4D534346',
        'lit' => '49544F4C49544C53',
        'chi' => '49545346',
        'chm' => '49545346',
        'jar' => '5F27A889',
        'jg' => '4A47040E000000',
        'kgb' => '4B47425F61726368',
        'shd' => '68490000',
        'lnk' => '4C00000001140200',
        'obj' => '80',
        'pdb' => 'ACED000573720012',
        'mar' => '4D41723000',
        'dmp' => '504147454455',
        'hdmp' => '4D444D5093A7',
        'mls' => '4D563243',
        'mmf' => '4D4D4D440000',
        'nvram' => '4D52564E',
        'ppz' => '4D534346',
        'snp' => '4D534346',
        'tlb' => '4D53465402000100',
        'dvf' => '4D535F564F494345',
        'msv' => '4D535F564F494345',
        'mid' => '4D546864',
        'midi' => '4D546864',
        'dsn' => '4D56',
        'com' => 'EB',
        'dll' => '4D5A',
        'drv' => '4D5A',
        'exe' => '4D5A',
        'pif' => '4D5A',
        'qts' => '4D5A',
        'qtx' => '4D5A',
        'sys' => 'FFFFFFFF',
        'acm' => '4D5A',
        'ax' => '4D5A900003000000',
        'cpl' => 'DCDC',
        'fon' => '4D5A',
        'ocx' => '4D5A',
        'olb' => '4D5A',
        'scr' => '4D5A',
        'vbx' => '4D5A',
        'vxd' => '4D5A',
        '386' => '4D5A',
        'api' => '4D5A900003000000',
        'flt' => '76323030332E3130',
        'zap' => '4D5A90000300000004000000FFFF',
        'sln' => '4D6963726F736F66742056697375616C',
        'jnt' => '4E422A00',
        'jtp' => '4E422A00',
        'cod' => '4E616D653A20',
        'dbf' => '4F504C4461746162',
        'oga' => '4F67675300020000',
        'ogg' => '4F67675300020000',
        'ogv' => '4F67675300020000',
        'ogx' => '4F67675300020000',
        'dw4' => '4F7B',
        'pgm' => '50350A',
        'pax' => '504158',
        'pgd' => '504750644D41494E',
        'img' => 'EB3C902A',
        'zip' => '504B0304140000',
        'docx' => '504B030414000600',
        'pptx' => '504B030414000600',
        'xlsx' => '504B030414000600',
        'kwd' => '504B0304',
        'odt' => '504B0304',
        'odp' => '504B0304',
        'ott' => '504B0304',
        'sxc' => '504B0304',
        'sxd' => '504B0304',
        'sxi' => '504B0304',
        'sxw' => '504B0304',
        'wmz' => '504B0304',
        'xpi' => '504B0304',
        'xps' => '504B0304',
        'xpt' => '5850434F4D0A5479',
        'grp' => '504D4343',
        'qemu' => '514649',
        'abd' => '5157205665722E20',
        'qsd' => '5157205665722E20',
        'reg' => 'FFFE',
        'sud' => '52454745444954',
        'ani' => '52494646',
        'cmx' => '52494646',
        'ds4' => '52494646',
        '4xm' => '52494646',
        'avi' => '52494646',
        'cda' => '52494646',
        'qcp' => '52494646',
        'rmi' => '52494646',
        'wav' => '52494646',
        'cap' => '58435000',
        'rar' => '526172211A0700',
        'ast' => '5343486C',
        'shw' => '53484F57',
        'cpi' => 'FF464F4E54',
        'sit' => '5374756666497420',
        'sdr' => '534D415254445257',
        'cnv' => '53514C4F434F4E56',
        'cal' => 'B5A2B0B3B3B0A5B5',
        'info' => 'E310000100000000',
        'uce' => '55434558',
        'ufa' => '554641C6D2C1',
        'pch' => '564350434830',
        'ctl' => '56455253494F4E20',
        'ws2' => '575332303030',
        'lwp' => '576F726450726F',
        'bdr' => '5854',
        'zoo' => '5A4F4F20',
        'ecf' => '5B47656E6572616C',
        'vcw' => '5B4D535643',
        'dun' => '5B50686F6E655D',
        'sam' => '5B7665725D',
        'cpx' => '5B57696E646F7773',
        'cfg' => '5B666C7473696D2E',
        'cas' => '5F434153455F',
        'cbk' => '5F434153455F',
        'arj' => '60EA',
        'vhd' => '636F6E6563746978',
        'csh' => '6375736800000002',
        'p10' => '64000000',
        'dex' => '6465780A30303900',
        'dsw' => '64737766696C65',
        'flac' => '664C614300000022',
        'dbb' => '6C33336C',
        'acd' => '72696666',
        'ram' => '727473703A2F2F',
        'dmg' => '78',
        'lgc' => '7B0D0A6F20',
        'lgd' => '7B0D0A6F20',
        'pwi' => '7B5C707769',
        'rtf' => '7B5C72746631',
        'psp' => '7E424B00',
        'wab' => '9CCBCB8D1375D211',
        'wpf' => '81CDAB',
        'png' => '89504E470D0A1A0A',
        'aw' => '8A0109000000E108',
        'hap' => '91334846',
        'skr' => '9501',
        'gpg' => '99',
        'pkr' => '9901',
        'qdf' => 'AC9EBD8F0000',
        'pwl' => 'E3828596',
        'dcx' => 'B168DE3A',
        'tib' => 'B46E6844',
        'acs' => 'C3ABCDAB',
        'lbk' => 'C8007900',
        'class' => 'CAFEBABE',
        'dbx' => 'CFAD12FE',
        'dot' => 'D0CF11E0A1B11AE1',
        'pps' => 'D0CF11E0A1B11AE1',
        'ppt' => 'D0CF11E0A1B11AE1',
        'xla' => 'D0CF11E0A1B11AE1',
        'xls' => 'D0CF11E0A1B11AE1',
        'wiz' => 'D0CF11E0A1B11AE1',
        'ac_' => 'D0CF11E0A1B11AE1',
        'adp' => 'D0CF11E0A1B11AE1',
        'apr' => 'D0CF11E0A1B11AE1',
        'mtw' => 'D0CF11E0A1B11AE1',
        'opt' => 'D0CF11E0A1B11AE1',
        'pub' => 'D0CF11E0A1B11AE1',
        'rvt' => 'D0CF11E0A1B11AE1',
        'sou' => 'D0CF11E0A1B11AE1',
        'spo' => 'D0CF11E0A1B11AE1',
        'vsd' => 'D0CF11E0A1B11AE1',
        'wps' => 'D0CF11E0A1B11AE1',
        'ftr' => 'D20A0000',
        'arl' => 'D42A',
        'aut' => 'D42A',
        'wmf' => 'D7CDC69A',
        'efx' => 'DCFE',
        'one' => 'E4525C7B8CD8A74D',
        'rpm' => 'EDABEEDB',
        'gho' => 'FEEF',
        'ghs' => 'FEEF',
        'wp' => 'FF575043',
        'wpd' => 'FF575043',
        'wpg' => 'FF575043',
        'wpp' => 'FF575043',
        'wp5' => 'FF575043',
        'wp6' => 'FF575043',
        'jfif' => 'FFD8FF',
        'jpe' => 'FFD8FF',
        'jpeg' => 'FFD8FF',
        'jpg' => 'FFD8FF',
        'mof' => 'FFFE23006C006900',
        'ipa' => '504B03040A',
    );
    
    public static function validation($filePath, $fileExt) {
                if (!isset(self::$fileFormats[$fileExt])) {
            return false;
        }
        $length = strlen(self::$fileFormats[$fileExt]);
        $bin = self::readFile($filePath, $length);
        $fileHead = unpack("H{$length}", $bin);
                if (strtolower(self::$fileFormats[$fileExt]) == $fileHead[1]) {
            return true;
        }
        return false;
    }
    
    private static function readFile($filePath, $size) {
        $file = fopen($filePath, "rb");
        $bin = fread($file, $size);
        fclose($file);
        return $bin;
    }
}
}
namespace phpex\Util\ORG{
use phpex\Foundation\Response;
class Image {
    static private $error;
    
    static public function buildString($string = '', $width = 48, $height = 22, $image_code = "") {
        $length = strlen($string);
        $width = ($length * 9 + 10) > $width ? $length * 9 + 10 : $width;
        $verify = imagecreatetruecolor($width, $height);
        $white = imagecolorallocate($verify, 0xFF, 0xFF, 0xFF);
        imagefill($verify, 0, 0, $white);                 $blue = imagecolorallocate($verify, 43, 51, 204);
        $red = imagecolorallocate($verify, 208, 44, 44);
        $green = imagecolorallocate($verify, 51, 255, 204);
                imagedashedline($verify, rand(0, $width), 0, rand(0, $width), $height, $red);
        imagedashedline($verify, rand(0, $width), 0, rand(0, $width), $height, $blue);
        imagedashedline($verify, rand(0, $width), 0, rand(0, $width), $height, $blue);
        imageline($verify, 0, rand(0, $height), $width, rand(0, $height), $green);
                imagestring($verify, 5, rand(2, ($width / $length)), rand(1, $height / 3), $string, $blue);
        imagedashedline($verify, rand(0, $width), 0, rand(0, $width), $height, $blue);
        imagedashedline($verify, rand(0, $width), 0, rand(0, $width), $height, $blue);
        ob_start();
        imagejpeg($verify);
        return new Response(ob_get_clean(), 200, array('Content-Type' => "image/jpeg", "Image-Code" => $image_code));
    }
    static public function buildStringBase($string = '', $width = 48, $height = 22, $image_code = ""){
        $length = strlen($string);
        $width = ($length * 9 + 10) > $width ? $length * 9 + 10 : $width;
        $verify = imagecreatetruecolor($width, $height);
        $white = imagecolorallocate($verify, 0xFF, 0xFF, 0xFF);
        imagefill($verify, 0, 0, $white);                 $blue = imagecolorallocate($verify, 43, 51, 204);
        $red = imagecolorallocate($verify, 208, 44, 44);
        $green = imagecolorallocate($verify, 51, 255, 204);
                imagedashedline($verify, rand(0, $width), 0, rand(0, $width), $height, $red);
        imagedashedline($verify, rand(0, $width), 0, rand(0, $width), $height, $blue);
        imagedashedline($verify, rand(0, $width), 0, rand(0, $width), $height, $blue);
        imageline($verify, 0, rand(0, $height), $width, rand(0, $height), $green);
                imagestring($verify, 5, rand(2, ($width / $length)), rand(1, $height / 3), $string, $blue);
        imagedashedline($verify, rand(0, $width), 0, rand(0, $width), $height, $blue);
        imagedashedline($verify, rand(0, $width), 0, rand(0, $width), $height, $blue);
        ob_start();
        imagejpeg($verify);
        return new Response("data:image/jpeg;base64,".base64_encode(ob_get_clean()), 200, array('Content-Type' => "image/jpeg", "Image-Code" => $image_code));
    }
    
    static public function thumb($source, $saveName, $width = null, $height = null) {
                if (is_file($source)) {
            $info = self::getImageInfo($source);
            if (false === $info) {
                self::$error = 'Failed to get image information';
                return false;
            }
        } else {
            self::$error = 'Image not exists ';
            return false;
        }
        if (is_null($width) && is_null($height)) {
            self::$error = 'You need to specify the width and height of at least one';
            return false;
        } elseif (is_null($width)) {
            $width = ($info['width'] * $height) / $info['height'];
        } elseif (is_null($height)) {
            $height = ($info['height'] * $width) / $info['width'];
        }
        $newImage = imagecreatetruecolor($width, $height);
        $functionName = "imagecreatefrom" . $info['type'];
        $sourImage = $functionName($source);
        imagecopyresampled($newImage, $sourImage, 0, 0, 0, 0, $width, $height, $info['width'], $info['height']);
        if (false === mk_dir(dirname($saveName))) {
            self::$error = ' Directory cannot write : ' . $savePath;
        }
        imagejpeg($newImage, $saveName);
    }
    
    static public function water($resource, $water, $savename = null, $alpha = 80, $position = 5, $margin = 0) {
                if (!file_exists($resource) || !file_exists($water)) {
            self::$error = '缺少源文件或者水印文件';
            return false;
        }
        if (!is_numeric($alpha) || $alpha > 100) {
            $alpha = 80;
        }
                $resourceInfo = self::getImageInfo($resource);
        $waterInfo = self::getImageInfo($water);
                if (false === $resourceInfo || false === $waterInfo) {
            self::$error = '获取文件信息失败';
            return false;
        }
                if ($resourceInfo['width'] < $waterInfo['width'] || $resourceInfo['height'] < $waterInfo['height']) {
            self::$error = '源文件的宽高小于水印图片宽高';
            return false;
        }
                $positionArr = self::getPosition($resourceInfo, $waterInfo, $position, $margin);
                $sCreateFun = "imagecreatefrom" . $resourceInfo['type'];
        $sImage = $sCreateFun($resource);
        $wCreateFun = "imagecreatefrom" . $waterInfo['type'];
        $wImage = $wCreateFun($water);
                imagealphablending($wImage, true);
                imagecopymerge($sImage, $wImage, $positionArr['left'], $positionArr['top'], 0, 0, $waterInfo['width'], $waterInfo['height'], $alpha);
                $ImageFun = 'Image' . $resourceInfo['type'];
        mk_dir(dirname($savename));
                if (is_null($savename)) {
            $savename = $resource;
            @unlink($resource);
        }
                $ImageFun($sImage, $savename);
        imagedestroy($sImage);
    }
    static private function getPosition($resourceInfo, $waterInfo, $position, $margin = 0) {
        switch ($position) {
            case 0:                 $left = $resourceInfo['width'] - $waterInfo['width'];
                $top = $resourceInfo['height'] - $waterInfo['height'];
                return array('left' => mt_rand(0 + $margin, $left - $margin), 'top' => mt_rand(0 + $margin, $top - $margin));
            case 1:                 return array('left' => 0 + $margin, 'top' => 0 + $margin);
            case 2:                 $left = ($resourceInfo['width'] - $waterInfo['width']) / 2;
                return array('left' => $left, 'top' => 0 + $margin);
            case 3:                 $left = $resourceInfo['width'] - $waterInfo['width'];
                return array('left' => $left - $margin, 'top' => 0 + $margin);
            case 4:                 $top = ($resourceInfo['height'] - $waterInfo['height']) / 2;
                return array('left' => 0 + $margin, 'top' => $top);
            case 5:                 $left = ($resourceInfo['width'] - $waterInfo['width']) / 2;
                $top = ($resourceInfo['height'] - $waterInfo['height']) / 2;
                return array('left' => $left, 'top' => $top);
            case 6:                 $left = $resourceInfo['width'] - $waterInfo['width'];
                $top = ($resourceInfo['height'] - $waterInfo['height']) / 2;
                return array('left' => $left - $margin, 'top' => $top);
            case 7:                $top = $resourceInfo['height'] - $waterInfo['height'];
                return array('left' => 0 + $margin, 'top' => $top - $margin);
            case 8:                $top = $resourceInfo['height'] - $waterInfo['height'];
                $left = ($resourceInfo['width'] - $waterInfo['width']) / 2;
                return array('left' => $left, 'top' => $top - $margin);
            case 9:                $left = $resourceInfo['width'] - $waterInfo['width'];
                $top = $resourceInfo['height'] - $waterInfo['height'];
                return array('left' => $left, 'top' => $top - $margin);
        }
    }
    
    static function getImageInfo($img) {
        $imageInfo = getimagesize($img);
        if ($imageInfo !== false) {
            $imageType = strtolower(substr(image_type_to_extension($imageInfo[2]), 1));
            $imageSize = filesize($img);
            $info = array(
                "width" => $imageInfo[0],
                "height" => $imageInfo[1],
                "type" => $imageType,
                "size" => $imageSize,
                "mime" => $imageInfo['mime']
            );
            return $info;
        } else {
            return false;
        }
    }
    
    public static function clip($resource, $savename, $newWidth, $newHeight, $x = 0, $y = 0) {
        if ($newWidth < 1 || $newHeight < 1) {
            self::$error = "params width or height error !";
            return false;
        }
        if (!file_exists($resource)) {
            self::$error = $resource . " is not exists !";
            return false;
        }
        $clipInfo = self::getImageInfo($resource);
        $support_type = array('jpeg', 'png', 'gif');
        if (!in_array($clipInfo['type'], $support_type, true)) {
            self::$error = "this type of image does not support! only support jpg , gif or png";
            return false;
        }
        $wCreateFun = "imagecreatefrom" . $clipInfo['type'];
        $src_img = $wCreateFun($resource);
        $w = imagesx($src_img);
        $h = imagesy($src_img);
        $ratio_w = 1.0 * $newWidth / $w;
        $ratio_h = 1.0 * $newHeight / $h;
        $ratio = 1.0;
        $imagesFun = "image" . $clipInfo['type'];
        mk_dir(dirname($savename));
        if (($ratio_w < 1 && $ratio_h < 1) || ($ratio_w > 1 && $ratio_h > 1)) {
            if ($ratio_w < $ratio_h) {
                $ratio = $ratio_h;
            } else {
                $ratio = $ratio_w;
            }
            $inter_w = (int)($newWidth / $ratio);
            $inter_h = (int)($newHeight / $ratio);
            $inter_img = imagecreatetruecolor($inter_w, $inter_h);
            imagecopy($inter_img, $src_img, 0, 0, 0, 0, $inter_w, $inter_h);
            $new_img = imagecreatetruecolor($newWidth, $newHeight);
            imagecopyresampled($new_img, $inter_img, 0, 0, 0, 0, $newWidth, $newHeight, $inter_w, $inter_h);
            $imagesFun($new_img, $savename, 100);
        } else {
            $ratio = $ratio_h > $ratio_w ? $ratio_h : $ratio_w;
            $inter_w = (int)($w * $ratio);
            $inter_h = (int)($h * $ratio);
            $inter_img = imagecreatetruecolor($inter_w, $inter_h);
            imagecopyresampled($inter_img, $src_img, 0, 0, (int)$x, (int)$y, $inter_w, $inter_h, $w, $h);
            $new_img = imagecreatetruecolor($newWidth, $newHeight);
            imagecopy($new_img, $inter_img, 0, 0, 0, 0, $newWidth, $newHeight);
            $imagesFun($new_img, $savename, 100);
        }
    }
    
    static public function getError() {
        return self::$error;
    }
}
}
namespace phpex\Util\ORG{
class Lang {
    
    private static $instance;
    private $var_name = "l";
    private $current_lang = "zh-cn";
    private $default_lang = "zh-cn";
    private $langs = array();
    private function __construct() {
        $lang = C("lang");
        $langdir = C("config_path") . "lang/";
        foreach ($lang as $value) {
            $this->langs[$value["names_en"]] = parseFile($langdir . $value["package"]);
        }
        $this->setVarName($this->var_name);
    }
    public static function getInstance() {
        if (!self::$instance) {
            self::$instance = new static();
        }
        return self::$instance;
    }
    public function setCurrentLang($name) {
        if (isset($this->langs[$name]))
            $this->current_lang = $name;
        else
            debug_throws("不支持此语言：%s", $name);
    }
    public function setDefaultLang($name) {
        if (isset($this->langs[$name]))
            $this->default_lang = $name;
        else
            debug_throws("不支持此语言：%s", $name);
    }
    public function getDefalutLang() {
        return $this->default_lang;
    }
    public function getCurrentLang() {
        return $this->current_lang;
    }
    public function setVarName($var_name) {
        $this->var_name = $var_name;
        if (isset($_GET[$var_name]) && isset($this->langs[$_GET[$var_name]])) {
            $this->current_lang = $_GET[$var_name];
        }
    }
    public static function translation($key) {
        $instance = self::getInstance();
        return $instance->translations($key);
    }
    public function translations($key) {
        if (isset($this->langs[$this->current_lang][$key])) {
            return $this->langs[$this->current_lang][$key];
        } elseif (isset($this->langs[$this->default_lang][$key])) {
            return $this->langs[$this->default_lang][$key];
        } else {
            return sprintf("__%s__", $key);
        }
    }
}
}
namespace phpex\Util\ORG{
use \Exception;
if (version_compare(PHP_VERSION, '5.0.0', '<') ) exit("Sorry, this version of PHPMailer will only run on PHP version 5 or greater!\n");
class PHPMailer {
      
  
  public $Priority          = 3;
  
  public $CharSet           = 'iso-8859-1';
  
  public $ContentType       = 'text/plain';
  
  public $Encoding          = '8bit';
  
  public $ErrorInfo         = '';
  
  public $From              = 'root@localhost';
  
  public $FromName          = 'Root User';
  
  public $Sender            = '';
  
  public $Subject           = '';
  
  public $Body              = '';
  
  public $AltBody           = '';
  
  public $WordWrap          = 0;
  
  public $Mailer            = 'mail';
  
  public $Sendmail          = '/usr/sbin/sendmail';
  
  public $PluginDir         = '';
  
  public $ConfirmReadingTo  = '';
  
  public $Hostname          = '';
  
  public $MessageID         = '';
      
  
  public $Host          = 'localhost';
  
  public $Port          = 25;
  
  public $Helo          = '';
  
  public $SMTPSecure    = '';
  
  public $SMTPAuth      = false;
  
  public $Username      = '';
  
  public $Password      = '';
  
  public $Timeout       = 10;
  
  public $SMTPDebug     = false;
  
  public $SMTPKeepAlive = false;
  
  public $SingleTo      = false;
  
  public $LE              = "\n";
  
  public $Version         = '5.0.2';
      
  private   $smtp           = NULL;
  private   $to             = array();
  private   $cc             = array();
  private   $bcc            = array();
  private   $ReplyTo        = array();
  private   $all_recipients = array();
  private   $attachment     = array();
  private   $CustomHeader   = array();
  private   $message_type   = '';
  private   $boundary       = array();
  protected $language       = array();
  private   $error_count    = 0;
  private   $sign_cert_file = "";
  private   $sign_key_file  = "";
  private   $sign_key_pass  = "";
  private   $exceptions     = false;
      
  const STOP_MESSAGE = 0;   const STOP_CONTINUE = 1;   const STOP_CRITICAL = 2; 
      
  
  public function __construct($exceptions = false) {
    $this->exceptions = ($exceptions == true);
  }
  
  public function IsHTML($ishtml = true) {
    if ($ishtml) {
      $this->ContentType = 'text/html';
    } else {
      $this->ContentType = 'text/plain';
    }
  }
  
  public function IsSMTP() {
    $this->Mailer = 'SMTP';
  }
  
  public function IsMail() {
    $this->Mailer = 'mail';
  }
  
  public function IsSendmail() {
    if (!stristr(ini_get('sendmail_path'), 'sendmail')) {
      $this->Sendmail = '/var/qmail/bin/sendmail';
    }
    $this->Mailer = 'sendmail';
  }
  
  public function IsQmail() {
    if (stristr(ini_get('sendmail_path'), 'qmail')) {
      $this->Sendmail = '/var/qmail/bin/sendmail';
    }
    $this->Mailer = 'sendmail';
  }
      
  
  public function AddAddress($address, $name = '') {
    return $this->AddAnAddress('to', $address, $name);
  }
  
  public function AddCC($address, $name = '') {
    return $this->AddAnAddress('cc', $address, $name);
  }
  
  public function AddBCC($address, $name = '') {
    return $this->AddAnAddress('bcc', $address, $name);
  }
  
  public function AddReplyTo($address, $name = '') {
    return $this->AddAnAddress('ReplyTo', $address, $name);
  }
  
  private function AddAnAddress($kind, $address, $name = '') {
    if (!preg_match('/^(to|cc|bcc|ReplyTo)$/', $kind)) {
      echo 'Invalid recipient array: ' . kind;
      return false;
    }
    $address = trim($address);
    $name = trim(preg_replace('/[\r\n]+/', '', $name));     if (!self::ValidateAddress($address)) {
      $this->SetError($this->Lang('invalid_address').': '. $address);
      if ($this->exceptions) {
        throw new phpmailerException($this->Lang('invalid_address').': '.$address);
      }
      echo $this->Lang('invalid_address').': '.$address;
      return false;
    }
  if ($kind != 'ReplyTo') {
    if (!isset($this->all_recipients[strtolower($address)])) {
        array_push($this->$kind, array($address, $name));
        $this->all_recipients[strtolower($address)] = true;
    return true;
      }
  } else {
    if (!array_key_exists(strtolower($address), $this->ReplyTo)) {
        $this->ReplyTo[strtolower($address)] = array($address, $name);
    return true;
    }
  }
    return false;
  }
  public function SetFrom($address, $name = '') {
    $address = trim($address);
    $name = trim(preg_replace('/[\r\n]+/', '', $name));     if (!self::ValidateAddress($address)) {
      $this->SetError($this->Lang('invalid_address').': '. $address);
      if ($this->exceptions) {
        throw new phpmailerException($this->Lang('invalid_address').': '.$address);
      }
      echo $this->Lang('invalid_address').': '.$address;
      return false;
    }
  $this->From = $address;
  $this->FromName = $name;
  return true;
  }
  
  public static function ValidateAddress($address) {
    if (function_exists('filter_var')) {       if(filter_var($address, FILTER_VALIDATE_EMAIL) === FALSE) {
        return false;
      } else {
        return true;
      }
    } else {
      return preg_match('/^(?:[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+\.)*[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+@(?:(?:(?:[a-zA-Z0-9_](?:[a-zA-Z0-9_\-](?!\.)){0,61}[a-zA-Z0-9_-]?\.)+[a-zA-Z0-9_](?:[a-zA-Z0-9_\-](?!$)){0,61}[a-zA-Z0-9_]?)|(?:\[(?:(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\]))$/', $address);
    }
  }
      
  
  public function Send($catch=false) {
    try {
      if ((count($this->to) + count($this->cc) + count($this->bcc)) < 1) {
        throw new phpmailerException($this->Lang('provide_address'), self::STOP_CRITICAL);
      }
            if(!empty($this->AltBody)) {
        $this->ContentType = 'multipart/alternative';
      }
      $this->error_count = 0;       $this->SetMessageType();
      $header = $this->CreateHeader();
      $body = $this->CreateBody();
      if (empty($this->Body)) {
        throw new phpmailerException($this->Lang('empty_message'), self::STOP_CRITICAL);
      }
            switch($this->Mailer) {
        case 'sendmail':
          return $this->SendmailSend($header, $body);
        case 'SMTP':
          return $this->SmtpSend($header, $body);
        case 'mail':
        default:
          return $this->MailSend($header, $body);
      }
    } catch (phpmailerException $e) {      
      $this->SetError($e->getMessage());
      if ($catch) {
        throw $e;
      }
            return false;
    }
  }
  
  protected function SendmailSend($header, $body) {
    if ($this->Sender != '') {
      $sendmail = sprintf("%s -oi -f %s -t", escapeshellcmd($this->Sendmail), escapeshellarg($this->Sender));
    } else {
      $sendmail = sprintf("%s -oi -t", escapeshellcmd($this->Sendmail));
    }
    if(!@$mail = popen($sendmail, 'w')) {
      throw new phpmailerException($this->Lang('execute') . $this->Sendmail, self::STOP_CRITICAL);
    }
    fputs($mail, $header);
    fputs($mail, $body);
    $result = pclose($mail);
    if($result != 0) {
      throw new phpmailerException($this->Lang('execute') . $this->Sendmail, self::STOP_CRITICAL);
    }
    return true;
  }
  
  protected function MailSend($header, $body) {
    $toArr = array();
    foreach($this->to as $t) {
      $toArr[] = $this->AddrFormat($t);
    }
    $to = implode(', ', $toArr);
    $params = sprintf("-oi -f %s", $this->Sender);
    if ($this->Sender != '' && strlen(ini_get('safe_mode'))< 1) {
      $old_from = ini_get('sendmail_from');
      ini_set('sendmail_from', $this->Sender);
      if ($this->SingleTo === true && count($toArr) > 1) {
        foreach ($toArr as $key => $val) {
          $rt = @mail($val, $this->EncodeHeader($this->SecureHeader($this->Subject)), $body, $header, $params);
        }
      } else {
        $rt = @mail($to, $this->EncodeHeader($this->SecureHeader($this->Subject)), $body, $header, $params);
      }
    } else {
      if ($this->SingleTo === true && count($toArr) > 1) {
        foreach ($toArr as $key => $val) {
          $rt = @mail($val, $this->EncodeHeader($this->SecureHeader($this->Subject)), $body, $header, $params);
        }
      } else {
        $rt = @mail($to, $this->EncodeHeader($this->SecureHeader($this->Subject)), $body, $header);
      }
    }
    if (isset($old_from)) {
      ini_set('sendmail_from', $old_from);
    }
    if(!$rt) {
      throw new phpmailerException($this->Lang('instantiate'), self::STOP_CRITICAL);
    }
    return true;
  }
  
  protected function SmtpSend($header, $body) {
        $bad_rcpt = array();
    if(!$this->SmtpConnect()) {
      throw new phpmailerException($this->Lang('smtp_connect_failed'), self::STOP_CRITICAL);
    }
    $smtp_from = ($this->Sender == '') ? $this->From : $this->Sender;
    if(!$this->smtp->Mail($smtp_from)) {
      throw new phpmailerException($this->Lang('from_failed') . $smtp_from, self::STOP_CRITICAL);
    }
        foreach($this->to as $to) {
      if (!$this->smtp->Recipient($to[0])) {
        $bad_rcpt[] = $to[0];
      }
    }
    foreach($this->cc as $cc) {
      if (!$this->smtp->Recipient($cc[0])) {
        $bad_rcpt[] = $cc[0];
      }
    }
    foreach($this->bcc as $bcc) {
      if (!$this->smtp->Recipient($bcc[0])) {
        $bad_rcpt[] = $bcc[0];
      }
    }
    if (count($bad_rcpt) > 0 ) {       $badaddresses = implode(', ', $bad_rcpt);
      throw new phpmailerException($this->Lang('recipients_failed') . $badaddresses);
    }
    if(!$this->smtp->Data($header . $body)) {
      throw new phpmailerException($this->Lang('data_not_accepted'), self::STOP_CRITICAL);
    }
    if($this->SMTPKeepAlive == true) {
      $this->smtp->Reset();
    }
    return true;
  }
  
  public function SmtpConnect() {
    if(is_null($this->smtp)) {
      $this->smtp = new SMTP();
    }
    $this->smtp->do_debug = $this->SMTPDebug;
    $hosts = explode(';', $this->Host);
    $index = 0;
    $connection = $this->smtp->Connected();
        try {
      while($index < count($hosts) && !$connection) {
        $hostinfo = array();
        if (preg_match('/^(.+):([0-9]+)$/', $hosts[$index], $hostinfo)) {
          $host = $hostinfo[1];
          $port = $hostinfo[2];
        } else {
          $host = $hosts[$index];
          $port = $this->Port;
        }
        $tls = ($this->SMTPSecure == 'tls');
        $ssl = ($this->SMTPSecure == 'ssl');
        if ($this->smtp->Connect(($ssl ? 'ssl://':'').$host, $port, $this->Timeout)) {
          $hello = ($this->Helo != '' ? $this->Helo : $this->ServerHostname());
          $this->smtp->Hello($hello);
          if ($tls) {
            if (!$this->smtp->StartTLS()) {
              throw new phpmailerException($this->Lang('tls'));
            }
                        $this->smtp->Hello($hello);
          }
          $connection = true;
          if ($this->SMTPAuth) {
            if (!$this->smtp->Authenticate($this->Username, $this->Password)) {
              throw new phpmailerException($this->Lang('authenticate'));
            }
          }
        }
        $index++;
        if (!$connection) {
          throw new phpmailerException($this->Lang('connect_host'));
        }
      }
    } catch (phpmailerException $e) {
      $this->smtp->Reset();
      throw $e;
    }
    return true;
  }
  
  public function SmtpClose() {
    if(!is_null($this->smtp)) {
      if($this->smtp->Connected()) {
        $this->smtp->Quit();
        $this->smtp->Close();
      }
    }
  }
  
  function SetLanguage($langcode = 'en', $lang_path = 'language/') {
        $PHPMAILER_LANG = array(
      'provide_address' => 'You must provide at least one recipient email address.',
      'mailer_not_supported' => ' mailer is not supported.',
      'execute' => 'Could not execute: ',
      'instantiate' => 'Could not instantiate mail function.',
      'authenticate' => 'SMTP Error: Could not authenticate.',
      'from_failed' => 'The following From address failed: ',
      'recipients_failed' => 'SMTP Error: The following recipients failed: ',
      'data_not_accepted' => 'SMTP Error: Data not accepted.',
      'connect_host' => 'SMTP Error: Could not connect to SMTP host.',
      'file_access' => 'Could not access file: ',
      'file_open' => 'File Error: Could not open file: ',
      'encoding' => 'Unknown encoding: ',
      'signing' => 'Signing Error: ',
      'smtp_error' => 'SMTP server error: ',
      'empty_message' => 'Message body empty',
      'invalid_address' => 'Invalid address',
      'variable_set' => 'Cannot set or reset variable: '
    );
        $l = true;
    if ($langcode != 'en') {       $l = @include $lang_path.'phpmailer.lang-'.$langcode.'.php';
    }
    $this->language = $PHPMAILER_LANG;
    return ($l == true);   }
  
  public function GetTranslations() {
    return $this->language;
  }
      
  
  public function AddrAppend($type, $addr) {
    $addr_str = $type . ': ';
    $addresses = array();
    foreach ($addr as $a) {
      $addresses[] = $this->AddrFormat($a);
    }
    $addr_str .= implode(', ', $addresses);
    $addr_str .= $this->LE;
    return $addr_str;
  }
  
  public function AddrFormat($addr) {
    if (empty($addr[1])) {
      return $this->SecureHeader($addr[0]);
    } else {
      return $this->EncodeHeader($this->SecureHeader($addr[1]), 'phrase') . " <" . $this->SecureHeader($addr[0]) . ">";
    }
  }
  
  public function WrapText($message, $length, $qp_mode = false) {
    $soft_break = ($qp_mode) ? sprintf(" =%s", $this->LE) : $this->LE;
            $is_utf8 = (strtolower($this->CharSet) == "utf-8");
    $message = $this->FixEOL($message);
    if (substr($message, -1) == $this->LE) {
      $message = substr($message, 0, -1);
    }
    $line = explode($this->LE, $message);
    $message = '';
    for ($i=0 ;$i < count($line); $i++) {
      $line_part = explode(' ', $line[$i]);
      $buf = '';
      for ($e = 0; $e<count($line_part); $e++) {
        $word = $line_part[$e];
        if ($qp_mode and (strlen($word) > $length)) {
          $space_left = $length - strlen($buf) - 1;
          if ($e != 0) {
            if ($space_left > 20) {
              $len = $space_left;
              if ($is_utf8) {
                $len = $this->UTF8CharBoundary($word, $len);
              } elseif (substr($word, $len - 1, 1) == "=") {
                $len--;
              } elseif (substr($word, $len - 2, 1) == "=") {
                $len -= 2;
              }
              $part = substr($word, 0, $len);
              $word = substr($word, $len);
              $buf .= ' ' . $part;
              $message .= $buf . sprintf("=%s", $this->LE);
            } else {
              $message .= $buf . $soft_break;
            }
            $buf = '';
          }
          while (strlen($word) > 0) {
            $len = $length;
            if ($is_utf8) {
              $len = $this->UTF8CharBoundary($word, $len);
            } elseif (substr($word, $len - 1, 1) == "=") {
              $len--;
            } elseif (substr($word, $len - 2, 1) == "=") {
              $len -= 2;
            }
            $part = substr($word, 0, $len);
            $word = substr($word, $len);
            if (strlen($word) > 0) {
              $message .= $part . sprintf("=%s", $this->LE);
            } else {
              $buf = $part;
            }
          }
        } else {
          $buf_o = $buf;
          $buf .= ($e == 0) ? $word : (' ' . $word);
          if (strlen($buf) > $length and $buf_o != '') {
            $message .= $buf_o . $soft_break;
            $buf = $word;
          }
        }
      }
      $message .= $buf . $this->LE;
    }
    return $message;
  }
  
  public function UTF8CharBoundary($encodedText, $maxLength) {
    $foundSplitPos = false;
    $lookBack = 3;
    while (!$foundSplitPos) {
      $lastChunk = substr($encodedText, $maxLength - $lookBack, $lookBack);
      $encodedCharPos = strpos($lastChunk, "=");
      if ($encodedCharPos !== false) {
                        $hex = substr($encodedText, $maxLength - $lookBack + $encodedCharPos + 1, 2);
        $dec = hexdec($hex);
        if ($dec < 128) {                               $maxLength = ($encodedCharPos == 0) ? $maxLength :
          $maxLength - ($lookBack - $encodedCharPos);
          $foundSplitPos = true;
        } elseif ($dec >= 192) {                     $maxLength = $maxLength - ($lookBack - $encodedCharPos);
          $foundSplitPos = true;
        } elseif ($dec < 192) {           $lookBack += 3;
        }
      } else {
                $foundSplitPos = true;
      }
    }
    return $maxLength;
  }
  
  public function SetWordWrap() {
    if($this->WordWrap < 1) {
      return;
    }
    switch($this->message_type) {
      case 'alt':
      case 'alt_attachments':
        $this->AltBody = $this->WrapText($this->AltBody, $this->WordWrap);
        break;
      default:
        $this->Body = $this->WrapText($this->Body, $this->WordWrap);
        break;
    }
  }
  
  public function CreateHeader() {
    $result = '';
        $uniq_id = md5(uniqid(time()));
    $this->boundary[1] = 'b1_' . $uniq_id;
    $this->boundary[2] = 'b2_' . $uniq_id;
    $result .= $this->HeaderLine('Date', self::RFCDate());
    if($this->Sender == '') {
      $result .= $this->HeaderLine('Return-Path', trim($this->From));
    } else {
      $result .= $this->HeaderLine('Return-Path', trim($this->Sender));
    }
        if($this->Mailer != 'mail') {
      if(count($this->to) > 0) {
        $result .= $this->AddrAppend('To', $this->to);
      } elseif (count($this->cc) == 0) {
        $result .= $this->HeaderLine('To', 'undisclosed-recipients:;');
      }
    }
    $from = array();
    $from[0][0] = trim($this->From);
    $from[0][1] = $this->FromName;
    $result .= $this->AddrAppend('From', $from);
        if(count($this->cc) > 0) {
      $result .= $this->AddrAppend('Cc', $this->cc);
    }
        if((($this->Mailer == 'sendmail') || ($this->Mailer == 'mail')) && (count($this->bcc) > 0)) {
      $result .= $this->AddrAppend('Bcc', $this->bcc);
    }
    if(count($this->ReplyTo) > 0) {
      $result .= $this->AddrAppend('Reply-to', $this->ReplyTo);
    }
        if($this->Mailer != 'mail') {
      $result .= $this->HeaderLine('Subject', $this->EncodeHeader($this->SecureHeader($this->Subject)));
    }
    if($this->MessageID != '') {
      $result .= $this->HeaderLine('Message-ID',$this->MessageID);
    } else {
      $result .= sprintf("Message-ID: <%s@%s>%s", $uniq_id, $this->ServerHostname(), $this->LE);
    }
    $result .= $this->HeaderLine('X-Priority', $this->Priority);
    $result .= $this->HeaderLine('X-Mailer', 'PHPMailer '.$this->Version.' (phpmailer.codeworxtech.com)');
    if($this->ConfirmReadingTo != '') {
      $result .= $this->HeaderLine('Disposition-Notification-To', '<' . trim($this->ConfirmReadingTo) . '>');
    }
        for($index = 0; $index < count($this->CustomHeader); $index++) {
      $result .= $this->HeaderLine(trim($this->CustomHeader[$index][0]), $this->EncodeHeader(trim($this->CustomHeader[$index][1])));
    }
    if (!$this->sign_key_file) {
      $result .= $this->HeaderLine('MIME-Version', '1.0');
      $result .= $this->GetMailMIME();
    }
    return $result;
  }
  
  public function GetMailMIME() {
    $result = '';
    switch($this->message_type) {
      case 'plain':
        $result .= $this->HeaderLine('Content-Transfer-Encoding', $this->Encoding);
        $result .= sprintf("Content-Type: %s; charset=\"%s\"", $this->ContentType, $this->CharSet);
        break;
      case 'attachments':
      case 'alt_attachments':
        if($this->InlineImageExists()){
          $result .= sprintf("Content-Type: %s;%s\ttype=\"text/html\";%s\tboundary=\"%s\"%s", 'multipart/related', $this->LE, $this->LE, $this->boundary[1], $this->LE);
        } else {
          $result .= $this->HeaderLine('Content-Type', 'multipart/mixed;');
          $result .= $this->TextLine("\tboundary=\"" . $this->boundary[1] . '"');
        }
        break;
      case 'alt':
        $result .= $this->HeaderLine('Content-Type', 'multipart/alternative;');
        $result .= $this->TextLine("\tboundary=\"" . $this->boundary[1] . '"');
        break;
    }
    if($this->Mailer != 'mail') {
      $result .= $this->LE.$this->LE;
    }
    return $result;
  }
  
  public function CreateBody() {
    $body = '';
    if ($this->sign_key_file) {
      $body .= $this->GetMailMIME();
    }
    $this->SetWordWrap();
    switch($this->message_type) {
      case 'alt':
        $body .= $this->GetBoundary($this->boundary[1], '', 'text/plain', '');
        $body .= $this->EncodeString($this->AltBody, $this->Encoding);
        $body .= $this->LE.$this->LE;
        $body .= $this->GetBoundary($this->boundary[1], '', 'text/html', '');
        $body .= $this->EncodeString($this->Body, $this->Encoding);
        $body .= $this->LE.$this->LE;
        $body .= $this->EndBoundary($this->boundary[1]);
        break;
      case 'plain':
        $body .= $this->EncodeString($this->Body, $this->Encoding);
        break;
      case 'attachments':
        $body .= $this->GetBoundary($this->boundary[1], '', '', '');
        $body .= $this->EncodeString($this->Body, $this->Encoding);
        $body .= $this->LE;
        $body .= $this->AttachAll();
        break;
      case 'alt_attachments':
        $body .= sprintf("--%s%s", $this->boundary[1], $this->LE);
        $body .= sprintf("Content-Type: %s;%s" . "\tboundary=\"%s\"%s", 'multipart/alternative', $this->LE, $this->boundary[2], $this->LE.$this->LE);
        $body .= $this->GetBoundary($this->boundary[2], '', 'text/plain', '') . $this->LE;         $body .= $this->EncodeString($this->AltBody, $this->Encoding);
        $body .= $this->LE.$this->LE;
        $body .= $this->GetBoundary($this->boundary[2], '', 'text/html', '') . $this->LE;         $body .= $this->EncodeString($this->Body, $this->Encoding);
        $body .= $this->LE.$this->LE;
        $body .= $this->EndBoundary($this->boundary[2]);
        $body .= $this->AttachAll();
        break;
    }
    if ($this->IsError()) {
      $body = '';
    } elseif ($this->sign_key_file) {
      try {
        $file = tempnam('', 'mail');
        file_put_contents($file, $body);         $signed = tempnam("", "signed");
        if (@openssl_pkcs7_sign($file, $signed, "file://".$this->sign_cert_file, array("file://".$this->sign_key_file, $this->sign_key_pass), NULL)) {
          @unlink($file);
          @unlink($signed);
          $body = file_get_contents($signed);
        } else {
          @unlink($file);
          @unlink($signed);
          throw new phpmailerException($this->Lang("signing").openssl_error_string());
        }
      } catch (phpmailerException $e) {
        $body = '';
        if ($this->exceptions) {
          throw $e;
        }
      }
    }
    return $body;
  }
  
  private function GetBoundary($boundary, $charSet, $contentType, $encoding) {
    $result = '';
    if($charSet == '') {
      $charSet = $this->CharSet;
    }
    if($contentType == '') {
      $contentType = $this->ContentType;
    }
    if($encoding == '') {
      $encoding = $this->Encoding;
    }
    $result .= $this->TextLine('--' . $boundary);
    $result .= sprintf("Content-Type: %s; charset = \"%s\"", $contentType, $charSet);
    $result .= $this->LE;
    $result .= $this->HeaderLine('Content-Transfer-Encoding', $encoding);
    $result .= $this->LE;
    return $result;
  }
  
  private function EndBoundary($boundary) {
    return $this->LE . '--' . $boundary . '--' . $this->LE;
  }
  
  private function SetMessageType() {
    if(count($this->attachment) < 1 && strlen($this->AltBody) < 1) {
      $this->message_type = 'plain';
    } else {
      if(count($this->attachment) > 0) {
        $this->message_type = 'attachments';
      }
      if(strlen($this->AltBody) > 0 && count($this->attachment) < 1) {
        $this->message_type = 'alt';
      }
      if(strlen($this->AltBody) > 0 && count($this->attachment) > 0) {
        $this->message_type = 'alt_attachments';
      }
    }
  }
  
  public function HeaderLine($name, $value) {
    return $name . ': ' . $value . $this->LE;
  }
  
  public function TextLine($value) {
    return $value . $this->LE;
  }
      
  
  public function AddAttachment($path, $name = '', $encoding = 'base64', $type = 'application/octet-stream') {
    try {
      if ( !@is_file($path) ) {
        throw new phpmailerException($this->Lang('file_access') . $path, self::STOP_CONTINUE);
      }
      $filename = basename($path);
      if ( $name == '' ) {
        $name = $filename;
      }
      $this->attachment[] = array(
        0 => $path,
        1 => $filename,
        2 => $name,
        3 => $encoding,
        4 => $type,
        5 => false,          6 => 'attachment',
        7 => 0
      );
    } catch (phpmailerException $e) {
      $this->SetError($e->getMessage());
      if ($this->exceptions) {
        throw $e;
      }      
      if ( $e->getCode() == self::STOP_CRITICAL ) {
        return false;
      }
    }
    return true;
  }
  
  public function GetAttachments() {
    return $this->attachment;
  }
  
  private function AttachAll() {
        $mime = array();
    $cidUniq = array();
    $incl = array();
        foreach ($this->attachment as $attachment) {
            $bString = $attachment[5];
      if ($bString) {
        $string = $attachment[0];
      } else {
        $path = $attachment[0];
      }
      if (in_array($attachment[0], $incl)) { continue; }
      $filename    = $attachment[1];
      $name        = $attachment[2];
      $encoding    = $attachment[3];
      $type        = $attachment[4];
      $disposition = $attachment[6];
      $cid         = $attachment[7];
      $incl[]      = $attachment[0];
      if ( $disposition == 'inline' && isset($cidUniq[$cid]) ) { continue; }
      $cidUniq[$cid] = true;
      $mime[] = sprintf("--%s%s", $this->boundary[1], $this->LE);
      $mime[] = sprintf("Content-Type: %s; name=\"%s\"%s", $type, $this->EncodeHeader($this->SecureHeader($name)), $this->LE);
      $mime[] = sprintf("Content-Transfer-Encoding: %s%s", $encoding, $this->LE);
      if($disposition == 'inline') {
        $mime[] = sprintf("Content-ID: <%s>%s", $cid, $this->LE);
      }
      $mime[] = sprintf("Content-Disposition: %s; filename=\"%s\"%s", $disposition, $this->EncodeHeader($this->SecureHeader($name)), $this->LE.$this->LE);
            if($bString) {
        $mime[] = $this->EncodeString($string, $encoding);
        if($this->IsError()) {
          return '';
        }
        $mime[] = $this->LE.$this->LE;
      } else {
        $mime[] = $this->EncodeFile($path, $encoding);
        if($this->IsError()) {
          return '';
        }
        $mime[] = $this->LE.$this->LE;
      }
    }
    $mime[] = sprintf("--%s--%s", $this->boundary[1], $this->LE);
    return join('', $mime);
  }
  
  private function EncodeFile($path, $encoding = 'base64') {
    try {
      if (!is_readable($path)) {
        throw new phpmailerException($this->Lang('file_open') . $path, self::STOP_CONTINUE);
      }
      if (function_exists('get_magic_quotes')) {
        function get_magic_quotes() {
          return false;
        }
      }
      if (PHP_VERSION < 6) {
        $magic_quotes = get_magic_quotes_runtime();
        set_magic_quotes_runtime(0);
      }
      $file_buffer  = file_get_contents($path);
      $file_buffer  = $this->EncodeString($file_buffer, $encoding);
      if (PHP_VERSION < 6) { set_magic_quotes_runtime($magic_quotes); }
      return $file_buffer;
    } catch (Exception $e) {
      $this->SetError($e->getMessage());
      return '';
    }
  }
  
  public function EncodeString ($str, $encoding = 'base64') {
    $encoded = '';
    switch(strtolower($encoding)) {
      case 'base64':
        $encoded = chunk_split(base64_encode($str), 76, $this->LE);
        break;
      case '7bit':
      case '8bit':
        $encoded = $this->FixEOL($str);
                if (substr($encoded, -(strlen($this->LE))) != $this->LE)
          $encoded .= $this->LE;
        break;
      case 'binary':
        $encoded = $str;
        break;
      case 'quoted-printable':
        $encoded = $this->EncodeQP($str);
        break;
      default:
        $this->SetError($this->Lang('encoding') . $encoding);
        break;
    }
    return $encoded;
  }
  
  public function EncodeHeader($str, $position = 'text') {
    $x = 0;
    switch (strtolower($position)) {
      case 'phrase':
        if (!preg_match('/[\200-\377]/', $str)) {
                    $encoded = addcslashes($str, "\0..\37\177\\\"");
          if (($str == $encoded) && !preg_match('/[^A-Za-z0-9!#$%&\'*+\/=?^_`{|}~ -]/', $str)) {
            return ($encoded);
          } else {
            return ("\"$encoded\"");
          }
        }
        $x = preg_match_all('/[^\040\041\043-\133\135-\176]/', $str, $matches);
        break;
      case 'comment':
        $x = preg_match_all('/[()"]/', $str, $matches);
              case 'text':
      default:
        $x += preg_match_all('/[\000-\010\013\014\016-\037\177-\377]/', $str, $matches);
        break;
    }
    if ($x == 0) {
      return ($str);
    }
    $maxlen = 75 - 7 - strlen($this->CharSet);
        if (strlen($str)/3 < $x) {
      $encoding = 'B';
      if (function_exists('mb_strlen') && $this->HasMultiBytes($str)) {
                        $encoded = $this->Base64EncodeWrapMB($str);
      } else {
        $encoded = base64_encode($str);
        $maxlen -= $maxlen % 4;
        $encoded = trim(chunk_split($encoded, $maxlen, "\n"));
      }
    } else {
      $encoding = 'Q';
      $encoded = $this->EncodeQ($str, $position);
      $encoded = $this->WrapText($encoded, $maxlen, true);
      $encoded = str_replace('='.$this->LE, "\n", trim($encoded));
    }
    $encoded = preg_replace('/^(.*)$/m', " =?".$this->CharSet."?$encoding?\\1?=", $encoded);
    $encoded = trim(str_replace("\n", $this->LE, $encoded));
    return $encoded;
  }
  
  public function HasMultiBytes($str) {
    if (function_exists('mb_strlen')) {
      return (strlen($str) > mb_strlen($str, $this->CharSet));
    } else {       return false;
    }
  }
  
  public function Base64EncodeWrapMB($str) {
    $start = "=?".$this->CharSet."?B?";
    $end = "?=";
    $encoded = "";
    $mb_length = mb_strlen($str, $this->CharSet);
        $length = 75 - strlen($start) - strlen($end);
        $ratio = $mb_length / strlen($str);
        $offset = $avgLength = floor($length * $ratio * .75);
    for ($i = 0; $i < $mb_length; $i += $offset) {
      $lookBack = 0;
      do {
        $offset = $avgLength - $lookBack;
        $chunk = mb_substr($str, $i, $offset, $this->CharSet);
        $chunk = base64_encode($chunk);
        $lookBack++;
      }
      while (strlen($chunk) > $length);
      $encoded .= $chunk . $this->LE;
    }
        $encoded = substr($encoded, 0, -strlen($this->LE));
    return $encoded;
  }
  
  public function EncodeQPphp( $input = '', $line_max = 76, $space_conv = false) {
    $hex = array('0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F');
    $lines = preg_split('/(?:\r\n|\r|\n)/', $input);
    $eol = "\r\n";
    $escape = '=';
    $output = '';
    while( list(, $line) = each($lines) ) {
      $linlen = strlen($line);
      $newline = '';
      for($i = 0; $i < $linlen; $i++) {
        $c = substr( $line, $i, 1 );
        $dec = ord( $c );
        if ( ( $i == 0 ) && ( $dec == 46 ) ) {           $c = '=2E';
        }
        if ( $dec == 32 ) {
          if ( $i == ( $linlen - 1 ) ) {             $c = '=20';
          } else if ( $space_conv ) {
            $c = '=20';
          }
        } elseif ( ($dec == 61) || ($dec < 32 ) || ($dec > 126) ) {           $h2 = floor($dec/16);
          $h1 = floor($dec%16);
          $c = $escape.$hex[$h2].$hex[$h1];
        }
        if ( (strlen($newline) + strlen($c)) >= $line_max ) {           $output .= $newline.$escape.$eol;           $newline = '';
                    if ( $dec == 46 ) {
            $c = '=2E';
          }
        }
        $newline .= $c;
      }       $output .= $newline.$eol;
    }     return $output;
  }
  
  public function EncodeQP($string, $line_max = 76, $space_conv = false) {
    if (function_exists('quoted_printable_encode')) {       return quoted_printable_encode($string);
    }
    $filters = stream_get_filters();
    if (!in_array('convert.*', $filters)) {       return $this->EncodeQPphp($string, $line_max, $space_conv);     }
    $fp = fopen('php://temp/', 'r+');
    $string = preg_replace('/\r\n?/', $this->LE, $string);     $params = array('line-length' => $line_max, 'line-break-chars' => $this->LE);
    $s = stream_filter_append($fp, 'convert.quoted-printable-encode', STREAM_FILTER_READ, $params);
    fputs($fp, $string);
    rewind($fp);
    $out = stream_get_contents($fp);
    stream_filter_remove($s);
    $out = preg_replace('/^\./m', '=2E', $out);     fclose($fp);
    return $out;
  }
  
  public function EncodeQ ($str, $position = 'text') {
        $encoded = preg_replace('/[\r\n]*/', '', $str);
    switch (strtolower($position)) {
      case 'phrase':
        $encoded = preg_replace("/([^A-Za-z0-9!*+\/ -])/e", "'='.sprintf('%02X', ord('\\1'))", $encoded);
        break;
      case 'comment':
        $encoded = preg_replace("/([\(\)\"])/e", "'='.sprintf('%02X', ord('\\1'))", $encoded);
      case 'text':
      default:
                        $encoded = preg_replace('/([\000-\011\013\014\016-\037\075\077\137\177-\377])/e',
              "'='.sprintf('%02X', ord('\\1'))", $encoded);
        break;
    }
        $encoded = str_replace(' ', '_', $encoded);
    return $encoded;
  }
  
  public function AddStringAttachment($string, $filename, $encoding = 'base64', $type = 'application/octet-stream') {
        $this->attachment[] = array(
      0 => $string,
      1 => $filename,
      2 => $filename,
      3 => $encoding,
      4 => $type,
      5 => true,        6 => 'attachment',
      7 => 0
    );
  }
  
  public function AddEmbeddedImage($path, $cid, $name = '', $encoding = 'base64', $type = 'application/octet-stream') {
    if ( !@is_file($path) ) {
      $this->SetError($this->Lang('file_access') . $path);
      return false;
    }
    $filename = basename($path);
    if ( $name == '' ) {
      $name = $filename;
    }
        $this->attachment[] = array(
      0 => $path,
      1 => $filename,
      2 => $name,
      3 => $encoding,
      4 => $type,
      5 => false,        6 => 'inline',
      7 => $cid
    );
    return true;
  }
  
  public function InlineImageExists() {
    foreach($this->attachment as $attachment) {
      if ($attachment[6] == 'inline') {
        return true;
      }
    }
    return false;
  }
      
  
  public function ClearAddresses() {
    foreach($this->to as $to) {
      unset($this->all_recipients[strtolower($to[0])]);
    }
    $this->to = array();
  }
  
  public function ClearCCs() {
    foreach($this->cc as $cc) {
      unset($this->all_recipients[strtolower($cc[0])]);
    }
    $this->cc = array();
  }
  
  public function ClearBCCs() {
    foreach($this->bcc as $bcc) {
      unset($this->all_recipients[strtolower($bcc[0])]);
    }
    $this->bcc = array();
  }
  
  public function ClearReplyTos() {
    $this->ReplyTo = array();
  }
  
  public function ClearAllRecipients() {
    $this->to = array();
    $this->cc = array();
    $this->bcc = array();
    $this->all_recipients = array();
  }
  
  public function ClearAttachments() {
    $this->attachment = array();
  }
  
  public function ClearCustomHeaders() {
    $this->CustomHeader = array();
  }
      
  
  protected function SetError($msg) {
    $this->error_count++;
    if ($this->Mailer == 'smtp' and !is_null($this->smtp)) {
      $lasterror = $this->smtp->getError();
      if (!empty($lasterror) and array_key_exists('smtp_msg', $lasterror)) {
        $msg .= '<p>' . $this->Lang('smtp_error') . $lasterror['smtp_msg'] . "</p>\n";
      }
    }
    $this->ErrorInfo = $msg;
  }
  
  public static function RFCDate() {
    $tz = date('Z');
    $tzs = ($tz < 0) ? '-' : '+';
    $tz = abs($tz);
    $tz = (int)($tz/3600)*100 + ($tz%3600)/60;
    $result = sprintf("%s %s%04d", date('D, j M Y H:i:s'), $tzs, $tz);
    return $result;
  }
  
  private function ServerHostname() {
    if (!empty($this->Hostname)) {
      $result = $this->Hostname;
    } elseif (isset($_SERVER['SERVER_NAME'])) {
      $result = $_SERVER['SERVER_NAME'];
    } else {
      $result = 'localhost.localdomain';
    }
    return $result;
  }
  
  private function Lang($key) {
    if(count($this->language) < 1) {
      $this->SetLanguage('en');     }
    if(isset($this->language[$key])) {
      return $this->language[$key];
    } else {
      return 'Language string failed to load: ' . $key;
    }
  }
  
  public function IsError() {
    return ($this->error_count > 0);
  }
  
  private function FixEOL($str) {
    $str = str_replace("\r\n", "\n", $str);
    $str = str_replace("\r", "\n", $str);
    $str = str_replace("\n", $this->LE, $str);
    return $str;
  }
  
  public function AddCustomHeader($custom_header) {
    $this->CustomHeader[] = explode(':', $custom_header, 2);
  }
  
  public function MsgHTML($message, $basedir = '') {
    preg_match_all("/(src|background)=\"(.*)\"/Ui", $message, $images);
    if(isset($images[2])) {
      foreach($images[2] as $i => $url) {
                if (!preg_match('#^[A-z]+://#',$url)) {
          $filename = basename($url);
          $directory = dirname($url);
          ($directory == '.')?$directory='':'';
          $cid = 'cid:' . md5($filename);
          $ext = pathinfo($filename, PATHINFO_EXTENSION);
          $mimeType  = self::_mime_types($ext);
          if ( strlen($basedir) > 1 && substr($basedir,-1) != '/') { $basedir .= '/'; }
          if ( strlen($directory) > 1 && substr($directory,-1) != '/') { $directory .= '/'; }
          if ( $this->AddEmbeddedImage($basedir.$directory.$filename, md5($filename), $filename, 'base64',$mimeType) ) {
            $message = preg_replace("/".$images[1][$i]."=\"".preg_quote($url, '/')."\"/Ui", $images[1][$i]."=\"".$cid."\"", $message);
          }
        }
      }
    }
    $this->IsHTML(true);
    $this->Body = $message;
    $textMsg = trim(strip_tags(preg_replace('/<(head|title|style|script)[^>]*>.*?<\/\\1>/s','',$message)));
    if (!empty($textMsg) && empty($this->AltBody)) {
      $this->AltBody = html_entity_decode($textMsg);
    }
    if (empty($this->AltBody)) {
      $this->AltBody = 'To view this email message, open it in a program that understands HTML!' . "\n\n";
    }
  }
  
  public static function _mime_types($ext = '') {
    $mimes = array(
      'hqx'   =>  'application/mac-binhex40',
      'cpt'   =>  'application/mac-compactpro',
      'doc'   =>  'application/msword',
      'bin'   =>  'application/macbinary',
      'dms'   =>  'application/octet-stream',
      'lha'   =>  'application/octet-stream',
      'lzh'   =>  'application/octet-stream',
      'exe'   =>  'application/octet-stream',
      'class' =>  'application/octet-stream',
      'psd'   =>  'application/octet-stream',
      'so'    =>  'application/octet-stream',
      'sea'   =>  'application/octet-stream',
      'dll'   =>  'application/octet-stream',
      'oda'   =>  'application/oda',
      'pdf'   =>  'application/pdf',
      'ai'    =>  'application/postscript',
      'eps'   =>  'application/postscript',
      'ps'    =>  'application/postscript',
      'smi'   =>  'application/smil',
      'smil'  =>  'application/smil',
      'mif'   =>  'application/vnd.mif',
      'xls'   =>  'application/vnd.ms-excel',
      'ppt'   =>  'application/vnd.ms-powerpoint',
      'wbxml' =>  'application/vnd.wap.wbxml',
      'wmlc'  =>  'application/vnd.wap.wmlc',
      'dcr'   =>  'application/x-director',
      'dir'   =>  'application/x-director',
      'dxr'   =>  'application/x-director',
      'dvi'   =>  'application/x-dvi',
      'gtar'  =>  'application/x-gtar',
      'php'   =>  'application/x-httpd-php',
      'php4'  =>  'application/x-httpd-php',
      'php3'  =>  'application/x-httpd-php',
      'phtml' =>  'application/x-httpd-php',
      'phps'  =>  'application/x-httpd-php-source',
      'js'    =>  'application/x-javascript',
      'swf'   =>  'application/x-shockwave-flash',
      'sit'   =>  'application/x-stuffit',
      'tar'   =>  'application/x-tar',
      'tgz'   =>  'application/x-tar',
      'xhtml' =>  'application/xhtml+xml',
      'xht'   =>  'application/xhtml+xml',
      'zip'   =>  'application/zip',
      'mid'   =>  'audio/midi',
      'midi'  =>  'audio/midi',
      'mpga'  =>  'audio/mpeg',
      'mp2'   =>  'audio/mpeg',
      'mp3'   =>  'audio/mpeg',
      'aif'   =>  'audio/x-aiff',
      'aiff'  =>  'audio/x-aiff',
      'aifc'  =>  'audio/x-aiff',
      'ram'   =>  'audio/x-pn-realaudio',
      'rm'    =>  'audio/x-pn-realaudio',
      'rpm'   =>  'audio/x-pn-realaudio-plugin',
      'ra'    =>  'audio/x-realaudio',
      'rv'    =>  'video/vnd.rn-realvideo',
      'wav'   =>  'audio/x-wav',
      'bmp'   =>  'image/bmp',
      'gif'   =>  'image/gif',
      'jpeg'  =>  'image/jpeg',
      'jpg'   =>  'image/jpeg',
      'jpe'   =>  'image/jpeg',
      'png'   =>  'image/png',
      'tiff'  =>  'image/tiff',
      'tif'   =>  'image/tiff',
      'css'   =>  'text/css',
      'html'  =>  'text/html',
      'htm'   =>  'text/html',
      'shtml' =>  'text/html',
      'txt'   =>  'text/plain',
      'text'  =>  'text/plain',
      'log'   =>  'text/plain',
      'rtx'   =>  'text/richtext',
      'rtf'   =>  'text/rtf',
      'xml'   =>  'text/xml',
      'xsl'   =>  'text/xml',
      'mpeg'  =>  'video/mpeg',
      'mpg'   =>  'video/mpeg',
      'mpe'   =>  'video/mpeg',
      'qt'    =>  'video/quicktime',
      'mov'   =>  'video/quicktime',
      'avi'   =>  'video/x-msvideo',
      'movie' =>  'video/x-sgi-movie',
      'doc'   =>  'application/msword',
      'word'  =>  'application/msword',
      'xl'    =>  'application/excel',
      'eml'   =>  'message/rfc822'
    );
    return (!isset($mimes[strtolower($ext)])) ? 'application/octet-stream' : $mimes[strtolower($ext)];
  }
  
  public function set($name, $value = '') {
    try {
      if (isset($this->$name) ) {
        $this->$name = $value;
      } else {
        throw new phpmailerException($this->Lang('variable_set') . $name, self::STOP_CRITICAL);
      }
    } catch (Exception $e) {
      $this->SetError($e->getMessage());
      if ($e->getCode() == self::STOP_CRITICAL) {
        return false;
      }
    }
    return true;
  }
  
  public function SecureHeader($str) {
    $str = str_replace("\r", '', $str);
    $str = str_replace("\n", '', $str);
    return trim($str);
  }
  
  public function Sign($cert_filename, $key_filename, $key_pass) {
    $this->sign_cert_file = $cert_filename;
    $this->sign_key_file = $key_filename;
    $this->sign_key_pass = $key_pass;
  }
}
class phpmailerException extends Exception {
  public function errorMessage() {
    $errorMsg = '<strong>' . $this->getMessage() . "</strong><br />\n";
    return $errorMsg;
  }
}
}
namespace phpex\Util\ORG{
class PHPZip {
    private $ctrl_dir = array();
    private $datasec = array();
    
                var $fileList = array();
    public function visitFile($path, $ignore) {
        global $fileList;
        $path = str_replace("\\", "/", $path);
        $fdir = dir($path);
        while (($file = $fdir->read()) !== false) {
            if ($file == '.' || $file == '..') {
                continue;
            }
            $pathSub = preg_replace("*/{2,}*", "/", $path . "/" . $file);  
            if (in_array($pathSub, $ignore)) continue;
            $fileList[] = is_dir($pathSub) ? $pathSub . "/" : $pathSub;
            if (is_dir($pathSub)) {
                $this->visitFile($pathSub);
            }
        }
        $fdir->close();
        return $fileList;
    }
    private function unix2DosTime($unixtime = 0) {
        $timearray = ($unixtime == 0) ? getdate() : getdate($unixtime);
        if ($timearray['year'] < 1980) {
            $timearray['year'] = 1980;
            $timearray['mon'] = 1;
            $timearray['mday'] = 1;
            $timearray['hours'] = 0;
            $timearray['minutes'] = 0;
            $timearray['seconds'] = 0;
        }
        return (($timearray['year'] - 1980) << 25)
        | ($timearray['mon'] << 21)
        | ($timearray['mday'] << 16)
        | ($timearray['hours'] << 11)
        | ($timearray['minutes'] << 5)
        | ($timearray['seconds'] >> 1);
    }
    var $old_offset = 0;
    private function addFile($data, $filename, $time = 0) {
        $filename = str_replace('\\', '/', $filename);
        $dtime = dechex($this->unix2DosTime($time));
        $hexdtime = '\x' . $dtime[6] . $dtime[7]
            . '\x' . $dtime[4] . $dtime[5]
            . '\x' . $dtime[2] . $dtime[3]
            . '\x' . $dtime[0] . $dtime[1];
        eval('$hexdtime = "' . $hexdtime . '";');
        $fr = "\x50\x4b\x03\x04";
        $fr .= "\x14\x00";
        $fr .= "\x00\x00";
        $fr .= "\x08\x00";
        $fr .= $hexdtime;
        $unc_len = strlen($data);
        $crc = crc32($data);
        $zdata = gzcompress($data);
        $c_len = strlen($zdata);
        $zdata = substr(substr($zdata, 0, strlen($zdata) - 4), 2);
        $fr .= pack('V', $crc);
        $fr .= pack('V', $c_len);
        $fr .= pack('V', $unc_len);
        $fr .= pack('v', strlen($filename));
        $fr .= pack('v', 0);
        $fr .= $filename;
        $fr .= $zdata;
        $fr .= pack('V', $crc);
        $fr .= pack('V', $c_len);
        $fr .= pack('V', $unc_len);
        $this->datasec[] = $fr;
        $new_offset = strlen(implode('', $this->datasec));
        $cdrec = "\x50\x4b\x01\x02";
        $cdrec .= "\x00\x00";
        $cdrec .= "\x14\x00";
        $cdrec .= "\x00\x00";
        $cdrec .= "\x08\x00";
        $cdrec .= $hexdtime;
        $cdrec .= pack('V', $crc);
        $cdrec .= pack('V', $c_len);
        $cdrec .= pack('V', $unc_len);
        $cdrec .= pack('v', strlen($filename));
        $cdrec .= pack('v', 0);
        $cdrec .= pack('v', 0);
        $cdrec .= pack('v', 0);
        $cdrec .= pack('v', 0);
        $cdrec .= pack('V', 32);
        $cdrec .= pack('V', $this->old_offset);
        $this->old_offset = $new_offset;
        $cdrec .= $filename;
        $this->ctrl_dir[] = $cdrec;
    }
    var $eof_ctrl_dir = "\x50\x4b\x05\x06\x00\x00\x00\x00";
    private function file() {
        $data = implode('', $this->datasec);
        $ctrldir = implode('', $this->ctrl_dir);
        return $data
        . $ctrldir
        . $this->eof_ctrl_dir
        . pack('v', sizeof($this->ctrl_dir))
        . pack('v', sizeof($this->ctrl_dir))
        . pack('V', strlen($ctrldir))
        . pack('V', strlen($data))
        . "\x00\x00";
    }
                            public function Zip($dir, $saveName, array $ignore = array()) {
        if (@!function_exists('gzcompress')) {
            return;
        }
        ob_end_clean();
        $filelist = $this->visitFile($dir, $ignore);
        if (count($filelist) == 0) {
            return;
        }
        foreach ($filelist as $file) {
            if (!file_exists($file) || !is_file($file)) {
                continue;
            }
            $fd = fopen($file, "rb");
            $content = @fread($fd, filesize($file));
            fclose($fd);
                                    $file = substr($file, strlen($dir));
            if (substr($file, 0, 1) == "\\" || substr($file, 0, 1) == "/") {
                $file = substr($file, 1);
            }
            $this->addFile($content, $file);
        }
        $out = $this->file();
        $fp = fopen($saveName, "wb");
        fwrite($fp, $out, strlen($out));
        fclose($fp);
    }
                            public function ZipAndDownload($dir, array $ignore = array()) {
        if (@!function_exists('gzcompress')) {
            return;
        }
        ob_end_clean();
        $filelist = $this->visitFile($dir, $ignore);
        if (count($filelist) == 0) {
            return;
        }
        foreach ($filelist as $file) {
            if (!file_exists($file) || !is_file($file)) {
                continue;
            }
            $fd = fopen($file, "rb");
            $content = @fread($fd, filesize($file));
            fclose($fd);
                                    $file = substr($file, strlen($dir));
            if (substr($file, 0, 1) == "\\" || substr($file, 0, 1) == "/") {
                $file = substr($file, 1);
            }
            $this->addFile($content, $file);
        }
        $out = $this->file();
        @header('Content-Encoding: none');
        @header('Content-Type: application/zip');
        @header('Content-Disposition: attachment ; filename=Farticle' . date("YmdHis", time()) . '.zip');
        @header('Pragma: no-cache');
        @header('Expires: 0');
        print($out);
    }
    
                        private function ReadCentralDir($zip, $zipfile) {
        $size = filesize($zipfile);
        $max_size = ($size < 277) ? $size : 277;
        @fseek($zip, $size - $max_size);
        $pos = ftell($zip);
        $bytes = 0x00000000;
        while ($pos < $size) {
            $byte = @fread($zip, 1);
            $bytes = ($bytes << 8) | Ord($byte);
            $pos++;
            if ($bytes == 0x504b0506) {
                break;
            }
        }
        $data = unpack('vdisk/vdisk_start/vdisk_entries/ventries/Vsize/Voffset/vcomment_size', fread($zip, 18));
        $centd['comment'] = ($data['comment_size'] != 0) ? fread($zip, $data['comment_size']) : '';          $centd['entries'] = $data['entries'];
        $centd['disk_entries'] = $data['disk_entries'];
        $centd['offset'] = $data['offset'];
        $centd['disk_start'] = $data['disk_start'];
        $centd['size'] = $data['size'];
        $centd['disk'] = $data['disk'];
        return $centd;
    }
    private function ReadCentralFileHeaders($zip) {
        $binary_data = fread($zip, 46);
        $header = unpack('vchkid/vid/vversion/vversion_extracted/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len/vcomment_len/vdisk/vinternal/Vexternal/Voffset', $binary_data);
        $header['filename'] = ($header['filename_len'] != 0) ? fread($zip, $header['filename_len']) : '';
        $header['extra'] = ($header['extra_len'] != 0) ? fread($zip, $header['extra_len']) : '';
        $header['comment'] = ($header['comment_len'] != 0) ? fread($zip, $header['comment_len']) : '';
        if ($header['mdate'] && $header['mtime']) {
            $hour = ($header['mtime'] & 0xF800) >> 11;
            $minute = ($header['mtime'] & 0x07E0) >> 5;
            $seconde = ($header['mtime'] & 0x001F) * 2;
            $year = (($header['mdate'] & 0xFE00) >> 9) + 1980;
            $month = ($header['mdate'] & 0x01E0) >> 5;
            $day = $header['mdate'] & 0x001F;
            $header['mtime'] = mktime($hour, $minute, $seconde, $month, $day, $year);
        } else {
            $header['mtime'] = time();
        }
        $header['stored_filename'] = $header['filename'];
        $header['status'] = 'ok';
        if (substr($header['filename'], -1) == '/') {
            $header['external'] = 0x41FF0010;
        }          return $header;
    }
    private function ReadFileHeader($zip) {
        $binary_data = fread($zip, 30);
        $data = unpack('vchk/vid/vversion/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len', $binary_data);
        $header['filename'] = fread($zip, $data['filename_len']);
        $header['extra'] = ($data['extra_len'] != 0) ? fread($zip, $data['extra_len']) : '';
        $header['compression'] = $data['compression'];
        $header['size'] = $data['size'];
        $header['compressed_size'] = $data['compressed_size'];
        $header['crc'] = $data['crc'];
        $header['flag'] = $data['flag'];
        $header['mdate'] = $data['mdate'];
        $header['mtime'] = $data['mtime'];
        if ($header['mdate'] && $header['mtime']) {
            $hour = ($header['mtime'] & 0xF800) >> 11;
            $minute = ($header['mtime'] & 0x07E0) >> 5;
            $seconde = ($header['mtime'] & 0x001F) * 2;
            $year = (($header['mdate'] & 0xFE00) >> 9) + 1980;
            $month = ($header['mdate'] & 0x01E0) >> 5;
            $day = $header['mdate'] & 0x001F;
            $header['mtime'] = mktime($hour, $minute, $seconde, $month, $day, $year);
        } else {
            $header['mtime'] = time();
        }
        $header['stored_filename'] = $header['filename'];
        $header['status'] = "ok";
        return $header;
    }
    private function ExtractFile($header, $to, $zip) {
        $header = $this->readfileheader($zip);
        if (substr($to, -1) != "/") {
            $to .= "/";
        }
        if (!@is_dir($to)) {
            @mkdir($to, 0777);
        }
        $pth = explode("/", dirname($header['filename']));
        for ($i = 0; isset($pth[$i]); $i++) {
            if (!$pth[$i]) {
                continue;
            }
            $pthss .= $pth[$i] . "/";
            if (!is_dir($to . $pthss)) {
                @mkdir($to . $pthss, 0777);
            }
        }
        if (!($header['external'] == 0x41FF0010) && !($header['external'] == 16)) {
            if ($header['compression'] == 0) {
                $fp = @fopen($to . $header['filename'], 'wb');
                if (!$fp) {
                    return (-1);
                }
                $size = $header['compressed_size'];
                while ($size != 0) {
                    $read_size = ($size < 2048 ? $size : 2048);
                    $buffer = fread($zip, $read_size);
                    $binary_data = pack('a' . $read_size, $buffer);
                    @fwrite($fp, $binary_data, $read_size);
                    $size -= $read_size;
                }
                fclose($fp);
                touch($to . $header['filename'], $header['mtime']);
            } else {
                $fp = @fopen($to . $header['filename'] . '.gz', 'wb');
                if (!$fp) {
                    return (-1);
                }
                $binary_data = pack('va1a1Va1a1', 0x8b1f, Chr($header['compression']), Chr(0x00), time(), Chr(0x00), Chr(3));
                fwrite($fp, $binary_data, 10);
                $size = $header['compressed_size'];
                while ($size != 0) {
                    $read_size = ($size < 1024 ? $size : 1024);
                    $buffer = fread($zip, $read_size);
                    $binary_data = pack('a' . $read_size, $buffer);
                    @fwrite($fp, $binary_data, $read_size);
                    $size -= $read_size;
                }
                $binary_data = pack('VV', $header['crc'], $header['size']);
                fwrite($fp, $binary_data, 8);
                fclose($fp);
                $gzp = @gzopen($to . $header['filename'] . '.gz', 'rb') or die("Cette archive est compress!");
                if (!$gzp) {
                    return (-2);
                }
                $fp = @fopen($to . $header['filename'], 'wb');
                if (!$fp) {
                    return (-1);
                }
                $size = $header['size'];
                while ($size != 0) {
                    $read_size = ($size < 2048 ? $size : 2048);
                    $buffer = gzread($gzp, $read_size);
                    $binary_data = pack('a' . $read_size, $buffer);
                    @fwrite($fp, $binary_data, $read_size);
                    $size -= $read_size;
                }
                fclose($fp);
                gzclose($gzp);
                touch($to . $header['filename'], $header['mtime']);
                @unlink($to . $header['filename'] . '.gz');
            }
        }
        return true;
    }
                                                                                                                                        public function unZip($zipfile, $to, $index = Array(-1)) {
        $ok = 0;
        $zip = @fopen($zipfile, 'rb');
        if (!$zip) {
            return (-1);
        }
        $cdir = $this->ReadCentralDir($zip, $zipfile);
        $pos_entry = $cdir['offset'];
        if (!is_array($index)) {
            $index = array($index);
        }
        for ($i = 0; $index[$i]; $i++) {
            if (intval($index[$i]) != $index[$i] || $index[$i] > $cdir['entries']) {
                return (-1);
            }
        }
        for ($i = 0; $i < $cdir['entries']; $i++) {
            @fseek($zip, $pos_entry);
            $header = $this->ReadCentralFileHeaders($zip);
            $header['index'] = $i;
            $pos_entry = ftell($zip);
            @rewind($zip);
            fseek($zip, $header['offset']);
            if (in_array("-1", $index) || in_array($i, $index)) {
                $stat[$header['filename']] = $this->ExtractFile($header, $to, $zip);
            }
        }
        fclose($zip);
        return $stat;
    }
    
                                                    public function GetZipInnerFilesInfo($zipfile) {
        $zip = @fopen($zipfile, 'rb');
        if (!$zip) {
            return (0);
        }
        $centd = $this->ReadCentralDir($zip, $zipfile);
        @rewind($zip);
        @fseek($zip, $centd['offset']);
        $ret = array();
        for ($i = 0; $i < $centd['entries']; $i++) {
            $header = $this->ReadCentralFileHeaders($zip);
            $header['index'] = $i;
            $info = array(
                'filename' => $header['filename'],                                   'stored_filename' => $header['stored_filename'],                            'size' => $header['size'],                                       'compressed_size' => $header['compressed_size'],                            'crc' => strtoupper(dechex($header['crc'])),                    'mtime' => date("Y-m-d H:i:s", $header['mtime']),                  'comment' => $header['comment'],                                    'folder' => ($header['external'] == 0x41FF0010 || $header['external'] == 16) ? 1 : 0,                  'index' => $header['index'],                                      'status' => $header['status']                                  );
            $ret[] = $info;
            unset($header);
        }
        fclose($zip);
        return $ret;
    }
                            public function GetZipComment($zipfile) {
        $zip = @fopen($zipfile, 'rb');
        if (!$zip) {
            return (0);
        }
        $centd = $this->ReadCentralDir($zip, $zipfile);
        fclose($zip);
        return $centd[comment];
    }
}
}
namespace phpex\Util\ORG{
class Page {
    protected $options = array(
        'totalRows' => 0,
        'listRows' => 20,
        'current' => 1,
        'parameter' => 1,
        'var_page' => "p",
        'url' => "",
    );
    protected $callback;
    
    public $rollPage = 5;
    
    public $listRows = 20;
    
    public $firstRow = 0;
    
    protected $totalPages;
    
    protected $totalRows;
    
    protected $nowPage;
    
    protected $coolPages;
    
    protected $varPage;
    
    protected $parameter;
    
    public $wrapperTag = "<ul>__STRING__</ul>";
    
    public $listTag = "<li>__STRING__</li>";
    
    public $pageInfo = '<div class="pageInfo">共__TOTAL__条记录，每页显示__PAGESIZE__条，当前__CURRENTPAGE__/__PAGETOTAL__页</div>';
    
    public $listActiveTag = "<li class='active'>__STRING__</li>";
    
    public $emptyHide = array('prevRoll', 'nextRoll');
    
    public $pagination = 'firstPage|prevRoll|prevPage|linkPage|nextPage|nextRoll|endPage';
    
    public $replaces = array(
        '__first__' => '第一页',
        '__end__' => '最后一页',
        '__prev__' => '上一页',
        '__next__' => '下一页',
        '__prevRoll__' => '前__ROLL__页',
        '__nextRoll__' => '后__ROLL__页',
    );
    public function clear() {
        
    }
    public function callback($callback) {
        is_callable($callback) and $this->callback = $callback;
    }
    public function showEvent() {
        if (is_callable($this->callback)) {
            return call_user_func($this->callback, $this);
        }
        return false;
    }
    public function options(array $options = array()) {
        $this->options = array_merge($this->options, $options);
    }
    public function setTotal($total) {
        $this->options["totalRows"] = $total;
    }
    
    private function parameter($totalRows, $listRows = '', $current = "", $parameter = '', $var_page = 'p') {
        $this->totalRows = $totalRows;
        $this->parameter = $parameter;
        $this->varPage = $var_page;
        if (!empty($listRows)) {
            $this->listRows = intval($listRows);
        }
        $this->totalPages = ceil($this->totalRows / $this->listRows);          $this->coolPages = ceil($this->totalPages / $this->rollPage);
        $this->nowPage = !empty($current) ? intval($current) : 1;
        if ($this->nowPage < 1) {
            $this->nowPage = 1;
        } elseif (!empty($this->totalPages) && $this->nowPage > $this->totalPages) {
            $this->nowPage = $this->totalPages;
        }       
        $this->firstRow = $this->listRows * ($this->nowPage - 1);
    }
    public function getTotal() {
        return $this->totalPages;
    }
    
    public function show() {
        $this->parameter($this->options['totalRows'], $this->options['listRows'], $this->options['current'], $this->options['parameter'], $this->options['var_page']);
        if (0 == $this->totalRows)
            return '';
        $p = $this->varPage;
        $nowCoolPage = ceil($this->nowPage / $this->rollPage);
        $url = $this->options["url"]? : $_SERVER['REQUEST_URI'];
        if (preg_match("/([\?&]$p\=)\d+/", $url)) {
            $url = preg_replace("/([\?&]$p\=)\d+/", '\\1__PAGE__', $url);
        } elseif (preg_match("/\?/", $url)) {
            $url.="&$p=__PAGE__";
        } else {
            $url.="?$p=__PAGE__";
        }
        $urls = parse_url($url);
        
        parse_str($urls['query'], $query);
       
        $query = array_merge((array) $query, (array) $this->parameter);
        $query = array_filter($query, function($v) {
            return trim($v) !== "";
        });
        $url = isset($urls["scheme"]) ? $urls["scheme"] . "://" : "";
        $url .= isset($urls["host"]) ? $urls["host"] : "";
        $url .= isset($urls["user"]) ? $urls["user"] : "";
        $url .= isset($urls["pass"]) ? $urls["pass"] : "";
        $url .= isset($urls["path"]) ? $urls["path"] : "";
        $url .= "?" . http_build_query($query);
        $pagination = array();
        if ($this->nowPage == 0) {
            $pagination['firstPage'] = in_array('firstPage', $this->emptyHide) ? '' : '<span>__first__</span>';
        } else {
            $pagination['firstPage'] = '<a href="' . str_replace('__PAGE__', 1, $url) . '">__first__</a>';
        }
        if ($this->nowPage >= $this->totalPages) {
            $pagination['endPage'] = in_array('endPage', $this->emptyHide) ? '' : '<span>__end__</span>';
        } else {
            $pagination['endPage'] = '<a href="' . str_replace('__PAGE__', $this->totalPages, $url) . '">__end__</a>';
        }
        $upRow = $this->nowPage - 1;
        $downRow = $this->nowPage + 1;
        if ($upRow > 0) {
            $pagination['prevPage'] = '<a href="' . str_replace('__PAGE__', $upRow, $url) . '">__prev__</a>';
        } else {
            $pagination['prevPage'] = in_array('prevPage', $this->emptyHide) ? '' : '<span>__prev__</span>';
        }
        if ($downRow <= $this->totalPages) {
            $pagination['nextPage'] = '<a href="' . str_replace('__PAGE__', $downRow, $url) . '">__next__</a>';
        } else {
            $pagination['nextPage'] = in_array('nextPage', $this->emptyHide) ? '' : '<span>__next__</span>';
        }
        if ($nowCoolPage > 1) {
            $preRow = $this->nowPage - $this->rollPage;
            $pagination['prevRoll'] = "<a href='" . str_replace('__PAGE__', $preRow, $url) . "' >__prevRoll__</a>";
        } else {
            $pagination['prevRoll'] = in_array('prevRoll', $this->emptyHide) ? '' : '<span>__prevRoll__</span>';
        }
        if ($nowCoolPage < $this->coolPages) {
            $nextRow = $this->nowPage + $this->rollPage;
            $pagination['nextRoll'] = "<a href='" . str_replace('__PAGE__', $nextRow, $url) . "' >__nextRoll__</a>";
        } else {
            $pagination['nextRoll'] = in_array('nextRoll', $this->emptyHide) ? '' : '<span>__nextRoll__</span>';
        }
        $pagination['linkPage'] = "";
        for ($i = 1; $i <= $this->rollPage; $i++) {
            $page = ($nowCoolPage - 1) * $this->rollPage + $i;
            if ($page != $this->nowPage) {
                if ($page <= $this->totalPages) {
                    $links = "<a href='" . str_replace('__PAGE__', $page, $url) . "'>" . $page . "</a>";
                    $pagination['linkPage'] .=str_replace("__STRING__", $links, $this->listTag);
                } else {
                    break;
                }
            } else {
                $pagination['linkPage'] .= str_replace("__STRING__", "<span>$page</span>", $this->listActiveTag);
            }
        }
        $widgets = explode("|", $this->pagination);
        $pageStr = "";
        foreach ($widgets as $widget) {
            if ($pagination[$widget])
                $pageStr.=$widget == "linkPage" ? $pagination[$widget] : str_replace('__STRING__', $pagination[$widget], $this->listTag);
        }
        $search = array_keys($this->replaces);
        $pageStr = str_replace($search, $this->replaces, $pageStr);
        $pageStr = str_replace("__ROLL__", $this->rollPage, $pageStr);
        return str_replace('__STRING__', $pageStr, $this->wrapperTag);
    }
    public function pageInfo() {
        $searchs = array('__TOTAL__', '__PAGESIZE__', '__CURRENTPAGE__', '__PAGETOTAL__');
        $replaces = array($this->totalRows, $this->listRows, $this->nowPage, $this->totalPages);
        return str_replace($searchs, $replaces, $this->pageInfo);
    }
    public function pageLimit($autourl, $currentSize, $tpl = "每页显示__STRING__条", $limitlists = array(3, 5, 8, 10, 12, 15, 20, 30, 50, 100, 120, 150, 300)) {
        $pagestr = "<select style='width:50px' onchange=\"location.href='" . $autourl . "?pagesize='+this.value\">";
        foreach ($limitlists as $v) {
            if ($v == $currentSize) {
                $pagestr .= "<option value=\"$v\" selected=\"selected\">$v</option>";
            } else {
                $pagestr .= "<option value=\"$v\">$v</option>";
            }
        }
        $pagestr .= "</select>";
        return str_replace("__STRING__", $pagestr, $tpl);
    }
}
}
namespace phpex\Util\ORG{
use phpex\Util\Yaml\Yaml;
use phpex\Util\Xml\XmlParse;
class Parse {
    private $cachePath;
    private function getCachePath() {
        if (null === $this->cachePath)
            $this->cachePath = main()->getRuntime() . "/Temp/parseFile";
        return $this->cachePath;
    }
    
    public function parseFile($path) {
        if (is_file($path))
            $pathinfo = pathinfo($path);
        else {
            return array();
        }
        $parseCachePath = $this->getCachePath();
        if (!is_dir($parseCachePath)) {
            mkdir($parseCachePath, 0777, true);
        }
        $key = md5($path);
        $cachePath = $parseCachePath . "/" . $key . ".php";
        $handle = fopen($cachePath, "c+");
        if (!$handle) {
            E("Unable to open or create file '%s'", $cachePath);
        }
        $stat = fstat($handle);
        if ($stat["size"] > 0 && filemtime($path) <= $stat['mtime']) {
            return include $cachePath;
        }
        switch (strtolower($pathinfo['extension'])) {
            case "yml":
                $parse = $this->parseyaml($path);
                break;
            case "json":
                $parse = $this->parsejson($path);
                break;
            case "xml":
                $parse = $this->parsexml($path);
                break;
            case "php":
                $parse = $this->parsephp($path);
                break;
            default:
                $parse = false;
        }
        ftruncate($handle, 0);
        flock($handle, LOCK_EX | LOCK_NB);
        $content = sprintf("<?php\n //parse cache:%s \nreturn %s ;", $path, var_export($parse, true));
        fwrite($handle, $content, strlen($content));
        flock($handle, LOCK_UN);
        return $parse;
    }
    
    function parseString($input, $extension = "yml") {
        switch (strtolower($extension)) {
            case "yml":
                return $this->parseyaml($input);
            case "json":
                return $this->parsejson($input);
            case "xml":
                return $this->parsexml($input);
            case "php":
                return $this->parsephp($input);
            default:
                return false;
        }
    }
    
    function parseyaml($input, $type = 'file') {
        $configs = Yaml::load($input);
        return (array) $configs;
    }
    
    function parsejson($input, $type = 'file') {
        $configs = ($type == "file") ? json_decode(file_get_contents($input), true) : json_decode($input, true);
        return (array) $configs;
    }
    
    function parsexml($input, $type = 'file') {
        $configs = ($type == "file") ? XmlParse::xmlLoad($input) : XmlParse::xmlLoadString($input);
        return (array) $configs;
    }
    
    function parsephp($input, $type = 'file') {
        $configs = ($type == "file") ? require $input : eval($input);
        return (array) $configs;
    }
}
}
namespace phpex\Util\ORG{
class SMTP {
  
  public $SMTP_PORT = 25;
  
  public $CRLF = "\r\n";
  
  public $do_debug;       
  
  public $do_verp = false;
      
  private $smtp_conn;   private $error;       private $helo_rply; 
  
  public function __construct() {
    $this->smtp_conn = 0;
    $this->error = null;
    $this->helo_rply = null;
    $this->do_debug = 0;
  }
      
  
  public function Connect($host, $port = 0, $tval = 30) {
        $this->error = null;
        if($this->connected()) {
            $this->error = array("error" => "Already connected to a server");
      return false;
    }
    if(empty($port)) {
      $port = $this->SMTP_PORT;
    }
        $this->smtp_conn = @fsockopen($host,                                     $port,                                     $errno,                                    $errstr,                                   $tval);           if(empty($this->smtp_conn)) {
      $this->error = array("error" => "Failed to connect to server",
                           "errno" => $errno,
                           "errstr" => $errstr);
      if($this->do_debug >= 1) {
              }
      return false;
    }
            if(substr(PHP_OS, 0, 3) != "WIN")
     socket_set_timeout($this->smtp_conn, $tval, 0);
        $announce = $this->get_lines();
    if($this->do_debug >= 2) {
          }
    return true;
  }
  
  public function StartTLS() {
    $this->error = null; 
    if(!$this->connected()) {
      $this->error = array("error" => "Called StartTLS() without being connected");
      return false;
    }
    fputs($this->smtp_conn,"STARTTLS" . $this->CRLF);
    $rply = $this->get_lines();
    $code = substr($rply,0,3);
    if($this->do_debug >= 2) {
          }
    if($code != 220) {
      $this->error =
         array("error"     => "STARTTLS not accepted from server",
               "smtp_code" => $code,
               "smtp_msg"  => substr($rply,4));
      if($this->do_debug >= 1) {
              }
      return false;
    }
        if(!stream_socket_enable_crypto($this->smtp_conn, true, STREAM_CRYPTO_METHOD_TLS_CLIENT)) {
      return false;
    }
    return true;
  }
  
  public function Authenticate($username, $password) {
        fputs($this->smtp_conn,"AUTH LOGIN" . $this->CRLF);
    $rply = $this->get_lines();
    $code = substr($rply,0,3);
    if($code != 334) {
      $this->error =
        array("error" => "AUTH not accepted from server",
              "smtp_code" => $code,
              "smtp_msg" => substr($rply,4));
      if($this->do_debug >= 1) {
              }
      return false;
    }
        fputs($this->smtp_conn, base64_encode($username) . $this->CRLF);
    $rply = $this->get_lines();
    $code = substr($rply,0,3);
    if($code != 334) {
      $this->error =
        array("error" => "Username not accepted from server",
              "smtp_code" => $code,
              "smtp_msg" => substr($rply,4));
      if($this->do_debug >= 1) {
              }
      return false;
    }
        fputs($this->smtp_conn, base64_encode($password) . $this->CRLF);
    $rply = $this->get_lines();
    $code = substr($rply,0,3);
    if($code != 235) {
      $this->error =
        array("error" => "Password not accepted from server",
              "smtp_code" => $code,
              "smtp_msg" => substr($rply,4));
      if($this->do_debug >= 1) {
              }
      return false;
    }
    return true;
  }
  
  public function Connected() {
    if(!empty($this->smtp_conn)) {
      $sock_status = socket_get_status($this->smtp_conn);
      if($sock_status["eof"]) {
                if($this->do_debug >= 1) {
                    }
        $this->Close();
        return false;
      }
      return true;     }
    return false;
  }
  
  public function Close() {
    $this->error = null;     $this->helo_rply = null;
    if(!empty($this->smtp_conn)) {
            fclose($this->smtp_conn);
      $this->smtp_conn = 0;
    }
  }
      
  
  public function Data($msg_data) {
    $this->error = null; 
    if(!$this->connected()) {
      $this->error = array(
              "error" => "Called Data() without being connected");
      return false;
    }
    fputs($this->smtp_conn,"DATA" . $this->CRLF);
    $rply = $this->get_lines();
    $code = substr($rply,0,3);
    if($this->do_debug >= 2) {
          }
    if($code != 354) {
      $this->error =
        array("error" => "DATA command not accepted from server",
              "smtp_code" => $code,
              "smtp_msg" => substr($rply,4));
      if($this->do_debug >= 1) {
              }
      return false;
    }
    
        $msg_data = str_replace("\r\n","\n",$msg_data);
    $msg_data = str_replace("\r","\n",$msg_data);
    $lines = explode("\n",$msg_data);
    
    $field = substr($lines[0],0,strpos($lines[0],":"));
    $in_headers = false;
    if(!empty($field) && !strstr($field," ")) {
      $in_headers = true;
    }
    $max_line_length = 998; 
    while(list(,$line) = @each($lines)) {
      $lines_out = null;
      if($line == "" && $in_headers) {
        $in_headers = false;
      }
            while(strlen($line) > $max_line_length) {
        $pos = strrpos(substr($line,0,$max_line_length)," ");
                if(!$pos) {
          $pos = $max_line_length - 1;
          $lines_out[] = substr($line,0,$pos);
          $line = substr($line,$pos);
        } else {
          $lines_out[] = substr($line,0,$pos);
          $line = substr($line,$pos + 1);
        }
        
        if($in_headers) {
          $line = "\t" . $line;
        }
      }
      $lines_out[] = $line;
            while(list(,$line_out) = @each($lines_out)) {
        if(strlen($line_out) > 0)
        {
          if(substr($line_out, 0, 1) == ".") {
            $line_out = "." . $line_out;
          }
        }
        fputs($this->smtp_conn,$line_out . $this->CRLF);
      }
    }
        fputs($this->smtp_conn, $this->CRLF . "." . $this->CRLF);
    $rply = $this->get_lines();
    $code = substr($rply,0,3);
    if($this->do_debug >= 2) {
          }
    if($code != 250) {
      $this->error =
        array("error" => "DATA not accepted from server",
              "smtp_code" => $code,
              "smtp_msg" => substr($rply,4));
      if($this->do_debug >= 1) {
              }
      return false;
    }
    return true;
  }
  
  public function Hello($host = '') {
    $this->error = null; 
    if(!$this->connected()) {
      $this->error = array(
            "error" => "Called Hello() without being connected");
      return false;
    }
        if(empty($host)) {
            $host = "localhost";
    }
        if(!$this->SendHello("EHLO", $host)) {
      if(!$this->SendHello("HELO", $host)) {
        return false;
      }
    }
    return true;
  }
  
  private function SendHello($hello, $host) {
    fputs($this->smtp_conn, $hello . " " . $host . $this->CRLF);
    $rply = $this->get_lines();
    $code = substr($rply,0,3);
    if($this->do_debug >= 2) {
          }
    if($code != 250) {
      $this->error =
        array("error" => $hello . " not accepted from server",
              "smtp_code" => $code,
              "smtp_msg" => substr($rply,4));
      if($this->do_debug >= 1) {
              }
      return false;
    }
    $this->helo_rply = $rply;
    return true;
  }
  
  public function Mail($from) {
    $this->error = null; 
    if(!$this->connected()) {
      $this->error = array(
              "error" => "Called Mail() without being connected");
      return false;
    }
    $useVerp = ($this->do_verp ? "XVERP" : "");
    fputs($this->smtp_conn,"MAIL FROM:<" . $from . ">" . $useVerp . $this->CRLF);
    $rply = $this->get_lines();
    $code = substr($rply,0,3);
    if($this->do_debug >= 2) {
          }
    if($code != 250) {
      $this->error =
        array("error" => "MAIL not accepted from server",
              "smtp_code" => $code,
              "smtp_msg" => substr($rply,4));
      if($this->do_debug >= 1) {
              }
      return false;
    }
    return true;
  }
  
  public function Quit($close_on_error = true) {
    $this->error = null; 
    if(!$this->connected()) {
      $this->error = array(
              "error" => "Called Quit() without being connected");
      return false;
    }
        fputs($this->smtp_conn,"quit" . $this->CRLF);
        $byemsg = $this->get_lines();
    if($this->do_debug >= 2) {
          }
    $rval = true;
    $e = null;
    $code = substr($byemsg,0,3);
    if($code != 221) {
            $e = array("error" => "SMTP server rejected quit command",
                 "smtp_code" => $code,
                 "smtp_rply" => substr($byemsg,4));
      $rval = false;
      if($this->do_debug >= 1) {
              }
    }
    if(empty($e) || $close_on_error) {
      $this->Close();
    }
    return $rval;
  }
  
  public function Recipient($to) {
    $this->error = null; 
    if(!$this->connected()) {
      $this->error = array(
              "error" => "Called Recipient() without being connected");
      return false;
    }
    fputs($this->smtp_conn,"RCPT TO:<" . $to . ">" . $this->CRLF);
    $rply = $this->get_lines();
    $code = substr($rply,0,3);
    if($this->do_debug >= 2) {
          }
    if($code != 250 && $code != 251) {
      $this->error =
        array("error" => "RCPT not accepted from server",
              "smtp_code" => $code,
              "smtp_msg" => substr($rply,4));
      if($this->do_debug >= 1) {
              }
      return false;
    }
    return true;
  }
  
  public function Reset() {
    $this->error = null; 
    if(!$this->connected()) {
      $this->error = array(
              "error" => "Called Reset() without being connected");
      return false;
    }
    fputs($this->smtp_conn,"RSET" . $this->CRLF);
    $rply = $this->get_lines();
    $code = substr($rply,0,3);
    if($this->do_debug >= 2) {
          }
    if($code != 250) {
      $this->error =
        array("error" => "RSET failed",
              "smtp_code" => $code,
              "smtp_msg" => substr($rply,4));
      if($this->do_debug >= 1) {
              }
      return false;
    }
    return true;
  }
  
  public function SendAndMail($from) {
    $this->error = null; 
    if(!$this->connected()) {
      $this->error = array(
          "error" => "Called SendAndMail() without being connected");
      return false;
    }
    fputs($this->smtp_conn,"SAML FROM:" . $from . $this->CRLF);
    $rply = $this->get_lines();
    $code = substr($rply,0,3);
    if($this->do_debug >= 2) {
          }
    if($code != 250) {
      $this->error =
        array("error" => "SAML not accepted from server",
              "smtp_code" => $code,
              "smtp_msg" => substr($rply,4));
      if($this->do_debug >= 1) {
              }
      return false;
    }
    return true;
  }
  
  public function Turn() {
    $this->error = array("error" => "This method, TURN, of the SMTP ".
                                    "is not implemented");
    if($this->do_debug >= 1) {
          }
    return false;
  }
  
  public function getError() {
    return $this->error;
  }
      
  
  private function get_lines() {
    $data = "";
    while($str = @fgets($this->smtp_conn,515)) {
      if($this->do_debug >= 4) {
                      }
      $data .= $str;
      if($this->do_debug >= 4) {
              }
            if(substr($str,3,1) == " ") { break; }
    }
    return $data;
  }
}
}
namespace phpex\Util\ORG{
class Seo {
    private $title,$subTitle, $keywords, $description;
    private $defaultTitle,$defaultSubTitle, $defaultKeywords, $defaultDescription;
    
    private $seoParse;
    public function setParse(SeoParseInterface $seoparse) {
        $this->seoParse = $seoparse;
    }
    public function getTitle() {
        if ($this->title)
            return $this->title;
        if ($this->seoParse && $this->seoParse->getTitle()) {
            $this->title = $this->seoParse->getTitle();
            return $this->title;
        }
        if (!$this->defaultTitle) {
            $this->defaultTitle = C("seo.title");
        }
        return $this->defaultTitle;
    }
    
    public function getSubTitle() {
        if ($this->subTitle)
            return $this->subTitle;
        if ($this->seoParse && $this->seoParse->getSubTitle()) {
            $this->subTitle = $this->seoParse->getSubTitle();
            return $this->subTitle;
        }
        if (!$this->defaultSubTitle) {
            $this->defaultSubTitle = C("seo.subTitle");
        }
        return $this->defaultSubTitle;
    }
    public function getKeywords() {
        if ($this->keywords)
            return $this->keywords;
        if ($this->seoParse && $this->seoParse->getKeywords()) {
            $this->keywords = $this->seoParse->getKeywords();
            return $this->keywords;
        }
        if (!$this->defaultKeywords) {
            $this->defaultKeywords = C("seo.keywords");
        }
        return $this->defaultKeywords;
    }
    public function getDescription() {
        if ($this->description)
            return $this->description;
        if ($this->seoParse && $this->seoParse->getKeywords()) {
            $this->description = $this->seoParse->getDescription();
            return $this->description;
        }
        if (!$this->defaultDescription) {
            $this->defaultDescription = C("seo.description");
        }
        return $this->defaultDescription;
    }
}
}
namespace phpex\Util\ORG{
interface SeoParseInterface {
    public function getTitle();
    
    public function getSubTitle();
    public function getKeywords();
    public function getDescription();
}
}
namespace phpex\Util\ORG{
class webservice {
    
    public function getClient($wsdl, $wsdl_mode = false) {   
        include_once main()->getMainRoot() . '/Util/ORG/lib/nusoap.php';
        $client = new \nusoap_client($wsdl,$wsdl_mode);
        $client->soap_defencoding = "UTF-8";
        $client->xml_encoding = "UTF-8";
        $client->decode_utf8 = FALSE;
        return $client;
    }
}
}
namespace phpex\Util\Yaml{
class Yaml
{
  static protected
    $spec = '1.2';
  
  static public function setSpecVersion($version)
  {
    if (!in_array($version, array('1.1', '1.2')))
    {
      throw new \InvalidArgumentException(sprintf('Version %s of the YAML specifications is not supported', $version));
    }
    self::$spec = $version;
  }
  
  static public function getSpecVersion()
  {
    return self::$spec;
  }
  
  public static function load($input)
  {
    $file = '';
        if (strpos($input, "\n") === false && is_file($input))
    {
      $file = $input;
      ob_start();
      $retval = include($input);
      $content = ob_get_clean();
            $input = is_array($retval) ? $retval : $content;
    }
        if (is_array($input))
    {
      return $input;
    }
    
    $yaml = new YamlParser();
    try
    {
      $ret = $yaml->parse($input);
    }
    catch (Exception $e)
    {
      throw new \InvalidArgumentException(sprintf('Unable to parse %s: %s', $file ? sprintf('file "%s"', $file) : 'string', $e->getMessage()));
    }
    return $ret;
  }
  
  public static function dump($array, $inline = 2)
  {
    
    $yaml = new YamlDumper();
    return $yaml->dump($array, $inline);
  }
}
function echoln($string)
{
  echo $string."\n";
}
}
namespace phpex\Util\Yaml{
class YamlDumper
{
  
  public function dump($input, $inline = 0, $indent = 0)
  {
    $output = '';
    $prefix = $indent ? str_repeat(' ', $indent) : '';
    if ($inline <= 0 || !is_array($input) || empty($input))
    {
      $output .= $prefix.YamlInline::dump($input);
    }
    else
    {
      $isAHash = array_keys($input) !== range(0, count($input) - 1);
      foreach ($input as $key => $value)
      {
        $willBeInlined = $inline - 1 <= 0 || !is_array($value) || empty($value);
        $output .= sprintf('%s%s%s%s',
          $prefix,
          $isAHash ? YamlInline::dump($key).':' : '-',
          $willBeInlined ? ' ' : "\n",
          $this->dump($value, $inline - 1, $willBeInlined ? 0 : $indent + 2)
        ).($willBeInlined ? "\n" : '');
      }
    }
    return $output;
  }
}
}
namespace phpex\Util\Yaml{
class YamlInline {
    const REGEX_QUOTED_STRING = '(?:"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"|\'([^\']*(?:\'\'[^\']*)*)\')';
    
    static public function load($value) {
        $value = trim($value);
        if (0 == strlen($value)) {
            return '';
        }
        if (function_exists('mb_internal_encoding') && ((int) ini_get('mbstring.func_overload')) & 2) {
            $mbEncoding = mb_internal_encoding();
            mb_internal_encoding('ASCII');
        }
        switch ($value[0]) {
            case '[':
                $result = self::parseSequence($value);
                break;
            case '{':
                $result = self::parseMapping($value);
                break;
            default:
                $result = self::parseScalar($value);
        }
        if (isset($mbEncoding)) {
            mb_internal_encoding($mbEncoding);
        }
        return $result;
    }
    
    static public function dump($value) {
        if ('1.1' === Yaml::getSpecVersion()) {
            $trueValues = array('true', 'on', '+', 'yes', 'y');
            $falseValues = array('false', 'off', '-', 'no', 'n');
        } else {
            $trueValues = array('true');
            $falseValues = array('false');
        }
        switch (true) {
            case is_resource($value):
                throw new InvalidArgumentException('Unable to dump PHP resources in a YAML file.');
            case is_object($value):
                return '!!php/object:' . serialize($value);
            case is_array($value):
                return self::dumpArray($value);
            case null === $value:
                return 'null';
            case true === $value:
                return 'true';
            case false === $value:
                return 'false';
            case ctype_digit($value):
                return is_string($value) ? "'$value'" : (int) $value;
            case is_numeric($value):
                return is_infinite($value) ? str_ireplace('INF', '.Inf', strval($value)) : (is_string($value) ? "'$value'" : $value);
            case false !== strpos($value, "\n") || false !== strpos($value, "\r"):
                return sprintf('"%s"', str_replace(array('"', "\n", "\r"), array('\\"', '\n', '\r'), $value));
            case preg_match('/[ \s \' " \: \{ \} \[ \] , & \* \# \?] | \A[ - ? | < > = ! % @ ` ]/x', $value):
                return sprintf("'%s'", str_replace('\'', '\'\'', $value));
            case '' == $value:
                return "''";
            case preg_match(self::getTimestampRegex(), $value):
                return "'$value'";
            case in_array(strtolower($value), $trueValues):
                return "'$value'";
            case in_array(strtolower($value), $falseValues):
                return "'$value'";
            case in_array(strtolower($value), array('null', '~')):
                return "'$value'";
            default:
                return $value;
        }
    }
    
    static protected function dumpArray($value) {
                $keys = array_keys($value);
        if (
                (1 == count($keys) && '0' == $keys[0]) ||
                (count($keys) > 1 && array_reduce($keys, create_function('$v,$w', 'return (integer) $v + $w;'), 0) == count($keys) * (count($keys) - 1) / 2)) {
            $output = array();
            foreach ($value as $val) {
                $output[] = self::dump($val);
            }
            return sprintf('[%s]', implode(', ', $output));
        }
                $output = array();
        foreach ($value as $key => $val) {
            $output[] = sprintf('%s: %s', self::dump($key), self::dump($val));
        }
        return sprintf('{ %s }', implode(', ', $output));
    }
    
    static public function parseScalar($scalar, $delimiters = null, $stringDelimiters = array('"', "'"), &$i = 0, $evaluate = true) {
        if (in_array($scalar[$i], $stringDelimiters)) {
                        $output = self::parseQuotedScalar($scalar, $i);
        } else {
                        if (!$delimiters) {
                $output = substr($scalar, $i);
                $i += strlen($output);
                                if (false !== $strpos = strpos($output, ' #')) {
                    $output = rtrim(substr($output, 0, $strpos));
                }
            } else if (preg_match('/^(.+?)(' . implode('|', $delimiters) . ')/', substr($scalar, $i), $match)) {
                $output = $match[1];
                $i += strlen($output);
            } else {
                throw new InvalidArgumentException(sprintf('Malformed inline YAML string (%s).', $scalar));
            }
            $output = $evaluate ? self::evaluateScalar($output) : $output;
        }
        return $output;
    }
    
    static protected function parseQuotedScalar($scalar, &$i) {
        if (!preg_match('/' . self::REGEX_QUOTED_STRING . '/Au', substr($scalar, $i), $match)) {
            throw new InvalidArgumentException(sprintf('Malformed inline YAML string (%s).', substr($scalar, $i)));
        }
        $output = substr($match[0], 1, strlen($match[0]) - 2);
        if ('"' == $scalar[$i]) {
                        $output = str_replace(array('\\"', '\\n', '\\r'), array('"', "\n", "\r"), $output);
        } else {
                        $output = str_replace('\'\'', '\'', $output);
        }
        $i += strlen($match[0]);
        return $output;
    }
    
    static protected function parseSequence($sequence, &$i = 0) {
        $output = array();
        $len = strlen($sequence);
        $i += 1;
                while ($i < $len) {
            switch ($sequence[$i]) {
                case '[':
                                        $output[] = self::parseSequence($sequence, $i);
                    break;
                case '{':
                                        $output[] = self::parseMapping($sequence, $i);
                    break;
                case ']':
                    return $output;
                case ',':
                case ' ':
                    break;
                default:
                    $isQuoted = in_array($sequence[$i], array('"', "'"));
                    $value = self::parseScalar($sequence, array(',', ']'), array('"', "'"), $i);
                    if (!$isQuoted && false !== strpos($value, ': ')) {
                                                try {
                            $value = self::parseMapping('{' . $value . '}');
                        } catch (InvalidArgumentException $e) {
                                                    }
                    }
                    $output[] = $value;
                    --$i;
            }
            ++$i;
        }
        throw new InvalidArgumentException(sprintf('Malformed inline YAML string %s', $sequence));
    }
    
    static protected function parseMapping($mapping, &$i = 0) {
        $output = array();
        $len = strlen($mapping);
        $i += 1;
                while ($i < $len) {
            switch ($mapping[$i]) {
                case ' ':
                case ',':
                    ++$i;
                    continue 2;
                case '}':
                    return $output;
            }
                        $key = self::parseScalar($mapping, array(':', ' '), array('"', "'"), $i, false);
                        $done = false;
            while ($i < $len) {
                switch ($mapping[$i]) {
                    case '[':
                                                $output[$key] = self::parseSequence($mapping, $i);
                        $done = true;
                        break;
                    case '{':
                                                $output[$key] = self::parseMapping($mapping, $i);
                        $done = true;
                        break;
                    case ':':
                    case ' ':
                        break;
                    default:
                        $output[$key] = self::parseScalar($mapping, array(',', '}'), array('"', "'"), $i);
                        $done = true;
                        --$i;
                }
                ++$i;
                if ($done) {
                    continue 2;
                }
            }
        }
        throw new InvalidArgumentException(sprintf('Malformed inline YAML string %s', $mapping));
    }
    
    static protected function evaluateScalar($scalar) {
        $scalar = trim($scalar);
        if ('1.1' === Yaml::getSpecVersion()) {
            $trueValues = array('true', 'on', '+', 'yes', 'y');
            $falseValues = array('false', 'off', '-', 'no', 'n');
        } else {
            $trueValues = array('true');
            $falseValues = array('false');
        }
        switch (true) {
            case 'null' == strtolower($scalar):
            case '' == $scalar:
            case '~' == $scalar:
                return null;
            case 0 === strpos($scalar, '!str'):
                return (string) substr($scalar, 5);
            case 0 === strpos($scalar, '! '):
                return intval(self::parseScalar(substr($scalar, 2)));
            case 0 === strpos($scalar, '!!php/object:'):
                return unserialize(substr($scalar, 13));
            case ctype_digit($scalar):
                $raw = $scalar;
                $cast = intval($scalar);
                return '0' == $scalar[0] ? octdec($scalar) : (((string) $raw == (string) $cast) ? $cast : $raw);
            case in_array(strtolower($scalar), $trueValues):
                return true;
            case in_array(strtolower($scalar), $falseValues):
                return false;
            case is_numeric($scalar):
                return '0x' == $scalar[0] . $scalar[1] ? hexdec($scalar) : floatval($scalar);
            case 0 == strcasecmp($scalar, '.inf'):
            case 0 == strcasecmp($scalar, '.NaN'):
                return -log(0);
            case 0 == strcasecmp($scalar, '-.inf'):
                return log(0);
            case preg_match('/^(-|\+)?[0-9,]+(\.[0-9]+)?$/', $scalar):
                return floatval(str_replace(',', '', $scalar));
            case preg_match(self::getTimestampRegex(), $scalar):
                return strtotime($scalar);
            default:
                return (string) $scalar;
        }
    }
    static protected function getTimestampRegex() {
        return <<<EOF
    ~^
    (?P<year>[0-9][0-9][0-9][0-9])
    -(?P<month>[0-9][0-9]?)
    -(?P<day>[0-9][0-9]?)
    (?:(?:[Tt]|[ \t]+)
    (?P<hour>[0-9][0-9]?)
    :(?P<minute>[0-9][0-9])
    :(?P<second>[0-9][0-9])
    (?:\.(?P<fraction>[0-9]*))?
    (?:[ \t]*(?P<tz>Z|(?P<tz_sign>[-+])(?P<tz_hour>[0-9][0-9]?)
    (?::(?P<tz_minute>[0-9][0-9]))?))?)?
    $~x
EOF;
    }
}
}
namespace phpex\Util\Yaml{
use InvalidArgumentException;
if (!defined('PREG_BAD_UTF8_OFFSET_ERROR')) {
    define('PREG_BAD_UTF8_OFFSET_ERROR', 5);
}
class YamlParser {
    protected
            $offset = 0,
            $lines = array(),
            $currentLineNb = -1,
            $currentLine = '',
            $refs = array();
    
    public function __construct($offset = 0) {
        $this->offset = $offset;
    }
    
    public function parse($value) {
        $this->currentLineNb = -1;
        $this->currentLine = '';
        $this->lines = explode("\n", $this->cleanup($value));
        if (function_exists('mb_internal_encoding') && ((int) ini_get('mbstring.func_overload')) & 2) {
            $mbEncoding = mb_internal_encoding();
            mb_internal_encoding('UTF-8');
        }
        $data = array();
        while ($this->moveToNextLine()) {
            if ($this->isCurrentLineEmpty()) {
                continue;
            }
                        if (preg_match('#^\t+#', $this->currentLine)) {
                throw new InvalidArgumentException(sprintf('A YAML file cannot contain tabs as indentation at line %d (%s).', $this->getRealCurrentLineNb() + 1, $this->currentLine));
            }
            $isRef = $isInPlace = $isProcessed = false;
            if (preg_match('#^\-((?P<leadspaces>\s+)(?P<value>.+?))?\s*$#u', $this->currentLine, $values)) {
                if (isset($values['value']) && preg_match('#^&(?P<ref>[^ ]+) *(?P<value>.*)#u', $values['value'], $matches)) {
                    $isRef = $matches['ref'];
                    $values['value'] = $matches['value'];
                }
                                if (!isset($values['value']) || '' == trim($values['value'], ' ') || 0 === strpos(ltrim($values['value'], ' '), '#')) {
                    $c = $this->getRealCurrentLineNb() + 1;
                    $parser = new YamlParser($c);
                    $parser->refs = & $this->refs;
                    $data[] = $parser->parse($this->getNextEmbedBlock());
                } else {
                    if (isset($values['leadspaces']) && ' ' == $values['leadspaces'] && preg_match('#^(?P<key>' . YamlInline::REGEX_QUOTED_STRING . '|[^ \'"\{].*?) *\:(\s+(?P<value>.+?))?\s*$#u', $values['value'], $matches)) {
                                                $c = $this->getRealCurrentLineNb();
                        $parser = new YamlParser($c);
                        $parser->refs = & $this->refs;
                        $block = $values['value'];
                        if (!$this->isNextLineIndented()) {
                            $block .= "\n" . $this->getNextEmbedBlock($this->getCurrentLineIndentation() + 2);
                        }
                        $data[] = $parser->parse($block);
                    } else {
                        $data[] = $this->parseValue($values['value']);
                    }
                }
            } else if (preg_match('#^(?P<key>' . YamlInline::REGEX_QUOTED_STRING . '|[^ \'"].*?) *\:(\s+(?P<value>.+?))?\s*$#u', $this->currentLine, $values)) {
                $key = YamlInline::parseScalar($values['key']);
                if ('<<' === $key) {
                    if (isset($values['value']) && '*' === substr($values['value'], 0, 1)) {
                        $isInPlace = substr($values['value'], 1);
                        if (!array_key_exists($isInPlace, $this->refs)) {
                            throw new InvalidArgumentException(sprintf('Reference "%s" does not exist at line %s (%s).', $isInPlace, $this->getRealCurrentLineNb() + 1, $this->currentLine));
                        }
                    } else {
                        if (isset($values['value']) && $values['value'] !== '') {
                            $value = $values['value'];
                        } else {
                            $value = $this->getNextEmbedBlock();
                        }
                        $c = $this->getRealCurrentLineNb() + 1;
                        $parser = new YamlParser($c);
                        $parser->refs = & $this->refs;
                        $parsed = $parser->parse($value);
                        $merged = array();
                        if (!is_array($parsed)) {
                            throw new InvalidArgumentException(sprintf("YAML merge keys used with a scalar value instead of an array at line %s (%s)", $this->getRealCurrentLineNb() + 1, $this->currentLine));
                        } else if (isset($parsed[0])) {
                                                        foreach (array_reverse($parsed) as $parsedItem) {
                                if (!is_array($parsedItem)) {
                                    throw new InvalidArgumentException(sprintf("Merge items must be arrays at line %s (%s).", $this->getRealCurrentLineNb() + 1, $parsedItem));
                                }
                                $merged = array_merge($parsedItem, $merged);
                            }
                        } else {
                                                        $merged = array_merge($merged, $parsed);
                        }
                        $isProcessed = $merged;
                    }
                } else if (isset($values['value']) && preg_match('#^&(?P<ref>[^ ]+) *(?P<value>.*)#u', $values['value'], $matches)) {
                    $isRef = $matches['ref'];
                    $values['value'] = $matches['value'];
                }
                if ($isProcessed) {
                                        $data = $isProcessed;
                }
                                else if (!isset($values['value']) || '' == trim($values['value'], ' ') || 0 === strpos(ltrim($values['value'], ' '), '#')) {
                                        if ($this->isNextLineIndented()) {
                        $data[$key] = null;
                    } else {
                        $c = $this->getRealCurrentLineNb() + 1;
                        $parser = new YamlParser($c);
                        $parser->refs = & $this->refs;
                        $data[$key] = $parser->parse($this->getNextEmbedBlock());
                    }
                } else {
                    if ($isInPlace) {
                        $data = $this->refs[$isInPlace];
                    } else {
                        $data[$key] = $this->parseValue($values['value']);
                    }
                }
            } else {
                                if (2 == count($this->lines) && empty($this->lines[1])) {
                    $value = YamlInline::load($this->lines[0]);
                    if (is_array($value)) {
                        $first = reset($value);
                        if ('*' === substr($first, 0, 1)) {
                            $data = array();
                            foreach ($value as $alias) {
                                $data[] = $this->refs[substr($alias, 1)];
                            }
                            $value = $data;
                        }
                    }
                    if (isset($mbEncoding)) {
                        mb_internal_encoding($mbEncoding);
                    }
                    return $value;
                }
                switch (preg_last_error()) {
                    case PREG_INTERNAL_ERROR:
                        $error = 'Internal PCRE error on line';
                        break;
                    case PREG_BACKTRACK_LIMIT_ERROR:
                        $error = 'pcre.backtrack_limit reached on line';
                        break;
                    case PREG_RECURSION_LIMIT_ERROR:
                        $error = 'pcre.recursion_limit reached on line';
                        break;
                    case PREG_BAD_UTF8_ERROR:
                        $error = 'Malformed UTF-8 data on line';
                        break;
                    case PREG_BAD_UTF8_OFFSET_ERROR:
                        $error = 'Offset doesn\'t correspond to the begin of a valid UTF-8 code point on line';
                        break;
                    default:
                        $error = 'Unable to parse line';
                }
                throw new InvalidArgumentException(sprintf('%s %d (%s).', $error, $this->getRealCurrentLineNb() + 1, $this->currentLine));
            }
            if ($isRef) {
                $this->refs[$isRef] = end($data);
            }
        }
        if (isset($mbEncoding)) {
            mb_internal_encoding($mbEncoding);
        }
        return empty($data) ? null : $data;
    }
    
    protected function getRealCurrentLineNb() {
        return $this->currentLineNb + $this->offset;
    }
    
    protected function getCurrentLineIndentation() {
        return strlen($this->currentLine) - strlen(ltrim($this->currentLine, ' '));
    }
    
    protected function getNextEmbedBlock($indentation = null) {
        $this->moveToNextLine();
        if (null === $indentation) {
            $newIndent = $this->getCurrentLineIndentation();
            if (!$this->isCurrentLineEmpty() && 0 == $newIndent) {
                throw new InvalidArgumentException(sprintf('Indentation problem at line %d (%s)', $this->getRealCurrentLineNb() + 1, $this->currentLine));
            }
        } else {
            $newIndent = $indentation;
        }
        $data = array(substr($this->currentLine, $newIndent));
        while ($this->moveToNextLine()) {
            if ($this->isCurrentLineEmpty()) {
                if ($this->isCurrentLineBlank()) {
                    $data[] = substr($this->currentLine, $newIndent);
                }
                continue;
            }
            $indent = $this->getCurrentLineIndentation();
            if (preg_match('#^(?P<text> *)$#', $this->currentLine, $match)) {
                                $data[] = $match['text'];
            } else if ($indent >= $newIndent) {
                $data[] = substr($this->currentLine, $newIndent);
            } else if (0 == $indent) {
                $this->moveToPreviousLine();
                break;
            } else {
                throw new InvalidArgumentException(sprintf('Indentation problem at line %d (%s)', $this->getRealCurrentLineNb() + 1, $this->currentLine));
            }
        }
        return implode("\n", $data);
    }
    
    protected function moveToNextLine() {
        if ($this->currentLineNb >= count($this->lines) - 1) {
            return false;
        }
        $this->currentLine = $this->lines[++$this->currentLineNb];
        return true;
    }
    
    protected function moveToPreviousLine() {
        $this->currentLine = $this->lines[--$this->currentLineNb];
    }
    
    protected function parseValue($value) {
        if ('*' === substr($value, 0, 1)) {
            if (false !== $pos = strpos($value, '#')) {
                $value = substr($value, 1, $pos - 2);
            } else {
                $value = substr($value, 1);
            }
            if (!array_key_exists($value, $this->refs)) {
                throw new InvalidArgumentException(sprintf('Reference "%s" does not exist (%s).', $value, $this->currentLine));
            }
            return $this->refs[$value];
        }
        if (preg_match('/^(?P<separator>\||>)(?P<modifiers>\+|\-|\d+|\+\d+|\-\d+|\d+\+|\d+\-)?(?P<comments> +#.*)?$/', $value, $matches)) {
            $modifiers = isset($matches['modifiers']) ? $matches['modifiers'] : '';
            return $this->parseFoldedScalar($matches['separator'], preg_replace('#\d+#', '', $modifiers), intval(abs($modifiers)));
        } else {
            return YamlInline::load($value);
        }
    }
    
    protected function parseFoldedScalar($separator, $indicator = '', $indentation = 0) {
        $separator = '|' == $separator ? "\n" : ' ';
        $text = '';
        $notEOF = $this->moveToNextLine();
        while ($notEOF && $this->isCurrentLineBlank()) {
            $text .= "\n";
            $notEOF = $this->moveToNextLine();
        }
        if (!$notEOF) {
            return '';
        }
        if (!preg_match('#^(?P<indent>' . ($indentation ? str_repeat(' ', $indentation) : ' +') . ')(?P<text>.*)$#u', $this->currentLine, $matches)) {
            $this->moveToPreviousLine();
            return '';
        }
        $textIndent = $matches['indent'];
        $previousIndent = 0;
        $text .= $matches['text'] . $separator;
        while ($this->currentLineNb + 1 < count($this->lines)) {
            $this->moveToNextLine();
            if (preg_match('#^(?P<indent> {' . strlen($textIndent) . ',})(?P<text>.+)$#u', $this->currentLine, $matches)) {
                if (' ' == $separator && $previousIndent != $matches['indent']) {
                    $text = substr($text, 0, -1) . "\n";
                }
                $previousIndent = $matches['indent'];
                $text .= str_repeat(' ', $diff = strlen($matches['indent']) - strlen($textIndent)) . $matches['text'] . ($diff ? "\n" : $separator);
            } else if (preg_match('#^(?P<text> *)$#', $this->currentLine, $matches)) {
                $text .= preg_replace('#^ {1,' . strlen($textIndent) . '}#', '', $matches['text']) . "\n";
            } else {
                $this->moveToPreviousLine();
                break;
            }
        }
        if (' ' == $separator) {
                        $text = preg_replace('/ (\n*)$/', "\n$1", $text);
        }
        switch ($indicator) {
            case '':
                $text = preg_replace('#\n+$#s', "\n", $text);
                break;
            case '+':
                break;
            case '-':
                $text = preg_replace('#\n+$#s', '', $text);
                break;
        }
        return $text;
    }
    
    protected function isNextLineIndented() {
        $currentIndentation = $this->getCurrentLineIndentation();
        $notEOF = $this->moveToNextLine();
        while ($notEOF && $this->isCurrentLineEmpty()) {
            $notEOF = $this->moveToNextLine();
        }
        if (false === $notEOF) {
            return false;
        }
        $ret = false;
        if ($this->getCurrentLineIndentation() <= $currentIndentation) {
            $ret = true;
        }
        $this->moveToPreviousLine();
        return $ret;
    }
    
    protected function isCurrentLineEmpty() {
        return $this->isCurrentLineBlank() || $this->isCurrentLineComment();
    }
    
    protected function isCurrentLineBlank() {
        return '' == trim($this->currentLine, ' ');
    }
    
    protected function isCurrentLineComment() {
                $ltrimmedLine = ltrim($this->currentLine, ' ');
        return $ltrimmedLine[0] === '#';
    }
    
    protected function cleanup($value) {
        $value = str_replace(array("\r\n", "\r"), "\n", $value);
        if (!preg_match("#\n$#", $value)) {
            $value .= "\n";
        }
                $count = 0;
        $value = preg_replace('#^\%YAML[: ][\d\.]+.*\n#su', '', $value, -1, $count);
        $this->offset += $count;
                $trimmedValue = preg_replace('#^(\#.*?\n)+#s', '', $value, -1, $count);
        if ($count == 1) {
                        $this->offset += substr_count($value, "\n") - substr_count($trimmedValue, "\n");
            $value = $trimmedValue;
        }
                $trimmedValue = preg_replace('#^\-\-\-.*?\n#s', '', $value, -1, $count);
        if ($count == 1) {
                        $this->offset += substr_count($value, "\n") - substr_count($trimmedValue, "\n");
            $value = $trimmedValue;
                        $value = preg_replace('#\.\.\.\s*$#s', '', $value);
        }
        return $value;
    }
}
}
namespace Latte{
interface IMacro
{
	
	function initialize();
	
	function finalize();
	
	function nodeOpened(MacroNode $node);
	
	function nodeClosed(MacroNode $node);
}
}
namespace Engine{
use Latte\IMacro;
interface ILatte extends IMacro {
    public static function installExtend(\Latte\Engine $latte);
}
}
namespace Engine{
class LatteEngine {
    private $appName;
    protected $pattern = "/^(?<app>[a-zA-Z0-9_]+@)?(?<theme>[a-zA-Z0-9_]+#)?(?<con>[a-zA-Z0-9_]+[\\:\\/])?(?<act>[a-zA-Z0-9_]+)?$/";
    public function fetch($templateFile, $assign, $config) {
        $latte = new \Latte\Engine;
        $latte->setAutoRefresh(defined("LATTE_DEV")?LATTE_DEV:main()->getEnv() == "dev");
        preg_match("/\.(?P<type>html|xhtml|xml|js|css|url|ical|text)\.latte$/", $templateFile, $match);
        if ($match)
            $latte->setContentType($match["type"]);
        $cache = $this->appName ? $config['cache'] . "latte/" . $this->appName : $config['cache'] . "latte";
        if (!is_dir($cache))
            mkdir($cache, 0777, true);
        $latte->setTempDirectory($cache);
        $lattes = (array) C("view.extension");
        phpexEngine::installExtend($latte);
        foreach ($lattes as $ilatte) {
            if (class_exists($ilatte)) {
                $rf = new \ReflectionClass($ilatte);
                if ($rf->isSubclassOf(__NAMESPACE__ . "\\ILatte"))
                    $ilatte::installExtend($latte);
            }
        }
        return $latte->renderToString($templateFile, $assign);
    }
    public function setAppName($appName) {
        $this->appName = $appName;
    }
}
}
namespace Latte{
abstract class LatteObject
{
	
	public function __call($name, $args)
	{
		$class = method_exists($this, $name) ? 'parent' : get_class($this);
		throw new \LogicException(sprintf('Call to undefined method %s::%s().', $class, $name));
	}
	
	public function &__get($name)
	{
		throw new \LogicException(sprintf('Cannot read an undeclared property %s::$%s.', get_class($this), $name));
	}
	
	public function __set($name, $value)
	{
		throw new \LogicException(sprintf('Cannot write to an undeclared property %s::$%s.', get_class($this), $name));
	}
	
	public function __isset($name)
	{
		return FALSE;
	}
	
	public function __unset($name)
	{
		throw new \LogicException(sprintf('Cannot unset the property %s::$%s.', get_class($this), $name));
	}
}
}
namespace Latte\Macros{
use Latte,
	Latte\MacroNode;
class MacroSet extends Latte\LatteObject implements Latte\IMacro
{
	
	private $compiler;
	
	private $macros;
	public function __construct(Latte\Compiler $compiler)
	{
		$this->compiler = $compiler;
	}
	public function addMacro($name, $begin, $end = NULL, $attr = NULL)
	{
		if (!$begin && !$end && !$attr) {
			throw new \InvalidArgumentException("At least one argument must be specified for macro '$name'.");
		}
		foreach (array($begin, $end, $attr) as $arg) {
			if ($arg && !is_string($arg)) {
				Latte\Helpers::checkCallback($arg);
			}
		}
		$this->macros[$name] = array($begin, $end, $attr);
		$this->compiler->addMacro($name, $this);
		return $this;
	}
	public static function install(Latte\Compiler $compiler)
	{
		return new static($compiler);
	}
	
	public function initialize()
	{
	}
	
	public function finalize()
	{
	}
	
	public function nodeOpened(MacroNode $node)
	{
		list($begin, $end, $attr) = $this->macros[$node->name];
		$node->isEmpty = !$end;
		if ($attr && $node->prefix === $node::PREFIX_NONE) {
			$node->isEmpty = TRUE;
			$this->compiler->setContext(Latte\Compiler::CONTEXT_DOUBLE_QUOTED_ATTR);
			$res = $this->compile($node, $attr);
			if ($res === FALSE) {
				return FALSE;
			} elseif (!$node->attrCode) {
				$node->attrCode = "<?php $res ?>";
			}
			$this->compiler->setContext(NULL);
		} elseif ($begin) {
			$res = $this->compile($node, $begin);
			if ($res === FALSE) {
				return FALSE;
			} elseif (!$node->openingCode) {
				$node->openingCode = "<?php $res ?>";
			}
		} elseif (!$end) {
			return FALSE;
		}
	}
	
	public function nodeClosed(MacroNode $node)
	{
		if (isset($this->macros[$node->name][1])) {
			$res = $this->compile($node, $this->macros[$node->name][1]);
			if (!$node->closingCode) {
				$node->closingCode = "<?php $res ?>";
			}
		}
	}
	
	private function compile(MacroNode $node, $def)
	{
		$node->tokenizer->reset();
		$writer = Latte\PhpWriter::using($node, $this->compiler);
		if (is_string($def)) {
			return $writer->write($def);
		} else {
			return call_user_func($def, $node, $writer);
		}
	}
	
	public function getCompiler()
	{
		return $this->compiler;
	}
}
}
namespace Engine{
use Latte\Macros\MacroSet;
use Latte\PhpWriter;
use Latte\MacroNode;
class phpexEngine extends MacroSet implements ILatte {
    protected $pattern = "/^(?<app>[a-zA-Z0-9_]+@)?(?<theme>[a-zA-Z0-9_]+#)?(?<con>[a-zA-Z0-9_]+[\\:\\/])?(?<act>[a-zA-Z0-9_]+)?$/";
    public static function installExtend(\Latte\Engine $latte) {
        $me = new static($latte->getCompiler());
        $latte->addFilter("asset", array($me, "filterAsset"));
        $latte->addFilter("todate", array($me, "todate"));
        $latte->addFilter("totime", array($me, "totime"));
        $latte->addFilter("default", array($me, "filterDefault"));
        $me->addMacro("asset", array($me, "macroAsset"), array($me, "macroEndAsset"));
        $me->addMacro("path", array($me, "macroPath"), array($me, "macroEndPath"));
        $me->addMacro("assetWrite", array($me, "macroAssetWrite"));
        $me->addMacro("import", array($me, 'macroImport'));
        $me->addMacro("literal", function (MacroNode $node, PhpWriter $writer) {
            return $writer->write('');
        }, function (MacroNode $node, PhpWriter $writer) {
            return $writer->write('');
        });
        $me->addMacro("control", array($me, 'macroControl'));
    }
    
    public function macroAsset(MacroNode $node, PhpWriter $writer) {
        return $writer->write('ob_start()');
    }
    
    public function macroEndAsset(MacroNode $node, PhpWriter $writer) {
        return $writer->write('echo phpex\Asset\Assetic::parseHtml(ob_get_clean(),"%node.args")');
    }
    public function macroPath(MacroNode $node, PhpWriter $writer) {
        return $writer->write('ob_start();');
    }
    public function macroEndPath(MacroNode $node, PhpWriter $writer) {
        return $writer->write('echo phpex\Asset\Assetic::path(ob_get_clean(),%node.args)');
    }
    public function macroAssetWrite(MacroNode $node, PhpWriter $writer) {
        return $writer->write('echo phpex\Assetic\Assetic::render("",%node.args)');
    }
    
    public function macroImport(MacroNode $node, PhpWriter $writer) {
        $pattern = $this->pattern;
        $filePath = trim(trim($node->args, "\""), "'");
        $configs = C("view");
        $basename = basename($filePath);
        $suffix = strstr($basename, ".");
        if ($suffix)
            $filePath = substr($filePath, 0, -strlen($suffix));
        else {
            $suffix = "." . getkey($configs["RelateEngine"], $configs["engine"]);
        }
        if (!$filePath) {             return "";
        } elseif (preg_match($pattern, $filePath, $matches)) {             
            if (!isset($matches["app"]) || empty($matches["app"])) {
                $appName = ucfirst(R()->getAppName());
            } else {
                $appName = ucfirst(substr($matches["app"], 0, -1));
            }
            $app = ins()->get("app." . $appName);
            if (!isset($matches["theme"]) || empty($matches["theme"])) {
                $theme = $app->getTheme() ? $app->getTheme() . "/" : "";
            } else {
                $theme = substr($matches["theme"], 0, -1) . "/";
            }
            if (!isset($matches["con"]) || empty($matches["con"])) {
                $con = R()->getController();
            } else {
                $con = substr($matches["con"], 0, -1);
            }
            $con = ucfirst($con);
            if (!isset($matches["act"]) || empty($matches["act"])) {
                $act = R()->getAction();
            } else {
                $act = $matches["act"];
            }
            $filePath = $app->getRoot() . "/View/" . $theme . $con . "/" . $act;
        }
        $filePath .= $suffix;
        $filePath = str_replace("\\", "/", $filePath);
        if (!is_file($filePath)) {
            $code = "echo  '<!--" . $filePath . "-->'";
            return ($node->modifiers) ? $writer->write('ob_start(); %raw; echo %modify(ob_get_clean())', $code) : $code;
        }
        $code = $writer->write('$_l->templates[%var]->getEngine()->render("' . $filePath . '", $template->getParameters()+ get_defined_vars())', $this->getCompiler()->getTemplateId());
        if ($node->modifiers) {
            return $writer->write('ob_start(); %raw; echo %modify(ob_get_clean())', $code);
        } else {
            return $code;
        }
    }
    public function macroControl(MacroNode $node, PhpWriter $writer) {
        return $writer->write('echo \Engine\phpexEngine::controlWriter("' . $node->args . '")');
    }
    public static function controlWriter($args) {
        $args = explode(" ", $args);
        list($app, $control, $action) = explode(":", $args[0]);
        $app = ins()->get("app." . ucfirst($app));
        $parameter = array();
        if (isset($args[1]))
            parse_str($args[1], $parameter);
        
        $response = $app->run(ucfirst($control), $action, $parameter);
        if ($response instanceof \phpex\Foundation\Response) {
            if ($response->getStatusCode() == 200) {
                return $response->getContent();
            } else {
                throw new \HttpInvalidParamException("response StatusCode must be 200");
            }
        } elseif (is_scalar($response)) {
            return (string) $response;
        } else {
            throw new \HttpInvalidParamException("response types must be string or Response object");
        }
    }
    public function todate($date, $format = "Y-m-d") {
        return todate($date, $format);
    }
    public function totime($date, $format = "Y-m-d H:i:s") {
        return $this->todate($date, $format);
    }
    public function filterDefault($string = "", $default = "") {
        if (trim(strval($string)) === "" || $string === null) {
            return $default;
        }
        return $string;
    }
    
}
}
namespace Latte{
class CompileException extends \Exception {
    
    public $sourceCode;
    
    public $sourceName;
    
    public $sourceLine;
    public function setSource($code, $line, $name = NULL) {
        $this->sourceCode = (string) $code;
        $this->sourceLine = (int) $line;
        $this->sourceName = (string) $name;
        if (is_file($name)) {
            $this->message = rtrim($this->message, '.')
                    . ' in ' . str_replace(dirname(dirname($name)), '...', $name) . ($line ? ":$line" : '');
        }
        return $this;
    }
}
}
namespace Latte{
class Compiler extends LatteObject
{
	
	private $tokens;
	
	private $output;
	
	private $position;
	
	private $macros;
	
	private $macroHandlers;
	
	private $htmlNode;
	
	private $macroNode;
	
	private $attrCodes = array();
	
	private $contentType;
	
	private $context;
	
	private $templateId;
	
	const CONTENT_HTML = 'html',
		CONTENT_XHTML = 'xhtml',
		CONTENT_XML = 'xml',
		CONTENT_JS = 'js',
		CONTENT_CSS = 'css',
		CONTENT_URL = 'url',
		CONTENT_ICAL = 'ical',
		CONTENT_TEXT = 'text';
	
	const CONTEXT_COMMENT = 'comment',
		CONTEXT_SINGLE_QUOTED_ATTR = "'",
		CONTEXT_DOUBLE_QUOTED_ATTR = '"',
		CONTEXT_UNQUOTED_ATTR = '=';
	public function __construct()
	{
		$this->macroHandlers = new \SplObjectStorage;
	}
	
	public function addMacro($name, IMacro $macro)
	{
		$this->macros[$name][] = $macro;
		$this->macroHandlers->attach($macro);
		return $this;
	}
	
	public function compile(array $tokens)
	{
		$this->templateId = substr(lcg_value(), 2, 10);
		$this->tokens = $tokens;
		$output = '';
		$this->output = & $output;
		$this->htmlNode = $this->macroNode = $this->context = NULL;
		foreach ($this->macroHandlers as $handler) {
			$handler->initialize($this);
		}
		foreach ($tokens as $this->position => $token) {
			$this->{"process$token->type"}($token);
		}
		while ($this->htmlNode) {
			if (!empty($this->htmlNode->macroAttrs)) {
				throw new CompileException('Missing ' . self::printEndTag($this->macroNode));
			}
			$this->htmlNode = $this->htmlNode->parentNode;
		}
		$prologs = $epilogs = '';
		foreach ($this->macroHandlers as $handler) {
			$res = $handler->finalize();
			$handlerName = get_class($handler);
			$prologs .= empty($res[0]) ? '' : "<?php\n// prolog $handlerName\n$res[0]\n?>";
			$epilogs = (empty($res[1]) ? '' : "<?php\n// epilog $handlerName\n$res[1]\n?>") . $epilogs;
		}
		$output = ($prologs ? $prologs . "<?php\n//\n// main template\n//\n?>\n" : '') . $output . $epilogs;
		if ($this->macroNode) {
			throw new CompileException('Missing ' . self::printEndTag($this->macroNode));
		}
		$output = $this->expandTokens($output);
		return $output;
	}
	
	public function setContentType($type)
	{
		$this->contentType = $type;
		$this->context = NULL;
		return $this;
	}
	
	public function getContentType()
	{
		return $this->contentType;
	}
	
	public function setContext($context, $sub = NULL)
	{
		$this->context = array($context, $sub);
		return $this;
	}
	
	public function getContext()
	{
		return $this->context;
	}
	
	public function getTemplateId()
	{
		return $this->templateId;
	}
	
	public function getMacroNode()
	{
		return $this->macroNode;
	}
	
	public function getLine()
	{
		return $this->tokens ? $this->tokens[$this->position]->line : NULL;
	}
	public function expandTokens($s)
	{
		return strtr($s, $this->attrCodes);
	}
	private function processText(Token $token)
	{
		if (($this->context[0] === self::CONTEXT_SINGLE_QUOTED_ATTR || $this->context[0] === self::CONTEXT_DOUBLE_QUOTED_ATTR)
			&& $token->text === $this->context[0]
		) {
			$this->setContext(self::CONTEXT_UNQUOTED_ATTR);
		}
		$this->output .= $token->text;
	}
	private function processMacroTag(Token $token)
	{
		$isRightmost = !isset($this->tokens[$this->position + 1])
			|| substr($this->tokens[$this->position + 1]->text, 0, 1) === "\n";
		if ($token->name[0] === '/') {
			$this->closeMacro((string) substr($token->name, 1), $token->value, $token->modifiers, $isRightmost);
		} else {
			$this->openMacro($token->name, $token->value, $token->modifiers, $isRightmost && !$token->empty);
			if ($token->empty) {
				$this->closeMacro($token->name, NULL, NULL, $isRightmost);
			}
		}
	}
	private function processHtmlTagBegin(Token $token)
	{
		if ($token->closing) {
			while ($this->htmlNode) {
				if (strcasecmp($this->htmlNode->name, $token->name) === 0) {
					break;
				}
				if ($this->htmlNode->macroAttrs) {
					throw new CompileException("Unexpected </$token->name>, expecting " . self::printEndTag($this->macroNode));
				}
				$this->htmlNode = $this->htmlNode->parentNode;
			}
			if (!$this->htmlNode) {
				$this->htmlNode = new HtmlNode($token->name);
			}
			$this->htmlNode->closing = TRUE;
			$this->htmlNode->offset = strlen($this->output);
			$this->setContext(NULL);
		} elseif ($token->text === '<!--') {
			$this->setContext(self::CONTEXT_COMMENT);
		} else {
			$this->htmlNode = new HtmlNode($token->name, $this->htmlNode);
			$this->htmlNode->isEmpty = in_array($this->contentType, array(self::CONTENT_HTML, self::CONTENT_XHTML))
				&& isset(Helpers::$emptyElements[strtolower($token->name)]);
			$this->htmlNode->offset = strlen($this->output);
			$this->setContext(self::CONTEXT_UNQUOTED_ATTR);
		}
		$this->output .= $token->text;
	}
	private function processHtmlTagEnd(Token $token)
	{
		if ($token->text === '-->') {
			$this->output .= $token->text;
			$this->setContext(NULL);
			return;
		}
		$htmlNode = $this->htmlNode;
		$isEmpty = !$htmlNode->closing && (strpos($token->text, '/') !== FALSE || $htmlNode->isEmpty);
		$end = '';
		if ($isEmpty && in_array($this->contentType, array(self::CONTENT_HTML, self::CONTENT_XHTML))) { 			$token->text = preg_replace('#^.*>#', $htmlNode->isEmpty && $this->contentType === self::CONTENT_XHTML ? ' />' : '>', $token->text);
			if (!$htmlNode->isEmpty) {
				$end = "</$htmlNode->name>";
			}
		}
		if (empty($htmlNode->macroAttrs)) {
			$this->output .= $token->text . $end;
		} else {
			$code = substr($this->output, $htmlNode->offset) . $token->text;
			$this->output = substr($this->output, 0, $htmlNode->offset);
			$this->writeAttrsMacro($code);
			if ($isEmpty) {
				$htmlNode->closing = TRUE;
				$this->writeAttrsMacro($end);
			}
		}
		if ($isEmpty) {
			$htmlNode->closing = TRUE;
		}
		$lower = strtolower($htmlNode->name);
		if (!$htmlNode->closing && ($lower === 'script' || $lower === 'style')) {
			$this->setContext($lower === 'script' ? self::CONTENT_JS : self::CONTENT_CSS);
		} else {
			$this->setContext(NULL);
			if ($htmlNode->closing) {
				$this->htmlNode = $this->htmlNode->parentNode;
			}
		}
	}
	private function processHtmlAttribute(Token $token)
	{
		if (strncmp($token->name, Parser::N_PREFIX, strlen(Parser::N_PREFIX)) === 0) {
			$name = substr($token->name, strlen(Parser::N_PREFIX));
			if (isset($this->htmlNode->macroAttrs[$name])) {
				throw new CompileException("Found multiple macro-attributes $token->name.");
			} elseif ($this->macroNode && $this->macroNode->htmlNode === $this->htmlNode) {
				throw new CompileException("Macro-attributes must not appear inside macro; found $token->name inside {{$this->macroNode->name}}.");
			}
			$this->htmlNode->macroAttrs[$name] = $token->value;
			return;
		}
		$this->htmlNode->attrs[$token->name] = TRUE;
		$this->output .= $token->text;
		$context = NULL;
		if (in_array($this->contentType, array(self::CONTENT_HTML, self::CONTENT_XHTML))) {
			$lower = strtolower($token->name);
			if (substr($lower, 0, 2) === 'on') {
				$context = self::CONTENT_JS;
			} elseif ($lower === 'style') {
				$context = self::CONTENT_CSS;
			} elseif (in_array($lower, array('href', 'src', 'action', 'formaction'))
				|| ($lower === 'data' && strtolower($this->htmlNode->name) === 'LatteObject')
			) {
				$context = self::CONTENT_URL;
			}
		}
		$this->setContext($token->value ?: self::CONTEXT_UNQUOTED_ATTR, $context);
	}
	private function processComment(Token $token)
	{
		$isLeftmost = trim(substr($this->output, strrpos("\n$this->output", "\n"))) === '';
		if (!$isLeftmost) {
			$this->output .= substr($token->text, strlen(rtrim($token->text, "\n")));
		}
	}
	
	
	public function openMacro($name, $args = NULL, $modifiers = NULL, $isRightmost = FALSE, $nPrefix = NULL)
	{
		$node = $this->expandMacro($name, $args, $modifiers, $nPrefix);
		if ($node->isEmpty) {
			$this->writeCode($node->openingCode, $this->output, $isRightmost);
		} else {
			$this->macroNode = $node;
			$node->saved = array(& $this->output, $isRightmost);
			$this->output = & $node->content;
		}
		return $node;
	}
	
	public function closeMacro($name, $args = NULL, $modifiers = NULL, $isRightmost = FALSE, $nPrefix = NULL)
	{
		$node = $this->macroNode;
		if (!$node || ($node->name !== $name && '' !== $name) || $modifiers
			|| ($args && $node->args && strncmp("$node->args ", "$args ", strlen($args) + 1))
			|| $nPrefix !== $node->prefix
		) {
			$name = $nPrefix
				? "</{$this->htmlNode->name}> for macro-attribute " . Parser::N_PREFIX . implode(' and ' . Parser::N_PREFIX, array_keys($this->htmlNode->macroAttrs))
				: '{/' . $name . ($args ? ' ' . $args : '') . $modifiers . '}';
			throw new CompileException("Unexpected $name" . ($node ? ', expecting ' . self::printEndTag($node) : ''));
		}
		$this->macroNode = $node->parentNode;
		if (!$node->args) {
			$node->setArgs($args);
		}
		$isLeftmost = $node->content ? trim(substr($this->output, strrpos("\n$this->output", "\n"))) === '' : FALSE;
		$node->closing = TRUE;
		$node->macro->nodeClosed($node);
		$this->output = & $node->saved[0];
		$this->writeCode($node->openingCode, $this->output, $node->saved[1]);
		$this->writeCode($node->closingCode, $node->content, $isRightmost, $isLeftmost);
		$this->output .= $node->content;
		return $node;
	}
	private function writeCode($code, & $output, $isRightmost, $isLeftmost = NULL)
	{
		if ($isRightmost) {
			$leftOfs = strrpos("\n$output", "\n");
			$isLeftmost = $isLeftmost === NULL ? trim(substr($output, $leftOfs)) === '' : $isLeftmost;
			if ($isLeftmost && substr($code, 0, 11) !== '<?php echo ') {
				$output = substr($output, 0, $leftOfs); 			} elseif (substr($code, -2) === '?>') {
				$code .= "\n"; 			}
		}
		$output .= $code;
	}
	
	public function writeAttrsMacro($code)
	{
		$attrs = $this->htmlNode->macroAttrs;
		$left = $right = array();
		foreach ($this->macros as $name => $foo) {
			$attrName = MacroNode::PREFIX_INNER . "-$name";
			if (isset($attrs[$attrName])) {
				if ($this->htmlNode->closing) {
					$left[] = array('closeMacro', $name, '', MacroNode::PREFIX_INNER);
				} else {
					array_unshift($right, array('openMacro', $name, $attrs[$attrName], MacroNode::PREFIX_INNER));
				}
				unset($attrs[$attrName]);
			}
		}
		foreach (array_reverse($this->macros) as $name => $foo) {
			$attrName = MacroNode::PREFIX_TAG . "-$name";
			if (isset($attrs[$attrName])) {
				$left[] = array('openMacro', $name, $attrs[$attrName], MacroNode::PREFIX_TAG);
				array_unshift($right, array('closeMacro', $name, '', MacroNode::PREFIX_TAG));
				unset($attrs[$attrName]);
			}
		}
		foreach ($this->macros as $name => $foo) {
			if (isset($attrs[$name])) {
				if ($this->htmlNode->closing) {
					$right[] = array('closeMacro', $name, '', MacroNode::PREFIX_NONE);
				} else {
					array_unshift($left, array('openMacro', $name, $attrs[$name], MacroNode::PREFIX_NONE));
				}
				unset($attrs[$name]);
			}
		}
		if ($attrs) {
			throw new CompileException('Unknown macro-attribute ' . Parser::N_PREFIX
				. implode(' and ' . Parser::N_PREFIX, array_keys($attrs)));
		}
		if (!$this->htmlNode->closing) {
			$this->htmlNode->attrCode = & $this->attrCodes[$uniq = ' n:' . substr(lcg_value(), 2, 10)];
			$code = substr_replace($code, $uniq, strrpos($code, '/>') ?: strrpos($code, '>'), 0);
		}
		foreach ($left as $item) {
			$node = $this->{$item[0]}($item[1], $item[2], NULL, NULL, $item[3]);
			if ($node->closing || $node->isEmpty) {
				$this->htmlNode->attrCode .= $node->attrCode;
				if ($node->isEmpty) {
					unset($this->htmlNode->macroAttrs[$node->name]);
				}
			}
		}
		$this->output .= $code;
		foreach ($right as $item) {
			$node = $this->{$item[0]}($item[1], $item[2], NULL, NULL, $item[3]);
			if ($node->closing) {
				$this->htmlNode->attrCode .= $node->attrCode;
			}
		}
		if ($right && substr($this->output, -2) === '?>') {
			$this->output .= "\n";
		}
	}
	
	public function expandMacro($name, $args, $modifiers = NULL, $nPrefix = NULL)
	{
		$inScript = in_array($this->context[0], array(self::CONTENT_JS, self::CONTENT_CSS));
		if (empty($this->macros[$name])) {
			throw new CompileException("Unknown macro {{$name}}" . ($inScript ? ' (in JavaScript or CSS, try to put a space after bracket.)' : ''));
		}
		if ($this->context[1] === self::CONTENT_URL) {
			$modifiers = preg_replace('#\|nosafeurl\s?(?=\||\z)#i', '', $modifiers, -1, $found);
			if (!$found && !preg_match('#\|datastream(?=\s|\||\z)#i', $modifiers)) {
				$modifiers .= '|safeurl';
			}
		}
		$modifiers = preg_replace('#\|noescape\s?(?=\||\z)#i', '', $modifiers, -1, $found);
		if (!$found && strpbrk($name, '=~%^&_')) {
			$modifiers .= '|escape';
		}
		if (!$found && $inScript && $name === '=' && preg_match('#["\'] *\z#', $this->tokens[$this->position - 1]->text)) {
			throw new CompileException("Do not place {$this->tokens[$this->position]->text} inside quotes.");
		}
		foreach (array_reverse($this->macros[$name]) as $macro) {
			$node = new MacroNode($macro, $name, $args, $modifiers, $this->macroNode, $this->htmlNode, $nPrefix);
			if ($macro->nodeOpened($node) !== FALSE) {
				return $node;
			}
		}
		throw new CompileException($nPrefix ? 'Unknown macro-attribute ' . Parser::N_PREFIX . "$nPrefix-$name" : "Unhandled macro {{$name}}");
	}
	private static function printEndTag(MacroNode $node)
	{
		if ($node->prefix) {
			return  "</{$node->htmlNode->name}> for macro-attribute " . Parser::N_PREFIX
				. implode(' and ' . Parser::N_PREFIX, array_keys($node->htmlNode->macroAttrs));
		} else {
			return "{/$node->name}";
		}
	}
}
}
namespace Latte{
class Engine extends LatteObject
{
	
	const CONTENT_HTML = Compiler::CONTENT_HTML,
		CONTENT_XHTML = Compiler::CONTENT_XHTML,
		CONTENT_XML = Compiler::CONTENT_XML,
		CONTENT_JS = Compiler::CONTENT_JS,
		CONTENT_CSS = Compiler::CONTENT_CSS,
		CONTENT_ICAL = Compiler::CONTENT_ICAL,
		CONTENT_TEXT = Compiler::CONTENT_TEXT;
	
	public $onCompile = array();
	
	private $parser;
	
	private $compiler;
	
	private $loader;
	
	private $contentType = self::CONTENT_HTML;
	
	private $tempDirectory;
	
	private $autoRefresh = TRUE;
	
	private $filters = array(
		NULL => array(), 		'bytes' => 'Latte\Runtime\Filters::bytes',
		'capitalize' => 'Latte\Runtime\Filters::capitalize',
		'datastream' => 'Latte\Runtime\Filters::dataStream',
		'date' => 'Latte\Runtime\Filters::date',
		'escapecss' => 'Latte\Runtime\Filters::escapeCss',
		'escapehtml' => 'Latte\Runtime\Filters::escapeHtml',
		'escapehtmlcomment' => 'Latte\Runtime\Filters::escapeHtmlComment',
		'escapeical' => 'Latte\Runtime\Filters::escapeICal',
		'escapejs' => 'Latte\Runtime\Filters::escapeJs',
		'escapeurl' => 'rawurlencode',
		'escapexml' => 'Latte\Runtime\Filters::escapeXML',
		'firstupper' => 'Latte\Runtime\Filters::firstUpper',
		'implode' => 'implode',
		'indent' => 'Latte\Runtime\Filters::indent',
		'lower' => 'Latte\Runtime\Filters::lower',
		'nl2br' => 'Latte\Runtime\Filters::nl2br',
		'number' => 'number_format',
		'repeat' => 'str_repeat',
		'replace' => 'Latte\Runtime\Filters::replace',
		'replacere' => 'Latte\Runtime\Filters::replaceRe',
		'safeurl' => 'Latte\Runtime\Filters::safeUrl',
		'strip' => 'Latte\Runtime\Filters::strip',
		'striptags' => 'strip_tags',
		'substr' => 'Latte\Runtime\Filters::substring',
		'trim' => 'Latte\Runtime\Filters::trim',
		'truncate' => 'Latte\Runtime\Filters::truncate',
		'upper' => 'Latte\Runtime\Filters::upper',
	);
	
	private $baseTemplateClass = 'Latte\Template';
	
	public function render($name, array $params = array())
	{
		$template = new $this->baseTemplateClass($params, $this->filters, $this, $name);
		$this->loadCacheFile($name, $template->getParameters());
	}
	
	public function renderToString($name, array $params = array())
	{
		ob_start();
		try {
			$this->render($name, $params);
		} catch (\Exception $e) {
			ob_end_clean();
			throw $e;
		}
		return ob_get_clean();
	}
	
	public function compile($name)
	{
		foreach ($this->onCompile ?: array() as $cb) {
			call_user_func(Helpers::checkCallback($cb), $this);
		}
		$this->onCompile = array();
		$source = $this->getLoader()->getContent($name);
		try {
			$tokens = $this->getParser()->setContentType($this->contentType)
				->parse($source);
			$code = $this->getCompiler()->setContentType($this->contentType)
				->compile($tokens);
			if (preg_match('#^\S{5,100}\z#', $name)) {
				$code = "<?php\n// source: $name\n?>" . $code;
			}
		} catch (\Exception $e) {
			$e = $e instanceof CompileException ? $e : new CompileException("Thrown exception '{$e->getMessage()}'", NULL, $e);
			throw $e->setSource($source, $this->getCompiler()->getLine(), $name);
		}
		$code = Helpers::optimizePhp($code);
		return $code;
	}
	
	private function loadCacheFile($name, $params)
	{
		if (!$this->tempDirectory) {
			return call_user_func(function() {
				foreach (func_get_arg(1) as $__k => $__v) {
					$$__k = $__v;
				}
				unset($__k, $__v);
				eval('?>' . func_get_arg(0));
			}, $this->compile($name), $params);
		}
		$file = $this->getCacheFile($name);
		$handle = fopen($file, 'c+');
		if (!$handle) {
			throw new \RuntimeException("Unable to open or create file '$file'.");
		}
		flock($handle, LOCK_SH);
		$stat = fstat($handle);
		if (!$stat['size'] || ($this->autoRefresh && $this->getLoader()->isExpired($name, $stat['mtime']))) {
			ftruncate($handle, 0);
			flock($handle, LOCK_EX);
			$stat = fstat($handle);
			if (!$stat['size']) {
				$code = $this->compile($name);
				if (fwrite($handle, $code, strlen($code)) !== strlen($code)) {
					ftruncate($handle, 0);
					throw new \RuntimeException("Unable to write file '$file'.");
				}
			}
			flock($handle, LOCK_SH); 		}
		call_user_func(function() {
			foreach (func_get_arg(1) as $__k => $__v) {
				$$__k = $__v;
			}
			unset($__k, $__v);
			include func_get_arg(0);
		}, $file, $params);
	}
	
	public function getCacheFile($name)
	{
		if (!$this->tempDirectory) {
			throw new \RuntimeException('Set path to temporary directory using setTempDirectory().');
		} elseif (!is_dir($this->tempDirectory)) {
			mkdir($this->tempDirectory);
		}
		$file = md5($name);
		if (preg_match('#\b\w.{10,50}$#', $name, $m)) {
			$file = trim(preg_replace('#\W+#', '-', $m[0]), '-') . '-' . $file;
		}
		return $this->tempDirectory . '/' . $file . '.php';
	}
	
	public function addFilter($name, $callback)
	{
		if ($name == NULL) { 			array_unshift($this->filters[NULL], $callback);
		} else {
			$this->filters[strtolower($name)] = $callback;
		}
		return $this;
	}
	
	public function getFilters()
	{
		return $this->filters;
	}
	
	public function addMacro($name, IMacro $macro)
	{
		$this->getCompiler()->addMacro($name, $macro);
		return $this;
	}
	
	public function setContentType($type)
	{
		$this->contentType = $type;
		return $this;
	}
	
	public function setTempDirectory($path)
	{
		$this->tempDirectory = $path;
		return $this;
	}
	
	public function setAutoRefresh($on = TRUE)
	{
		$this->autoRefresh = (bool) $on;
		return $this;
	}
	
	public function getParser()
	{
		if (!$this->parser) {
			$this->parser = new Parser;
		}
		return $this->parser;
	}
	
	public function getCompiler()
	{
		if (!$this->compiler) {
			$this->compiler = new Compiler;
			Macros\CoreMacros::install($this->compiler);
			Macros\BlockMacros::install($this->compiler);
		}
		return $this->compiler;
	}
	
	public function setLoader(ILoader $loader)
	{
		$this->loader = $loader;
		return $this;
	}
	
	public function getLoader()
	{
		if (!$this->loader) {
			$this->loader = new Loaders\FileLoader;
		}
		return $this->loader;
	}
}
}
namespace Latte{
class Helpers
{
	
	public static $emptyElements = array(
		'img'=>1,'hr'=>1,'br'=>1,'input'=>1,'meta'=>1,'area'=>1,'embed'=>1,'keygen'=>1,'source'=>1,'base'=>1,
		'col'=>1,'link'=>1,'param'=>1,'basefont'=>1,'frame'=>1,'isindex'=>1,'wbr'=>1,'command'=>1,'track'=>1
	);
	
	public static function checkCallback($callable)
	{
		if (!is_callable($callable, FALSE, $text)) {
			throw new \InvalidArgumentException("Callback '$text' is not callable.");
		}
		return $callable;
	}
	
	public static function optimizePhp($source, $lineLength = 80)
	{
		$res = $php = '';
		$lastChar = ';';
		$tokens = new \ArrayIterator(token_get_all($source));
		foreach ($tokens as $n => $token) {
			if (is_array($token)) {
				if ($token[0] === T_INLINE_HTML) {
					$lastChar = '';
					$res .= $token[1];
				} elseif ($token[0] === T_CLOSE_TAG) {
					$next = isset($tokens[$n + 1]) ? $tokens[$n + 1] : NULL;
					if (substr($res, -1) !== '<' && preg_match('#^<\?php\s*\z#', $php)) {
						$php = ''; 
					} elseif (is_array($next) && $next[0] === T_OPEN_TAG && (!isset($tokens[$n + 2][1]) || $tokens[$n + 2][1] !== 'xml')) { 						if (!strspn($lastChar, ';{}:/')) {
							$php .= $lastChar = ';';
						}
						if (substr($next[1], -1) === "\n") {
							$php .= "\n";
						}
						$tokens->next();
					} elseif ($next) {
						$res .= preg_replace('#;?(\s)*\z#', '$1', $php) . $token[1]; 						if (strlen($res) - strrpos($res, "\n") > $lineLength
							&& (!is_array($next) || strpos($next[1], "\n") === FALSE)
						) {
							$res .= "\n";
						}
						$php = '';
					} else { 						if (!strspn($lastChar, '};')) {
							$php .= ';';
						}
					}
				} elseif ($token[0] === T_ELSE || $token[0] === T_ELSEIF) {
					if ($tokens[$n + 1] === ':' && $lastChar === '}') {
						$php .= ';'; 					}
					$lastChar = '';
					$php .= $token[1];
				} elseif ($token[0] === T_OPEN_TAG && $token[1] === '<?' && isset($tokens[$n+1][1]) && $tokens[$n+1][1] === 'xml') {
					$lastChar = '';
					$res .= '<<?php ?>?';
					for ($tokens->next(); $tokens->valid(); $tokens->next()) {
						$token = $tokens->current();
						$res .= is_array($token) ? $token[1] : $token;
						if ($token[0] === T_CLOSE_TAG) {
							break;
						}
					}
				} else {
					if (!in_array($token[0], array(T_WHITESPACE, T_COMMENT, T_DOC_COMMENT, T_OPEN_TAG))) {
						$lastChar = '';
					}
					$php .= $token[1];
				}
			} else {
				$php .= $lastChar = $token;
			}
		}
		return $res . $php;
	}
}
}
namespace Latte{
class HtmlNode extends LatteObject
{
	
	public $name;
	
	public $isEmpty = FALSE;
	
	public $attrs = array();
	
	public $macroAttrs = array();
	
	public $closing = FALSE;
	
	public $parentNode;
	
	public $attrCode;
	
	public $offset;
	public function __construct($name, self $parentNode = NULL)
	{
		$this->name = $name;
		$this->parentNode = $parentNode;
	}
}
}
namespace Latte{
interface ILoader
{
	
	function getContent($name);
	
	function isExpired($name, $time);
	
	function getChildName($name, $parent = NULL);
}
}
namespace Latte{
class MacroNode extends LatteObject
{
	const PREFIX_INNER = 'inner',
		PREFIX_TAG = 'tag',
		PREFIX_NONE = 'none';
	
	public $macro;
	
	public $name;
	
	public $isEmpty = FALSE;
	
	public $args;
	
	public $modifiers;
	
	public $closing = FALSE;
	
	public $tokenizer;
	
	public $parentNode;
	
	public $openingCode;
	
	public $closingCode;
	
	public $attrCode;
	
	public $content;
	
	public $data;
	
	public $htmlNode;
	
	public $prefix;
	public $saved;
	public function __construct(IMacro $macro, $name, $args = NULL, $modifiers = NULL, self $parentNode = NULL, HtmlNode $htmlNode = NULL, $prefix = NULL)
	{
		$this->macro = $macro;
		$this->name = (string) $name;
		$this->modifiers = (string) $modifiers;
		$this->parentNode = $parentNode;
		$this->htmlNode = $htmlNode;
		$this->prefix = $prefix;
		$this->data = new \stdClass;
		$this->setArgs($args);
	}
	public function setArgs($args)
	{
		$this->args = (string) $args;
		$this->tokenizer = new MacroTokens($this->args);
	}
}
}
namespace Latte{
class TokenIterator extends LatteObject
{
	
	public $tokens;
	
	public $position = -1;
	
	public $ignored = array();
	
	public function __construct(array $tokens)
	{
		$this->tokens = $tokens;
	}
	
	public function currentToken()
	{
		return isset($this->tokens[$this->position])
			? $this->tokens[$this->position]
			: NULL;
	}
	
	public function currentValue()
	{
		return isset($this->tokens[$this->position])
			? $this->tokens[$this->position][Tokenizer::VALUE]
			: NULL;
	}
	
	public function nextToken()
	{
		return $this->scan(func_get_args(), TRUE, TRUE); 	}
	
	public function nextValue()
	{
		return $this->scan(func_get_args(), TRUE, TRUE, TRUE); 	}
	
	public function nextAll()
	{
		return $this->scan(func_get_args(), FALSE, TRUE); 	}
	
	public function nextUntil($arg)
	{
		return $this->scan(func_get_args(), FALSE, TRUE, FALSE, TRUE); 	}
	
	public function joinAll()
	{
		return $this->scan(func_get_args(), FALSE, TRUE, TRUE); 	}
	
	public function joinUntil($arg)
	{
		return $this->scan(func_get_args(), FALSE, TRUE, TRUE, TRUE); 	}
	
	public function isCurrent($arg)
	{
		if (!isset($this->tokens[$this->position])) {
			return FALSE;
		}
		$args = func_get_args();
		$token = $this->tokens[$this->position];
		return in_array($token[Tokenizer::VALUE], $args, TRUE)
			|| (isset($token[Tokenizer::TYPE]) && in_array($token[Tokenizer::TYPE], $args, TRUE));
	}
	
	public function isNext()
	{
		return (bool) $this->scan(func_get_args(), TRUE, FALSE); 	}
	
	public function isPrev()
	{
		return (bool) $this->scan(func_get_args(), TRUE, FALSE, FALSE, FALSE, TRUE); 	}
	
	public function reset()
	{
		$this->position = -1;
		return $this;
	}
	protected function next()
	{
		$this->position++;
	}
	
	protected function scan($wanted, $onlyFirst, $advance, $strings = FALSE, $until = FALSE, $prev = FALSE)
	{
		$res = $onlyFirst ? NULL : ($strings ? '' : array());
		$pos = $this->position + ($prev ? -1 : 1);
		do {
			if (!isset($this->tokens[$pos])) {
				if (!$wanted && $advance && !$prev && $pos <= count($this->tokens)) {
					$this->next();
				}
				return $res;
			}
			$token = $this->tokens[$pos];
			$type = isset($token[Tokenizer::TYPE]) ? $token[Tokenizer::TYPE] : NULL;
			if (!$wanted || (in_array($token[Tokenizer::VALUE], $wanted, TRUE) || in_array($type, $wanted, TRUE)) ^ $until) {
				while ($advance && !$prev && $pos > $this->position) {
					$this->next();
				}
				if ($onlyFirst) {
					return $strings ? $token[Tokenizer::VALUE] : $token;
				} elseif ($strings) {
					$res .= $token[Tokenizer::VALUE];
				} else {
					$res[] = $token;
				}
			} elseif ($until || !in_array($type, $this->ignored, TRUE)) {
				return $res;
			}
			$pos += $prev ? -1 : 1;
		} while (TRUE);
	}
}
}
namespace Latte{
class MacroTokens extends TokenIterator
{
	const T_WHITESPACE = 1,
		T_COMMENT = 2,
		T_SYMBOL = 3,
		T_NUMBER = 4,
		T_VARIABLE = 5,
		T_STRING = 6,
		T_CAST = 7,
		T_KEYWORD = 8,
		T_CHAR = 9;
	
	private static $tokenizer;
	
	public $depth = 0;
	public function __construct($input = NULL)
	{
		parent::__construct(is_array($input) ? $input : $this->parse($input));
		$this->ignored = array(self::T_COMMENT, self::T_WHITESPACE);
	}
	public function parse($s)
	{
		self::$tokenizer = self::$tokenizer ?: new Tokenizer(array(
			self::T_WHITESPACE => '\s+',
			self::T_COMMENT => '(?s)/\*.*?\*/',
			self::T_STRING => Parser::RE_STRING,
			self::T_KEYWORD => '(?:true|false|null|and|or|xor|clone|new|instanceof|return|continue|break|[A-Z_][A-Z0-9_]{2,})(?![\w\pL_])', 			self::T_CAST => '\((?:expand|string|array|int|integer|float|bool|boolean|LatteObject)\)', 			self::T_VARIABLE => '\$[\w\pL_]+',
			self::T_NUMBER => '[+-]?[0-9]+(?:\.[0-9]+)?(?:e[0-9]+)?',
			self::T_SYMBOL => '[\w\pL_]+(?:-[\w\pL_]+)*',
			self::T_CHAR => '::|=>|->|\+\+|--|<<|>>|<=|>=|===|!==|==|!=|<>|&&|\|\||[^"\']', 		), 'u');
		return self::$tokenizer->tokenize($s);
	}
	
	public function append($val, $position = NULL)
	{
		if ($val != NULL) { 			array_splice(
				$this->tokens,
				$position === NULL ? count($this->tokens) : $position, 0,
				is_array($val) ? array($val) : $this->parse($val)
			);
		}
		return $this;
	}
	
	public function prepend($val)
	{
		if ($val != NULL) { 			array_splice($this->tokens, 0, 0, is_array($val) ? array($val) : $this->parse($val));
		}
		return $this;
	}
	
	public function fetchWord()
	{
		$words = $this->fetchWords();
		return $words ? implode(':', $words) : FALSE;
	}
	
	public function fetchWords()
	{
		do {
			$words[] = $this->joinUntil(self::T_WHITESPACE, ',', ':');
		} while ($this->nextToken(':'));
		$this->nextToken(',');
		$this->nextAll(self::T_WHITESPACE, self::T_COMMENT);
		return $words === array('') ? array() : $words;
	}
	public function reset()
	{
		$this->depth = 0;
		return parent::reset();
	}
	protected function next()
	{
		parent::next();
		if ($this->isCurrent('[', '(', '{')) {
			$this->depth++;
		} elseif ($this->isCurrent(']', ')', '}')) {
			$this->depth--;
		}
	}
}
}
namespace Latte{
class Parser extends LatteObject
{
	
	const RE_STRING = '\'(?:\\\\.|[^\'\\\\])*\'|"(?:\\\\.|[^"\\\\])*"';
	
	const N_PREFIX = 'n:';
	
	public $defaultSyntax = 'latte';
	
	public $shortNoEscape = FALSE;
	
	public $syntaxes = array(
		'latte' => array('\\{(?![\\s\'"{}])', '\\}'), 		'double' => array('\\{\\{(?![\\s\'"{}])', '\\}\\}'), 		'asp' => array('<%\s*', '\s*%>'), 
		'python' => array('\\{[{%]\s*', '\s*[%}]\\}'), 		'off' => array('[^\x00-\xFF]', ''),
	);
	
	private $macroRe;
	
	private $input;
	
	private $output;
	
	private $offset;
	
	private $context;
	
	private $lastHtmlTag;
	
	private $syntaxEndTag;
	
	private $xmlMode;
	
	const CONTEXT_HTML_TEXT = 'htmlText',
		CONTEXT_CDATA = 'cdata',
		CONTEXT_HTML_TAG = 'htmlTag',
		CONTEXT_HTML_ATTRIBUTE = 'htmlAttribute',
		CONTEXT_RAW = 'raw',
		CONTEXT_HTML_COMMENT = 'htmlComment';
	
	public function parse($input)
	{
		if (substr($input, 0, 3) === "\xEF\xBB\xBF") { 			$input = substr($input, 3);
		}
		if (!preg_match('##u', $input)) {
			throw new \InvalidArgumentException('Template is not valid UTF-8 stream.');
		}
		$input = str_replace("\r\n", "\n", $input);
		$this->input = $input;
		$this->output = array();
		$this->offset = 0;
		$this->setSyntax($this->defaultSyntax);
		$this->setContext(self::CONTEXT_HTML_TEXT);
		$this->lastHtmlTag = $this->syntaxEndTag = NULL;
		while ($this->offset < strlen($input)) {
			$matches = $this->{"context".$this->context[0]}();
			if (!$matches) { 				break;
			} elseif (!empty($matches['comment'])) { 				$this->addToken(Token::COMMENT, $matches[0]);
			} elseif (!empty($matches['macro'])) { 				$token = $this->addToken(Token::MACRO_TAG, $matches[0]);
				list($token->name, $token->value, $token->modifiers, $token->empty) = $this->parseMacroTag($matches['macro']);
			}
			$this->filter();
		}
		if ($this->offset < strlen($input)) {
			$this->addToken(Token::TEXT, substr($this->input, $this->offset));
		}
		return $this->output;
	}
	
	private function contextHtmlText()
	{
		$matches = $this->match('~
			(?:(?<=\n|^)[ \t]*)?<(?P<closing>/?)(?P<tag>[a-z0-9:]+)|  ##  begin of HTML tag <tag </tag - ignores <!DOCTYPE
			<(?P<htmlcomment>!--(?!>))|     ##  begin of HTML comment <!--, but not <!-->
			'.$this->macroRe.'              ##  macro tag
		~xsi');
		if (!empty($matches['htmlcomment'])) { 			$this->addToken(Token::HTML_TAG_BEGIN, $matches[0]);
			$this->setContext(self::CONTEXT_HTML_COMMENT);
		} elseif (!empty($matches['tag'])) { 			$token = $this->addToken(Token::HTML_TAG_BEGIN, $matches[0]);
			$token->name = $matches['tag'];
			$token->closing = (bool) $matches['closing'];
			$this->lastHtmlTag = $matches['closing'] . strtolower($matches['tag']);
			$this->setContext(self::CONTEXT_HTML_TAG);
		}
		return $matches;
	}
	
	private function contextCData()
	{
		$matches = $this->match('~
			</(?P<tag>'.$this->lastHtmlTag.')(?![a-z0-9:])| ##  end HTML tag </tag
			'.$this->macroRe.'              ##  macro tag
		~xsi');
		if (!empty($matches['tag'])) { 			$token = $this->addToken(Token::HTML_TAG_BEGIN, $matches[0]);
			$token->name = $this->lastHtmlTag;
			$token->closing = TRUE;
			$this->lastHtmlTag = '/' . $this->lastHtmlTag;
			$this->setContext(self::CONTEXT_HTML_TAG);
		}
		return $matches;
	}
	
	private function contextHtmlTag()
	{
		$matches = $this->match('~
			(?P<end>\ ?/?>)([ \t]*\n)?|  ##  end of HTML tag
			'.$this->macroRe.'|          ##  macro tag
			\s*(?P<attr>[^\s/>={]+)(?:\s*=\s*(?P<value>["\']|[^\s/>{]+))? ## beginning of HTML attribute
		~xsi');
		if (!empty($matches['end'])) { 			$this->addToken(Token::HTML_TAG_END, $matches[0]);
			$this->setContext(!$this->xmlMode && in_array($this->lastHtmlTag, array('script', 'style')) ? self::CONTEXT_CDATA : self::CONTEXT_HTML_TEXT);
		} elseif (isset($matches['attr']) && $matches['attr'] !== '') { 			$token = $this->addToken(Token::HTML_ATTRIBUTE, $matches[0]);
			$token->name = $matches['attr'];
			$token->value = isset($matches['value']) ? $matches['value'] : '';
			if ($token->value === '"' || $token->value === "'") { 				if (strncmp($token->name, self::N_PREFIX, strlen(self::N_PREFIX)) === 0) {
					$token->value = '';
					if ($m = $this->match('~(.*?)' . $matches['value'] . '~xsi')) {
						$token->value = $m[1];
						$token->text .= $m[0];
					}
				} else {
					$this->setContext(self::CONTEXT_HTML_ATTRIBUTE, $matches['value']);
				}
			}
		}
		return $matches;
	}
	
	private function contextHtmlAttribute()
	{
		$matches = $this->match('~
			(?P<quote>'.$this->context[1].')|  ##  end of HTML attribute
			'.$this->macroRe.'                 ##  macro tag
		~xsi');
		if (!empty($matches['quote'])) { 			$this->addToken(Token::TEXT, $matches[0]);
			$this->setContext(self::CONTEXT_HTML_TAG);
		}
		return $matches;
	}
	
	private function contextHtmlComment()
	{
		$matches = $this->match('~
			(?P<htmlcomment>-->)|   ##  end of HTML comment
			'.$this->macroRe.'      ##  macro tag
		~xsi');
		if (!empty($matches['htmlcomment'])) { 			$this->addToken(Token::HTML_TAG_END, $matches[0]);
			$this->setContext(self::CONTEXT_HTML_TEXT);
		}
		return $matches;
	}
	
	private function contextRaw()
	{
		$matches = $this->match('~
			'.$this->macroRe.'     ##  macro tag
		~xsi');
		return $matches;
	}
	
	private function match($re)
	{
		if (!preg_match($re, $this->input, $matches, PREG_OFFSET_CAPTURE, $this->offset)) {
			if (preg_last_error()) {
				throw new RegexpException(NULL, preg_last_error());
			}
			return array();
		}
		$value = substr($this->input, $this->offset, $matches[0][1] - $this->offset);
		if ($value !== '') {
			$this->addToken(Token::TEXT, $value);
		}
		$this->offset = $matches[0][1] + strlen($matches[0][0]);
		foreach ($matches as $k => $v) {
			$matches[$k] = $v[0];
		}
		return $matches;
	}
	
	public function setContentType($type)
	{
		if (strpos($type, 'html') !== FALSE) {
			$this->xmlMode = FALSE;
			$this->setContext(self::CONTEXT_HTML_TEXT);
		} elseif (strpos($type, 'xml') !== FALSE) {
			$this->xmlMode = TRUE;
			$this->setContext(self::CONTEXT_HTML_TEXT);
		} else {
			$this->setContext(self::CONTEXT_RAW);
		}
		return $this;
	}
	
	public function setContext($context, $quote = NULL)
	{
		$this->context = array($context, $quote);
		return $this;
	}
	
	public function setSyntax($type)
	{
		$type = $type ?: $this->defaultSyntax;
		if (isset($this->syntaxes[$type])) {
			$this->setDelimiters($this->syntaxes[$type][0], $this->syntaxes[$type][1]);
		} else {
			throw new \InvalidArgumentException("Unknown syntax '$type'");
		}
		return $this;
	}
	
	public function setDelimiters($left, $right)
	{
		$this->macroRe = '
			(?P<comment>' . $left . '\\*.*?\\*' . $right . '\n{0,2})|
			' . $left . '
				(?P<macro>(?:
					' . self::RE_STRING . '|
					\{(?:' . self::RE_STRING . '|[^\'"{}])*+\}|
					[^\'"{}]
				)+?)
			' . $right . '
			(?P<rmargin>[ \t]*(?=\n))?
		';
		return $this;
	}
	
	public function parseMacroTag($tag)
	{
		if (!preg_match('~^
			(
				(?P<name>\?|/?[a-z]\w*+(?:[.:]\w+)*+(?!::|\(|\\\\))|   ## ?, name, /name, but not function( or class:: or namespace\
				(?P<noescape>!?)(?P<shortname>/?[=\~#%^&_]?)      ## !expression, !=expression, ...
			)(?P<args>.*?)
			(?P<modifiers>\|[a-z](?:'.Parser::RE_STRING.'|[^\'"])*(?<!/))?
			(?P<empty>/?\z)
		()\z~isx', $tag, $match)) {
			if (preg_last_error()) {
				throw new RegexpException(NULL, preg_last_error());
			}
			return FALSE;
		}
		if ($match['name'] === '') {
			$match['name'] = $match['shortname'] ?: '=';
			if ($match['noescape']) {
				if (!$this->shortNoEscape) {
					trigger_error("The noescape shortcut {!...} is deprecated, use {...|noescape} modifier on line {$this->getLine()}.", E_USER_DEPRECATED);
				}
				$match['modifiers'] .= '|noescape';
			}
		}
		return array($match['name'], trim($match['args']), $match['modifiers'], (bool) $match['empty']);
	}
	private function addToken($type, $text)
	{
		$this->output[] = $token = new Token;
		$token->type = $type;
		$token->text = $text;
		$token->line = $this->getLine();
		return $token;
	}
	private function getLine()
	{
		return substr_count($this->input, "\n", 0, max(1, $this->offset - 1)) + 1;
	}
	
	protected function filter()
	{
		$token = end($this->output);
		if ($token->type === Token::MACRO_TAG && $token->name === '/syntax') {
			$this->setSyntax($this->defaultSyntax);
			$token->type = Token::COMMENT;
		} elseif ($token->type === Token::MACRO_TAG && $token->name === 'syntax') {
			$this->setSyntax($token->value);
			$token->type = Token::COMMENT;
		} elseif ($token->type === Token::HTML_ATTRIBUTE && $token->name === 'n:syntax') {
			$this->setSyntax($token->value);
			$this->syntaxEndTag = '/' . $this->lastHtmlTag;
			$token->type = Token::COMMENT;
		} elseif ($token->type === Token::HTML_TAG_END && $this->lastHtmlTag === $this->syntaxEndTag) {
			$this->setSyntax($this->defaultSyntax);
		} elseif ($token->type === Token::MACRO_TAG && $token->name === 'contentType') {
			$this->setContentType($token->value);
		}
	}
}
}
namespace Latte{
class PhpWriter extends LatteObject
{
	
	private $tokens;
	
	private $modifiers;
	
	private $compiler;
	public static function using(MacroNode $node, Compiler $compiler = NULL)
	{
		return new static($node->tokenizer, $node->modifiers, $compiler);
	}
	public function __construct(MacroTokens $tokens, $modifiers = NULL, Compiler $compiler = NULL)
	{
		$this->tokens = $tokens;
		$this->modifiers = $modifiers;
		$this->compiler = $compiler;
	}
	
	public function write($mask)
	{
		$mask = preg_replace('#%(node|\d+)\.#', '%$1_', $mask);
		$me = $this;
		$mask = preg_replace_callback('#%escape(\(([^()]*+|(?1))+\))#', function($m) use ($me) {
			return $me->escapeFilter(new MacroTokens(substr($m[1], 1, -1)))->joinAll();
		}, $mask);
		$mask = preg_replace_callback('#%modify(\(([^()]*+|(?1))+\))#', function($m) use ($me) {
			return $me->formatModifiers(substr($m[1], 1, -1));
		}, $mask);
		$args = func_get_args();
		$pos = $this->tokens->position;
		$word = strpos($mask, '%node_word') === FALSE ? NULL : $this->tokens->fetchWord();
		$code = preg_replace_callback('#([,+]\s*)?%(node_|\d+_|)(word|var|raw|array|args)(\?)?(\s*\+\s*)?()#',
		function($m) use ($me, $word, & $args) {
			list(, $l, $source, $format, $cond, $r) = $m;
			switch ($source) {
				case 'node_':
					$arg = $word; break;
				case '':
					$arg = next($args); break;
				default:
					$arg = $args[$source + 1]; break;
			}
			switch ($format) {
				case 'word':
					$code = $me->formatWord($arg); break;
				case 'args':
					$code = $me->formatArgs(); break; 				case 'array':
					$code = $me->formatArray(); 					$code = $cond && $code === 'array()' ? '' : $code; break;
				case 'var':
					$code = var_export($arg, TRUE); break;
				case 'raw':
					$code = (string) $arg; break;
			}
			if ($cond && $code === '') {
				return $r ? $l : $r;
			} else {
				return $l . $code . $r;
			}
		}, $mask);
		$this->tokens->position = $pos;
		return $code;
	}
	
	public function formatModifiers($var)
	{
		$tokens = new MacroTokens(ltrim($this->modifiers, '|'));
		$tokens = $this->preprocess($tokens);
		$tokens = $this->modifiersFilter($tokens, $var);
		$tokens = $this->quoteFilter($tokens);
		return $tokens->joinAll();
	}
	
	public function formatArgs(MacroTokens $tokens = NULL)
	{
		$tokens = $this->preprocess($tokens);
		$tokens = $this->quoteFilter($tokens);
		return $tokens->joinAll();
	}
	
	public function formatArray(MacroTokens $tokens = NULL)
	{
		$tokens = $this->preprocess($tokens);
		$tokens = $this->expandFilter($tokens);
		$tokens = $this->quoteFilter($tokens);
		return $tokens->joinAll();
	}
	
	public function formatWord($s)
	{
		return (is_numeric($s) || preg_match('#^\$|[\'"]|^true\z|^false\z|^null\z#i', $s))
			? $this->formatArgs(new MacroTokens($s))
			: '"' . $s . '"';
	}
	
	public function preprocess(MacroTokens $tokens = NULL)
	{
		$tokens = $tokens === NULL ? $this->tokens : $tokens;
		$tokens = $this->removeCommentsFilter($tokens);
		$tokens = $this->shortTernaryFilter($tokens);
		$tokens = $this->shortArraysFilter($tokens);
		return $tokens;
	}
	
	public function removeCommentsFilter(MacroTokens $tokens)
	{
		$res = new MacroTokens;
		while ($tokens->nextToken()) {
			if (!$tokens->isCurrent(MacroTokens::T_COMMENT)) {
				$res->append($tokens->currentToken());
			}
		}
		return $res;
	}
	
	public function shortTernaryFilter(MacroTokens $tokens)
	{
		$res = new MacroTokens;
		$inTernary = array();
		while ($tokens->nextToken()) {
			if ($tokens->isCurrent('?')) {
				$inTernary[] = $tokens->depth;
			} elseif ($tokens->isCurrent(':')) {
				array_pop($inTernary);
			} elseif ($tokens->isCurrent(',', ')', ']') && end($inTernary) === $tokens->depth + !$tokens->isCurrent(',')) {
				$res->append(' : NULL');
				array_pop($inTernary);
			}
			$res->append($tokens->currentToken());
		}
		if ($inTernary) {
			$res->append(' : NULL');
		}
		return $res;
	}
	
	public function shortArraysFilter(MacroTokens $tokens)
	{
		$res = new MacroTokens;
		$arrays = array();
		while ($tokens->nextToken()) {
			if ($tokens->isCurrent('[')) {
				if ($arrays[] = !$tokens->isPrev(']', ')', MacroTokens::T_SYMBOL, MacroTokens::T_VARIABLE, MacroTokens::T_KEYWORD)) {
					$res->append('array(');
					continue;
				}
			} elseif ($tokens->isCurrent(']')) {
				if (array_pop($arrays) === TRUE) {
					$res->append(')');
					continue;
				}
			}
			$res->append($tokens->currentToken());
		}
		return $res;
	}
	
	public function expandFilter(MacroTokens $tokens)
	{
		$res = new MacroTokens('array(');
		$expand = NULL;
		while ($tokens->nextToken()) {
			if ($tokens->isCurrent('(expand)') && $tokens->depth === 0) {
				$expand = TRUE;
				$res->append('),');
			} elseif ($expand && $tokens->isCurrent(',') && !$tokens->depth) {
				$expand = FALSE;
				$res->append(', array(');
			} else {
				$res->append($tokens->currentToken());
			}
		}
		if ($expand !== NULL) {
			$res->prepend('array_merge(')->append($expand ? ', array()' : ')');
		}
		return $res->append(')');
	}
	
	public function quoteFilter(MacroTokens $tokens)
	{
		$res = new MacroTokens;
		while ($tokens->nextToken()) {
			$res->append($tokens->isCurrent(MacroTokens::T_SYMBOL)
				&& (!$tokens->isPrev() || $tokens->isPrev(',', '(', '[', '=>', ':', '?', '.', '<', '>', '<=', '>=', '===', '!==', '==', '!=', '<>', '&&', '||', '=', 'and', 'or', 'xor'))
				&& (!$tokens->isNext() || $tokens->isNext(',', ';', ')', ']', '=>', ':', '?', '.', '<', '>', '<=', '>=', '===', '!==', '==', '!=', '<>', '&&', '||', 'and', 'or', 'xor'))
				? "'" . $tokens->currentValue() . "'"
				: $tokens->currentToken()
			);
		}
		return $res;
	}
	
	public function modifiersFilter(MacroTokens $tokens, $var)
	{
		$inside = FALSE;
		$res = new MacroTokens($var);
		while ($tokens->nextToken()) {
			if ($tokens->isCurrent(MacroTokens::T_WHITESPACE)) {
				$res->append(' ');
			} elseif ($inside) {
				if ($tokens->isCurrent(':', ',')) {
					$res->append(', ');
					$tokens->nextAll(MacroTokens::T_WHITESPACE);
				} elseif ($tokens->isCurrent('|')) {
					$res->append(')');
					$inside = FALSE;
				} else {
					$res->append($tokens->currentToken());
				}
			} else {
				if ($tokens->isCurrent(MacroTokens::T_SYMBOL)) {
					if ($this->compiler && $tokens->isCurrent('escape')) {
						$res = $this->escapeFilter($res);
						$tokens->nextToken('|');
					} elseif (!strcasecmp($tokens->currentValue(), 'safeurl')) {
						$res->prepend('Latte\Runtime\Filters::safeUrl(');
						$inside = TRUE;
					} else {
						$res->prepend('$template->' . $tokens->currentValue() . '(');
						$inside = TRUE;
					}
				} else {
					throw new CompileException("Modifier name must be alphanumeric string, '{$tokens->currentValue()}' given.");
				}
			}
		}
		if ($inside) {
			$res->append(')');
		}
		return $res;
	}
	
	public function escapeFilter(MacroTokens $tokens)
	{
		$tokens = clone $tokens;
		switch ($this->compiler->getContentType()) {
			case Compiler::CONTENT_XHTML:
			case Compiler::CONTENT_HTML:
				$context = $this->compiler->getContext();
				switch ($context[0]) {
					case Compiler::CONTEXT_SINGLE_QUOTED_ATTR:
					case Compiler::CONTEXT_DOUBLE_QUOTED_ATTR:
					case Compiler::CONTEXT_UNQUOTED_ATTR:
						if ($context[1] === Compiler::CONTENT_JS) {
							$tokens->prepend('Latte\Runtime\Filters::escapeJs(')->append(')');
						} elseif ($context[1] === Compiler::CONTENT_CSS) {
							$tokens->prepend('Latte\Runtime\Filters::escapeCss(')->append(')');
						}
						$tokens->prepend('htmlSpecialChars(')->append($context[0] === Compiler::CONTEXT_SINGLE_QUOTED_ATTR ? ', ENT_QUOTES)' : ')');
						if ($context[0] === Compiler::CONTEXT_UNQUOTED_ATTR) {
							$tokens->prepend("'\"' . ")->append(" . '\"'");
						}
						return $tokens;
					case Compiler::CONTEXT_COMMENT:
						return $tokens->prepend('Latte\Runtime\Filters::escapeHtmlComment(')->append(')');
					case Compiler::CONTENT_JS:
					case Compiler::CONTENT_CSS:
						return $tokens->prepend('Latte\Runtime\Filters::escape' . ucfirst($context[0]) . '(')->append(')');
					default:
						return $tokens->prepend('Latte\Runtime\Filters::escapeHtml(')->append(', ENT_NOQUOTES)');
				}
			case Compiler::CONTENT_XML:
				$context = $this->compiler->getContext();
				switch ($context[0]) {
					case Compiler::CONTEXT_COMMENT:
						return $tokens->prepend('Latte\Runtime\Filters::escapeHtmlComment(')->append(')');
					default:
						$tokens->prepend('Latte\Runtime\Filters::escapeXml(')->append(')');
						if ($context[0] === Compiler::CONTEXT_UNQUOTED_ATTR) {
							$tokens->prepend("'\"' . ")->append(" . '\"'");
						}
						return $tokens;
				}
			case Compiler::CONTENT_JS:
			case Compiler::CONTENT_CSS:
			case Compiler::CONTENT_ICAL:
				return $tokens->prepend('Latte\Runtime\Filters::escape' . ucfirst($this->compiler->getContentType()) . '(')->append(')');
			case Compiler::CONTENT_TEXT:
				return $tokens;
			default:
				return $tokens->prepend('$template->escape(')->append(')');
		}
	}
}
}
namespace Latte{
class RegexpException extends \Exception
{
	static public $messages = array(
		PREG_INTERNAL_ERROR => 'Internal error',
		PREG_BACKTRACK_LIMIT_ERROR => 'Backtrack limit was exhausted',
		PREG_RECURSION_LIMIT_ERROR => 'Recursion limit was exhausted',
		PREG_BAD_UTF8_ERROR => 'Malformed UTF-8 data',
		5 => 'Offset didn\'t correspond to the begin of a valid UTF-8 code point', 	);
	public function __construct($message, $code = NULL)
	{
		parent::__construct($message ?: (isset(self::$messages[$code]) ? self::$messages[$code] : 'Unknown error'), $code);
	}
}
}
namespace Latte{
class RuntimeException extends \Exception {
    
}
}
namespace Latte{
class Template extends LatteObject
{
	
	private $engine;
	
	private $name;
	
	protected $params = array();
	
	protected $filters = array(
		NULL => array(), 	);
	public function __construct(array $params, array & $filters, Engine $engine, $name)
	{
		$params['template'] = $this;
		$this->setParameters($params);
		$this->filters = & $filters;
		$this->engine = $engine;
		$this->name = $name;
	}
	
	public function getEngine()
	{
		return $this->engine;
	}
	
	public function getName()
	{
		return $this->name;
	}
	
	public function initialize($templateId, $contentType)
	{
		Runtime\Filters::$xhtml = (bool) preg_match('#xml|xhtml#', $contentType);
				if (isset($this->params['_l'])) {
			$local = $this->params['_l'];
			unset($this->params['_l']);
		} else {
			$local = new \stdClass;
		}
		$local->templates[$templateId] = $this;
				if (!isset($this->params['_g'])) {
			$this->params['_g'] = new \stdClass;
		}
		return array($local, $this->params['_g']);
	}
	
	public function renderChildTemplate($name, array $params = array())
	{
		$name = $this->engine->getLoader()->getChildName($name, $this->name);
		$this->engine->render($name, $params);
	}
	
	public function __call($name, $args)
	{
		$lname = strtolower($name);
		if (!isset($this->filters[$lname])) {
			$args2 = $args;
			array_unshift($args2, $lname);
			foreach ($this->filters[NULL] as $filter) {
				$res = call_user_func_array(Helpers::checkCallback($filter), $args2);
				if ($res !== NULL) {
					return $res;
				} elseif (isset($this->filters[$lname])) {
					return call_user_func_array(Helpers::checkCallback($this->filters[$lname]), $args);
				}
			}
			return parent::__call($name, $args);
		}
		return call_user_func_array(Helpers::checkCallback($this->filters[$lname]), $args);
	}
	
	
	public function setParameters(array $params)
	{
		$this->params = $params;
		$this->params['template'] = $this;
		return $this;
	}
	
	public function getParameters()
	{
		return $this->params;
	}
	
	public function __set($name, $value)
	{
		$this->params[$name] = $value;
	}
	
	public function &__get($name)
	{
		if (!array_key_exists($name, $this->params)) {
			trigger_error("The variable '$name' does not exist in template.", E_USER_NOTICE);
		}
		return $this->params[$name];
	}
	
	public function __isset($name)
	{
		return isset($this->params[$name]);
	}
	
	public function __unset($name)
	{
		unset($this->params[$name]);
	}
}
}
namespace Latte{
class Token extends LatteObject
{
	const TEXT = 'text',
		MACRO_TAG = 'macroTag', 		HTML_TAG_BEGIN = 'htmlTagBegin', 		HTML_TAG_END = 'htmlTagEnd', 		HTML_ATTRIBUTE = 'htmlAttribute',
		COMMENT = 'comment'; 
	
	public $type;
	
	public $text;
	
	public $line;
	
	public $name;
	
	public $value;
	
	public $modifiers;
	
	public $closing;
	
	public $empty;
}
}
namespace Latte{
class Tokenizer extends LatteObject
{
	const VALUE = 0,
		OFFSET = 1,
		TYPE = 2;
	
	private $re;
	
	private $types;
	
	public function __construct(array $patterns, $flags = '')
	{
		$this->re = '~(' . implode(')|(', $patterns) . ')~A' . $flags;
		$this->types = array_keys($patterns);
	}
	
	public function tokenize($input)
	{
		preg_match_all($this->re, $input, $tokens, PREG_SET_ORDER);
		if (preg_last_error()) {
			throw new Latte\RegexpException(NULL, preg_last_error());
		}
		$len = 0;
		$count = count($this->types);
		foreach ($tokens as & $match) {
			$type = NULL;
			for ($i = 1; $i <= $count; $i++) {
				if (!isset($match[$i])) {
					break;
				} elseif ($match[$i] != NULL) {
					$type = $this->types[$i - 1]; break;
				}
			}
			$match = array(self::VALUE => $match[0], self::OFFSET => $len, self::TYPE => $type);
			$len += strlen($match[self::VALUE]);
		}
		if ($len !== strlen($input)) {
			list($line, $col) = $this->getCoordinates($input, $len);
			$token = str_replace("\n", '\n', substr($input, $len, 10));
			throw new CompileException("Unexpected '$token' on line $line, column $col.");
		}
		return $tokens;
	}
	
	public static function getCoordinates($text, $offset)
	{
		$text = substr($text, 0, $offset);
		return array(substr_count($text, "\n") + 1, $offset - strrpos("\n" . $text, "\n") + 1);
	}
}
}
namespace Latte\Loaders{
use Latte;
class FileLoader extends Latte\LatteObject implements Latte\ILoader
{
	
	public function getContent($file)
	{
		if (!is_file($file)) {
			throw new \RuntimeException("Missing template file '$file'.");
		} elseif ($this->isExpired($file, time())) {
			touch($file);
		}
		return file_get_contents($file);
	}
	
	public function isExpired($file, $time)
	{
		return @filemtime($file) > $time; 	}
	
	public function getChildName($file, $parent = NULL)
	{
		if ($parent && !preg_match('#/|[a-z]:#iA', $file)) {
			$file = dirname($parent) . '/' . $file;
		}
		return $file;
	}
}
}
namespace Latte\Loaders{
use Latte;
class StringLoader extends Latte\LatteObject implements Latte\ILoader
{
	
	public function getContent($content)
	{
		return $content;
	}
	
	public function isExpired($content, $time)
	{
		return FALSE;
	}
	
	public function getChildName($content, $parent = NULL)
	{
		return $content;
	}
}
}
namespace Latte\Macros{
use Latte,
	Latte\MacroNode,
	Latte\PhpWriter,
	Latte\CompileException,
	Latte\RuntimeException;
class BlockMacros extends MacroSet
{
	
	private $namedBlocks = array();
	
	private $extends;
	public static function install(Latte\Compiler $compiler)
	{
		$me = new static($compiler);
		$me->addMacro('include', array($me, 'macroInclude'));
		$me->addMacro('includeblock', array($me, 'macroIncludeBlock'));
		$me->addMacro('extends', array($me, 'macroExtends'));
		$me->addMacro('layout', array($me, 'macroExtends'));
		$me->addMacro('block', array($me, 'macroBlock'), array($me, 'macroBlockEnd'));
		$me->addMacro('define', array($me, 'macroBlock'), array($me, 'macroBlockEnd'));
		$me->addMacro('snippet', array($me, 'macroBlock'), array($me, 'macroBlockEnd'));
		$me->addMacro('snippetArea', array($me, 'macroBlock'), array($me, 'macroBlockEnd'));
		$me->addMacro('ifset', array($me, 'macroIfset'), '}');
	}
	
	public function initialize()
	{
		$this->namedBlocks = array();
		$this->extends = NULL;
	}
	
	public function finalize()
	{
				$last = $this->getCompiler()->getMacroNode();
		if ($last && $last->name === 'block') {
			$this->getCompiler()->closeMacro($last->name);
		}
		$epilog = $prolog = array();
		if ($this->namedBlocks) {
			foreach ($this->namedBlocks as $name => $code) {
				$func = '_lb' . substr(md5($this->getCompiler()->getTemplateId() . $name), 0, 10) . '_' . preg_replace('#[^a-z0-9_]#i', '_', $name);
				$snippet = $name[0] === '_';
				$prolog[] = "//\n// block $name\n//\n"
					. "if (!function_exists(\$_l->blocks[" . var_export($name, TRUE) . "][] = '$func')) { "
					. "function $func(\$_l, \$_args) { foreach (\$_args as \$__k => \$__v) \$\$__k = \$__v"
					. ($snippet ? '; $_control->redrawControl(' . var_export(substr($name, 1), TRUE) . ', FALSE)' : '')
					. "\n?>$code<?php\n}}";
			}
			$prolog[] = "//\n// end of blocks\n//";
		}
		if ($this->namedBlocks || $this->extends) {
			$prolog[] = '// template extending';
			$prolog[] = '$_l->extends = '
				. ($this->extends ? $this->extends : 'empty($template->_extended) && isset($_control) && $_control instanceof Nette\Application\UI\Presenter ? $_control->findLayoutTemplateFile() : NULL')
				. '; $template->_extended = $_extended = TRUE;';
			$prolog[] = 'if ($_l->extends) { ' . ($this->namedBlocks ? 'ob_start();' : 'return $template->renderChildTemplate($_l->extends, get_defined_vars());') . '}';
		}
		return array(implode("\n\n", $prolog), implode("\n", $epilog));
	}
	
	
	public function macroInclude(MacroNode $node, PhpWriter $writer)
	{
		$destination = $node->tokenizer->fetchWord(); 		if (!preg_match('~#|[\w-]+\z~A', $destination)) {
			return FALSE;
		}
		$destination = ltrim($destination, '#');
		$parent = $destination === 'parent';
		if ($destination === 'parent' || $destination === 'this') {
			for ($item = $node->parentNode; $item && $item->name !== 'block' && !isset($item->data->name); $item = $item->parentNode);
			if (!$item) {
				throw new CompileException("Cannot include $destination block outside of any block.");
			}
			$destination = $item->data->name;
		}
		$name = strpos($destination, '$') === FALSE ? var_export($destination, TRUE) : $destination;
		if (isset($this->namedBlocks[$destination]) && !$parent) {
			$cmd = "call_user_func(reset(\$_l->blocks[$name]), \$_l, %node.array? + get_defined_vars())";
		} else {
			$cmd = 'Latte\Macros\BlockMacros::callBlock' . ($parent ? 'Parent' : '') . "(\$_l, $name, %node.array? + " . ($parent ? 'get_defined_vars' : '$template->getParameters') . '())';
		}
		if ($node->modifiers) {
			return $writer->write("ob_start(); $cmd; echo %modify(ob_get_clean())");
		} else {
			return $writer->write($cmd);
		}
	}
	
	public function macroIncludeBlock(MacroNode $node, PhpWriter $writer)
	{
		return $writer->write('$_l->templates[%var]->renderChildTemplate(%node.word, %node.array? + get_defined_vars())',
			$this->getCompiler()->getTemplateId());
	}
	
	public function macroExtends(MacroNode $node, PhpWriter $writer)
	{
		if (!$node->args) {
			throw new CompileException("Missing destination in {{$node->name}}");
		}
		if (!empty($node->parentNode)) {
			throw new CompileException("{{$node->name}} must be placed outside any macro.");
		}
		if ($this->extends !== NULL) {
			throw new CompileException("Multiple {{$node->name}} declarations are not allowed.");
		}
		if ($node->args === 'none') {
			$this->extends = 'FALSE';
		} elseif ($node->args === 'auto') {
			$this->extends = '$_presenter->findLayoutTemplateFile()';
		} else {
			$this->extends = $writer->write('%node.word%node.args');
		}
		return;
	}
	
	public function macroBlock(MacroNode $node, PhpWriter $writer)
	{
		$name = $node->tokenizer->fetchWord();
		if ($node->name === '#') {
			trigger_error('Shortcut {#block} is deprecated.', E_USER_DEPRECATED);
		} elseif ($node->name === 'block' && $name === FALSE) { 			return $node->modifiers === '' ? '' : 'ob_start()';
		}
		$node->data->name = $name = ltrim($name, '#');
		if ($name == NULL) {
			if ($node->name === 'define') {
				throw new CompileException('Missing block name.');
			}
		} elseif (strpos($name, '$') !== FALSE) { 			if ($node->name === 'snippet') {
				for ($parent = $node->parentNode; $parent && !($parent->name === 'snippet' || $parent->name === 'snippetArea'); $parent = $parent->parentNode);
				if (!$parent) {
					throw new CompileException('Dynamic snippets are allowed only inside static snippet/snippetArea.');
				}
				$parent->data->dynamic = TRUE;
				$node->data->leave = TRUE;
				$node->closingCode = "<?php \$_dynSnippets[\$_dynSnippetId] = ob_get_flush() ?>";
				if ($node->prefix) {
					$node->attrCode = $writer->write("<?php echo ' id=\"' . (\$_dynSnippetId = \$_control->getSnippetId({$writer->formatWord($name)})) . '\"' ?>");
					return $writer->write('ob_start()');
				}
				$tag = trim($node->tokenizer->fetchWord(), '<>');
				$tag = $tag ? $tag : 'div';
				$node->closingCode .= "\n</$tag>";
				return $writer->write("?>\n<$tag id=\"<?php echo \$_dynSnippetId = \$_control->getSnippetId({$writer->formatWord($name)}) ?>\"><?php ob_start()");
			} else {
				$node->data->leave = TRUE;
				$fname = $writer->formatWord($name);
				$node->closingCode = "<?php }} " . ($node->name === 'define' ? '' : "call_user_func(reset(\$_l->blocks[$fname]), \$_l, get_defined_vars())") . " ?>";
				$func = '_lb' . substr(md5($this->getCompiler()->getTemplateId() . $name), 0, 10) . '_' . preg_replace('#[^a-z0-9_]#i', '_', $name);
				return "\n\n//\n// block $name\n//\n"
					. "if (!function_exists(\$_l->blocks[$fname]['{$this->getCompiler()->getTemplateId()}'] = '$func')) { "
					. "function $func(\$_l, \$_args) { foreach (\$_args as \$__k => \$__v) \$\$__k = \$__v";
			}
		}
				if ($node->name === 'snippet' || $node->name === 'snippetArea') {
			if ($node->prefix && isset($node->htmlNode->attrs['id'])) {
				throw new CompileException('Cannot combine HTML attribute id with n:snippet.');
			}
			$node->data->name = $name = '_' . $name;
		}
		if (isset($this->namedBlocks[$name])) {
			throw new CompileException("Cannot redeclare static {$node->name} '$name'");
		}
		$prolog = $this->namedBlocks ? '' : "if (\$_l->extends) { ob_end_clean(); return \$template->renderChildTemplate(\$_l->extends, get_defined_vars()); }\n";
		$this->namedBlocks[$name] = TRUE;
		$include = 'call_user_func(reset($_l->blocks[%var]), $_l, ' . (($node->name === 'snippet' || $node->name === 'snippetArea') ? '$template->getParameters()' : 'get_defined_vars()') . ')';
		if ($node->modifiers) {
			$include = "ob_start(); $include; echo %modify(ob_get_clean())";
		}
		if ($node->name === 'snippet') {
			if ($node->prefix) {
				$node->attrCode = $writer->write('<?php echo \' id="\' . $_control->getSnippetId(%var) . \'"\' ?>', (string) substr($name, 1));
				return $writer->write($prolog . $include, $name);
			}
			$tag = trim($node->tokenizer->fetchWord(), '<>');
			$tag = $tag ? $tag : 'div';
			return $writer->write("$prolog ?>\n<$tag id=\"<?php echo \$_control->getSnippetId(%var) ?>\"><?php $include ?>\n</$tag><?php ",
				(string) substr($name, 1), $name
			);
		} elseif ($node->name === 'define') {
			return $prolog;
		} else { 			return $writer->write($prolog . $include, $name);
		}
	}
	
	public function macroBlockEnd(MacroNode $node, PhpWriter $writer)
	{
		if (isset($node->data->name)) { 			if ($node->name === 'snippet' && $node->prefix === MacroNode::PREFIX_NONE 				&& preg_match('#^.*? n:\w+>\n?#s', $node->content, $m1) && preg_match('#[ \t]*<[^<]+\z#s', $node->content, $m2)
			) {
				$node->openingCode = $m1[0] . $node->openingCode;
				$node->content = substr($node->content, strlen($m1[0]), -strlen($m2[0]));
				$node->closingCode .= $m2[0];
			}
			if (empty($node->data->leave)) {
				if ($node->name === 'snippetArea') {
					$node->content = "<?php \$_control->snippetMode = isset(\$_snippetMode) && \$_snippetMode; ?>{$node->content}<?php \$_control->snippetMode = FALSE; ?>";
				}
				if (!empty($node->data->dynamic)) {
					$node->content .= '<?php if (isset($_dynSnippets)) return $_dynSnippets; ?>';
				}
				if ($node->name === 'snippetArea') {
					$node->content .= '<?php return FALSE; ?>';
				}
				$this->namedBlocks[$node->data->name] = $tmp = rtrim(ltrim($node->content, "\n"), " \t");
				$node->content = substr_replace($node->content, $node->openingCode . "\n", strspn($node->content, "\n"), strlen($tmp));
				$node->openingCode = '<?php ?>';
			}
		} elseif ($node->modifiers) { 			return $writer->write('echo %modify(ob_get_clean())');
		}
	}
	
	public function macroIfset(MacroNode $node, PhpWriter $writer)
	{
		if (strpos($node->args, '#') === FALSE) {
			return FALSE;
		}
		$list = array();
		while (($name = $node->tokenizer->fetchWord()) !== FALSE) {
			$list[] = $name[0] === '#' ? '$_l->blocks["' . substr($name, 1) . '"]' : $name;
		}
		return 'if (isset(' . implode(', ', $list) . ')) {';
	}
	
	
	public static function callBlock(\stdClass $context, $name, array $params)
	{
		if (empty($context->blocks[$name])) {
			throw new RuntimeException("Cannot include undefined block '$name'.");
		}
		$block = reset($context->blocks[$name]);
		$block($context, $params);
	}
	
	public static function callBlockParent(\stdClass $context, $name, array $params)
	{
		if (empty($context->blocks[$name]) || ($block = next($context->blocks[$name])) === FALSE) {
			throw new RuntimeException("Cannot include undefined parent block '$name'.");
		}
		$block($context, $params);
		prev($context->blocks[$name]);
	}
}
}
namespace Latte\Macros{
use Latte,
	Latte\CompileException,
	Latte\MacroNode,
	Latte\PhpWriter;
class CoreMacros extends MacroSet
{
	public static function install(Latte\Compiler $compiler)
	{
		$me = new static($compiler);
		$me->addMacro('if', array($me, 'macroIf'), array($me, 'macroEndIf'));
		$me->addMacro('elseif', '} elseif (%node.args) {');
		$me->addMacro('else', array($me, 'macroElse'));
		$me->addMacro('ifset', 'if (isset(%node.args)) {', '}');
		$me->addMacro('elseifset', '} elseif (isset(%node.args)) {');
		$me->addMacro('ifcontent', array($me, 'macroIfContent'), array($me, 'macroEndIfContent'));
		$me->addMacro('switch', '$_l->switch[] = (%node.args); if (FALSE) {', '} array_pop($_l->switch)');
		$me->addMacro('case', '} elseif (end($_l->switch) === (%node.args)) {');
		$me->addMacro('foreach', '', array($me, 'macroEndForeach'));
		$me->addMacro('for', 'for (%node.args) {', '}');
		$me->addMacro('while', 'while (%node.args) {', '}');
		$me->addMacro('continueIf', array($me, 'macroBreakContinueIf'));
		$me->addMacro('breakIf', array($me, 'macroBreakContinueIf'));
		$me->addMacro('first', 'if ($iterator->isFirst(%node.args)) {', '}');
		$me->addMacro('last', 'if ($iterator->isLast(%node.args)) {', '}');
		$me->addMacro('sep', 'if (!$iterator->isLast(%node.args)) {', '}');
		$me->addMacro('var', array($me, 'macroVar'));
		$me->addMacro('default', array($me, 'macroVar'));
		$me->addMacro('dump', array($me, 'macroDump'));
		$me->addMacro('debugbreak', array($me, 'macroDebugbreak'));
		$me->addMacro('l', '?>{<?php');
		$me->addMacro('r', '?>}<?php');
		$me->addMacro('_', array($me, 'macroTranslate'), array($me, 'macroTranslate'));
		$me->addMacro('=', array($me, 'macroExpr'));
		$me->addMacro('?', array($me, 'macroExpr'));
		$me->addMacro('capture', array($me, 'macroCapture'), array($me, 'macroCaptureEnd'));
		$me->addMacro('include', array($me, 'macroInclude'));
		$me->addMacro('use', array($me, 'macroUse'));
		$me->addMacro('contentType', array($me, 'macroContentType'));
		$me->addMacro('status', array($me, 'macroStatus'));
		$me->addMacro('class', NULL, NULL, array($me, 'macroClass'));
		$me->addMacro('attr', NULL, NULL, array($me, 'macroAttr'));
	}
	
	public function finalize()
	{
		return array('list($_l, $_g) = $template->initialize('
			. var_export($this->getCompiler()->getTemplateId(), TRUE) . ', '
			. var_export($this->getCompiler()->getContentType(), TRUE)
		. ')');
	}
	
	
	public function macroIf(MacroNode $node, PhpWriter $writer)
	{
		if ($node->data->capture = ($node->args === '')) {
			return 'ob_start()';
		}
		if ($node->prefix === $node::PREFIX_TAG) {
			return $writer->write($node->htmlNode->closing ? 'if (array_pop($_l->ifs)) {' : 'if ($_l->ifs[] = (%node.args)) {');
		}
		return $writer->write('if (%node.args) {');
	}
	
	public function macroEndIf(MacroNode $node, PhpWriter $writer)
	{
		if ($node->data->capture) {
			if ($node->args === '') {
				throw new CompileException('Missing condition in {if} macro.');
			}
			return $writer->write('if (%node.args) '
				. (isset($node->data->else) ? '{ ob_end_clean(); ob_end_flush(); }' : 'ob_end_flush();')
				. ' else '
				. (isset($node->data->else) ? '{ $_else = ob_get_contents(); ob_end_clean(); ob_end_clean(); echo $_else; }' : 'ob_end_clean();')
			);
		}
		return '}';
	}
	
	public function macroElse(MacroNode $node, PhpWriter $writer)
	{
		$ifNode = $node->parentNode;
		if ($ifNode && $ifNode->name === 'if' && $ifNode->data->capture) {
			if (isset($ifNode->data->else)) {
				throw new CompileException('Macro {if} supports only one {else}.');
			}
			$ifNode->data->else = TRUE;
			return 'ob_start()';
		}
		return '} else {';
	}
	
	public function macroIfContent(MacroNode $node, PhpWriter $writer)
	{
		if (!$node->htmlNode) {
			throw new CompileException("Unknown macro {{$node->name}}, use n:{$node->name} attribute.");
		} elseif ($node->prefix !== MacroNode::PREFIX_NONE) {
			throw new CompileException("Unknown attribute n:{$node->prefix}-{$node->name}, use n:{$node->name} attribute.");
		}
		return $writer->write('ob_start()');
	}
	
	public function macroEndIfContent(MacroNode $node, PhpWriter $writer)
	{
		preg_match('#(^.*?>)(.*)(<.*\z)#s', $node->content, $parts);
		$node->content = $parts[1]
			. '<?php ob_start() ?>'
			. $parts[2]
			. '<?php $_ifcontent = ob_get_contents(); ob_end_flush() ?>'
			. $parts[3];
		return 'rtrim($_ifcontent) === "" ? ob_end_clean() : ob_end_flush()';
	}
	
	public function macroTranslate(MacroNode $node, PhpWriter $writer)
	{
		if ($node->closing) {
			return $writer->write('echo %modify($template->translate(ob_get_clean()))');
		} elseif ($node->isEmpty = ($node->args !== '')) {
			return $writer->write('echo %modify($template->translate(%node.args))');
		} else {
			return 'ob_start()';
		}
	}
	
	public function macroInclude(MacroNode $node, PhpWriter $writer)
	{
		$code = $writer->write('$_l->templates[%var]->renderChildTemplate(%node.word, %node.array? + $template->getParameters())',
			$this->getCompiler()->getTemplateId());
		if ($node->modifiers) {
			return $writer->write('ob_start(); %raw; echo %modify(ob_get_clean())', $code);
		} else {
			return $code;
		}
	}
	
	public function macroUse(MacroNode $node, PhpWriter $writer)
	{
		call_user_func(Latte\Helpers::checkCallback(array($node->tokenizer->fetchWord(), 'install')), $this->getCompiler())
			->initialize();
	}
	
	public function macroCapture(MacroNode $node, PhpWriter $writer)
	{
		$variable = $node->tokenizer->fetchWord();
		if (substr($variable, 0, 1) !== '$') {
			throw new CompileException("Invalid capture block variable '$variable'");
		}
		$node->data->variable = $variable;
		return 'ob_start()';
	}
	
	public function macroCaptureEnd(MacroNode $node, PhpWriter $writer)
	{
		return $node->data->variable . $writer->write(' = %modify(ob_get_clean())');
	}
	
	public function macroEndForeach(MacroNode $node, PhpWriter $writer)
	{
		if ($node->modifiers !== '|noiterator' && preg_match('#\W(\$iterator|include|require|get_defined_vars)\W#', $this->getCompiler()->expandTokens($node->content))) {
			$node->openingCode = '<?php $iterations = 0; foreach ($iterator = $_l->its[] = new Latte\Runtime\CachingIterator('
			. preg_replace('#(.*)\s+as\s+#i', '$1) as ', $writer->formatArgs(), 1) . ') { ?>';
			$node->closingCode = '<?php $iterations++; } array_pop($_l->its); $iterator = end($_l->its) ?>';
		} else {
			$node->openingCode = '<?php $iterations = 0; foreach (' . $writer->formatArgs() . ') { ?>';
			$node->closingCode = '<?php $iterations++; } ?>';
		}
	}
	
	public function macroBreakContinueIf(MacroNode $node, PhpWriter $writer)
	{
		$cmd = str_replace('If', '', $node->name);
		if ($node->parentNode && $node->parentNode->prefix === $node::PREFIX_NONE) {
			return $writer->write("if (%node.args) { echo \"</{$node->parentNode->htmlNode->name}>\\n\"; $cmd; }");
		}
		return $writer->write("if (%node.args) $cmd");
	}
	
	public function macroClass(MacroNode $node, PhpWriter $writer)
	{
		return $writer->write('if ($_l->tmp = array_filter(%node.array)) echo \' class="\' . %escape(implode(" ", array_unique($_l->tmp))) . \'"\'');
	}
	
	public function macroAttr(MacroNode $node, PhpWriter $writer)
	{
		return $writer->write('echo Latte\Runtime\Filters::htmlAttributes(%node.array)');
	}
	
	public function macroDump(MacroNode $node, PhpWriter $writer)
	{
		$args = $writer->formatArgs();
		return 'Tracy\Debugger::barDump(' . ($node->args ? $writer->write("array(%var => $args)", $args) : 'get_defined_vars()')
			. ', "Template " . str_replace(dirname(dirname($template->getName())), "\xE2\x80\xA6", $template->getName()))';
	}
	
	public function macroDebugbreak(MacroNode $node, PhpWriter $writer)
	{
		return $writer->write(($node->args == NULL ? '' : 'if (!(%node.args)); else')
			. 'if (function_exists("debugbreak")) debugbreak(); elseif (function_exists("xdebug_break")) xdebug_break()');
	}
	
	public function macroVar(MacroNode $node, PhpWriter $writer)
	{
		if ($node->args === '' && $node->parentNode && $node->parentNode->name === 'switch') {
			return '} else {';
		}
		$var = TRUE;
		$tokens = $writer->preprocess();
		$res = new Latte\MacroTokens;
		while ($tokens->nextToken()) {
			if ($var && $tokens->isCurrent(Latte\MacroTokens::T_SYMBOL, Latte\MacroTokens::T_VARIABLE)) {
				if ($node->name === 'default') {
					$res->append("'" . ltrim($tokens->currentValue(), '$') . "'");
				} else {
					$res->append('$' . ltrim($tokens->currentValue(), '$'));
				}
				$var = NULL;
			} elseif ($tokens->isCurrent('=', '=>') && $tokens->depth === 0) {
				$res->append($node->name === 'default' ? '=>' : '=');
				$var = FALSE;
			} elseif ($tokens->isCurrent(',') && $tokens->depth === 0) {
				$res->append($node->name === 'default' ? ',' : ';');
				$var = TRUE;
			} elseif ($var === NULL && $node->name === 'default' && !$tokens->isCurrent(Latte\MacroTokens::T_WHITESPACE)) {
				throw new CompileException("Unexpected '{$tokens->currentValue()}' in {default $node->args}");
			} else {
				$res->append($tokens->currentToken());
			}
		}
		$out = $writer->quoteFilter($res)->joinAll();
		return $node->name === 'default' ? "extract(array($out), EXTR_SKIP)" : $out;
	}
	
	public function macroExpr(MacroNode $node, PhpWriter $writer)
	{
		return $writer->write(($node->name === '?' ? '' : 'echo ') . '%modify(%node.args)');
	}
	
	public function macroContentType(MacroNode $node, PhpWriter $writer)
	{
		if (strpos($node->args, 'xhtml') !== FALSE) {
			$this->getCompiler()->setContentType(Latte\Compiler::CONTENT_XHTML);
		} elseif (strpos($node->args, 'html') !== FALSE) {
			$this->getCompiler()->setContentType(Latte\Compiler::CONTENT_HTML);
		} elseif (strpos($node->args, 'xml') !== FALSE) {
			$this->getCompiler()->setContentType(Latte\Compiler::CONTENT_XML);
		} elseif (strpos($node->args, 'javascript') !== FALSE) {
			$this->getCompiler()->setContentType(Latte\Compiler::CONTENT_JS);
		} elseif (strpos($node->args, 'css') !== FALSE) {
			$this->getCompiler()->setContentType(Latte\Compiler::CONTENT_CSS);
		} elseif (strpos($node->args, 'calendar') !== FALSE) {
			$this->getCompiler()->setContentType(Latte\Compiler::CONTENT_ICAL);
		} else {
			$this->getCompiler()->setContentType(Latte\Compiler::CONTENT_TEXT);
		}
				if (strpos($node->args, '/')) {
			return $writer->write('header(%var)', "Content-Type: $node->args");
		}
	}
	
	public function macroStatus(MacroNode $node, PhpWriter $writer)
	{
		return $writer->write((substr($node->args, -1) === '?' ? 'if (!headers_sent()) ' : '') .
			'header((isset($_SERVER["SERVER_PROTOCOL"]) ? $_SERVER["SERVER_PROTOCOL"] : "HTTP/1.1") . " " . %0.var, TRUE, %0.var)', (int) $node->args
		);
	}
}
}
namespace Latte\Runtime{
use Latte;
class CachingIterator extends \CachingIterator implements \Countable
{
	
	private $counter = 0;
	public function __construct($iterator)
	{
		if (is_array($iterator) || $iterator instanceof \stdClass) {
			$iterator = new \ArrayIterator($iterator);
		} elseif ($iterator instanceof \Traversable) {
			if ($iterator instanceof \IteratorAggregate) {
				$iterator = $iterator->getIterator();
			} elseif (!$iterator instanceof \Iterator) {
				$iterator = new \IteratorIterator($iterator);
			}
		} else {
			throw new \InvalidArgumentException(sprintf('Invalid argument passed to foreach; array or Traversable expected, %s given.', is_LatteObject($iterator) ? get_class($iterator) : gettype($iterator)));
		}
		parent::__construct($iterator, 0);
	}
	
	public function isFirst($width = NULL)
	{
		return $this->counter === 1 || ($width && $this->counter !== 0 && (($this->counter - 1) % $width) === 0);
	}
	
	public function isLast($width = NULL)
	{
		return !$this->hasNext() || ($width && ($this->counter % $width) === 0);
	}
	
	public function isEmpty()
	{
		return $this->counter === 0;
	}
	
	public function isOdd()
	{
		return $this->counter % 2 === 1;
	}
	
	public function isEven()
	{
		return $this->counter % 2 === 0;
	}
	
	public function getCounter()
	{
		return $this->counter;
	}
	
	public function count()
	{
		$inner = $this->getInnerIterator();
		if ($inner instanceof \Countable) {
			return $inner->count();
		} else {
			throw new \LogicException('Iterator is not countable.');
		}
	}
	
	public function next()
	{
		parent::next();
		if (parent::valid()) {
			$this->counter++;
		}
	}
	
	public function rewind()
	{
		parent::rewind();
		$this->counter = parent::valid() ? 1 : 0;
	}
	
	public function getNextKey()
	{
		return $this->getInnerIterator()->key();
	}
	
	public function getNextValue()
	{
		return $this->getInnerIterator()->current();
	}
	
	
	public function __call($name, $args)
	{
		throw new \LogicException(sprintf('Call to undefined method %s::%s().', get_class($this), $name));
	}
	
	public function &__get($name)
	{
		if (method_exists($this, $m = 'get' . $name) || method_exists($this, $m = 'is' . $name)) {
			$ret = $this->$m();
			return $ret;
		}
		throw new \LogicException(sprintf('Cannot read an undeclared property %s::$%s.', get_class($this), $name));
	}
	
	public function __set($name, $value)
	{
		throw new \LogicException(sprintf('Cannot write to an undeclared property %s::$%s.', get_class($this), $name));
	}
	
	public function __isset($name)
	{
		return method_exists($this, 'get' . $name) || method_exists($this, 'is' . $name);
	}
	
	public function __unset($name)
	{
		throw new \LogicException(sprintf('Cannot unset the property %s::$%s.', get_class($this), $name));
	}
}
}
namespace Latte\Runtime{
use Latte;
class Filters
{
	
	public static $dateFormat = '%x';
	
	public static $xhtml = FALSE;
	
	public static function escapeHtml($s, $quotes = ENT_QUOTES)
	{
		if ($s instanceof IHtmlString || $s instanceof \Nette\Utils\IHtmlString) {
			return $s->__toString(TRUE);
		}
		return htmlSpecialChars($s, $quotes);
	}
	
	public static function escapeHtmlComment($s)
	{
		$s = (string) $s;
		if ($s && ($s[0] === '-' || $s[0] === '>' || $s[0] === '!')) {
			$s = ' ' . $s;
		}
		return str_replace('-', '- ', $s); 	}
	
	public static function escapeXML($s)
	{
								return htmlSpecialChars(preg_replace('#[\x00-\x08\x0B\x0C\x0E-\x1F]+#', '', $s), ENT_QUOTES);
	}
	
	public static function escapeCss($s)
	{
				return addcslashes($s, "\x00..\x1F!\"#$%&'()*+,./:;<=>?@[\\]^`{|}~");
	}
	
	public static function escapeJs($s)
	{
		if ($s instanceof IHtmlString || $s instanceof \Nette\Utils\IHtmlString) {
			$s = $s->__toString(TRUE);
		}
		$json = json_encode($s, PHP_VERSION_ID >= 50400 ? JSON_UNESCAPED_UNICODE : 0);
		if ($error = json_last_error()) {
			throw new \RuntimeException(PHP_VERSION_ID >= 50500 ? json_last_error_msg() : 'JSON encode error', $error);
		}
		return str_replace(array("\xe2\x80\xa8", "\xe2\x80\xa9", ']]>', '<!'), array('\u2028', '\u2029', ']]\x3E', '\x3C!'), $json);
	}
	
	public static function escapeICal($s)
	{
				return addcslashes(preg_replace('#[\x00-\x08\x0B\x0C-\x1F]+#', '', $s), "\";\\,:\n");
	}
	
	public static function safeUrl($s)
	{
		return preg_match('~^(?:(?:https?|ftp)://[^@]+(?:/.*)?|mailto:.+|[/?#].*|[^:]+)\z~i', $s) ? $s : '';
	}
	
	public static function strip($s)
	{
		return preg_replace_callback(
			'#(</textarea|</pre|</script|^).*?(?=<textarea|<pre|<script|\z)#si',
			function($m) {
				return trim(preg_replace('#[ \t\r\n]+#', ' ', $m[0]));
			},
			$s
		);
	}
	
	public static function indent($s, $level = 1, $chars = "\t")
	{
		if ($level >= 1) {
			$s = preg_replace_callback('#<(textarea|pre).*?</\\1#si', function($m) {
				return strtr($m[0], " \t\r\n", "\x1F\x1E\x1D\x1A");
			}, $s);
			if (preg_last_error()) {
				throw new Latte\RegexpException(NULL, preg_last_error());
			}
			$s = preg_replace('#(?:^|[\r\n]+)(?=[^\r\n])#', '$0' . str_repeat($chars, $level), $s);
			$s = strtr($s, "\x1F\x1E\x1D\x1A", " \t\r\n");
		}
		return $s;
	}
	
	public static function date($time, $format = NULL)
	{
		if ($time == NULL) { 			return NULL;
		}
		if (!isset($format)) {
			$format = self::$dateFormat;
		}
		if ($time instanceof \DateInterval) {
			return $time->format($format);
		} elseif (!$time instanceof \DateTime && !$time instanceof \DateTimeInterface) {
			$time = new \DateTime((is_numeric($time) ? '@' : '') . $time);
		}
		return strpos($format, '%') === FALSE
			? $time->format($format) 			: strftime($format, $time->format('U')); 	}
	
	public static function bytes($bytes, $precision = 2)
	{
		$bytes = round($bytes);
		$units = array('B', 'kB', 'MB', 'GB', 'TB', 'PB');
		foreach ($units as $unit) {
			if (abs($bytes) < 1024 || $unit === end($units)) {
				break;
			}
			$bytes = $bytes / 1024;
		}
		return round($bytes, $precision) . ' ' . $unit;
	}
	
	public static function replace($subject, $search, $replacement = '')
	{
		return str_replace($search, $replacement, $subject);
	}
	
	public static function replaceRe($subject, $pattern, $replacement = '')
	{
		$res = preg_replace($pattern, $replacement, $subject);
		if (preg_last_error()) {
			throw new Latte\RegexpException(NULL, preg_last_error());
		}
		return $res;
	}
	
	public static function dataStream($data, $type = NULL)
	{
		if ($type === NULL) {
			$type = finfo_buffer(finfo_open(FILEINFO_MIME_TYPE), $data);
		}
		return 'data:' . ($type ? "$type;" : '') . 'base64,' . base64_encode($data);
	}
	
	public static function nl2br($value)
	{
		return nl2br($value, self::$xhtml);
	}
	
	public static function substring($s, $start, $length = NULL)
	{
		if ($length === NULL) {
			$length = self::length($s);
		}
		if (function_exists('mb_substr')) {
			return mb_substr($s, $start, $length, 'UTF-8'); 		}
		return iconv_substr($s, $start, $length, 'UTF-8');
	}
	
	public static function truncate($s, $maxLen, $append = "\xE2\x80\xA6")
	{
		if (self::length($s) > $maxLen) {
			$maxLen = $maxLen - self::length($append);
			if ($maxLen < 1) {
				return $append;
			} elseif (preg_match('#^.{1,'.$maxLen.'}(?=[\s\x00-/:-@\[-`{-~])#us', $s, $matches)) {
				return $matches[0] . $append;
			} else {
				return self::substring($s, 0, $maxLen) . $append;
			}
		}
		return $s;
	}
	
	public static function lower($s)
	{
		return mb_strtolower($s, 'UTF-8');
	}
	
	public static function upper($s)
	{
		return mb_strtoupper($s, 'UTF-8');
	}
	
	public static function firstUpper($s)
	{
		return self::upper(self::substring($s, 0, 1)) . self::substring($s, 1);
	}
	
	public static function capitalize($s)
	{
		return mb_convert_case($s, MB_CASE_TITLE, 'UTF-8');
	}
	
	public static function length($s)
	{
		return strlen(utf8_decode($s)); 	}
	
	public static function trim($s, $charlist = " \t\n\r\0\x0B\xC2\xA0")
	{
		$charlist = preg_quote($charlist, '#');
		$s = preg_replace('#^['.$charlist.']+|['.$charlist.']+\z#u', '', $s);
		if (preg_last_error()) {
			throw new Latte\RegexpException(NULL, preg_last_error());
		}
		return $s;
	}
	
	public static function htmlAttributes($attrs)
	{
		if (!is_array($attrs)) {
			return '';
		}
		$s = '';
		foreach ($attrs as $key => $value) {
			if ($value === NULL || $value === FALSE) {
				continue;
			} elseif ($value === TRUE) {
				if (static::$xhtml) {
					$s .= ' ' . $key . '="' . $key . '"';
				} else {
					$s .= ' ' . $key;
				}
				continue;
			} elseif (is_array($value)) {
				$tmp = NULL;
				foreach ($value as $k => $v) {
					if ($v != NULL) { 												$tmp[] = $v === TRUE ? $k : (is_string($k) ? $k . ':' . $v : $v);
					}
				}
				if ($tmp === NULL) {
					continue;
				}
				$value = implode($key === 'style' || !strncmp($key, 'on', 2) ? ';' : ' ', $tmp);
			} else {
				$value = (string) $value;
			}
			$q = strpos($value, '"') === FALSE ? '"' : "'";
			$s .= ' ' . $key . '=' . $q . str_replace(array('&', $q), array('&amp;', $q === '"' ? '&quot;' : '&#39;'), $value) . $q;
		}
		return $s;
	}
}
}
namespace Latte\Runtime{
use Latte;
interface IHtmlString
{
	
	function __toString();
}
}
namespace Latte\Runtime{
use Latte;
class Html extends Latte\LatteObject implements IHtmlString
{
	
	private $value;
	public function __construct($value)
	{
		$this->value = (string) $value;
	}
	
	public function __toString()
	{
		return $this->value;
	}
}
}
namespace Psr\Log{
interface LoggerInterface
{
    
    public function emergency($message, array $context = array());
    
    public function alert($message, array $context = array());
    
    public function critical($message, array $context = array());
    
    public function error($message, array $context = array());
    
    public function warning($message, array $context = array());
    
    public function notice($message, array $context = array());
    
    public function info($message, array $context = array());
    
    public function debug($message, array $context = array());
    
    public function log($level, $message, array $context = array());
}
}
namespace Psr\Log{
abstract class AbstractLogger implements LoggerInterface
{
    
    public function emergency($message, array $context = array())
    {
        $this->log(LogLevel::EMERGENCY, $message, $context);
    }
    
    public function alert($message, array $context = array())
    {
        $this->log(LogLevel::ALERT, $message, $context);
    }
    
    public function critical($message, array $context = array())
    {
        $this->log(LogLevel::CRITICAL, $message, $context);
    }
    
    public function error($message, array $context = array())
    {
        $this->log(LogLevel::ERROR, $message, $context);
    }
    
    public function warning($message, array $context = array())
    {
        $this->log(LogLevel::WARNING, $message, $context);
    }
    
    public function notice($message, array $context = array())
    {
        $this->log(LogLevel::NOTICE, $message, $context);
    }
    
    public function info($message, array $context = array())
    {
        $this->log(LogLevel::INFO, $message, $context);
    }
    
    public function debug($message, array $context = array())
    {
        $this->log(LogLevel::DEBUG, $message, $context);
    }
}
}
namespace Psr\Log{
class InvalidArgumentException extends \InvalidArgumentException
{
}
}
namespace Psr\Log{
class LogLevel
{
    const EMERGENCY = 'emergency';
    const ALERT = 'alert';
    const CRITICAL = 'critical';
    const ERROR = 'error';
    const WARNING = 'warning';
    const NOTICE = 'notice';
    const INFO = 'info';
    const DEBUG = 'debug';
}
}
namespace Psr\Log{
interface LoggerAwareInterface
{
    
    public function setLogger(LoggerInterface $logger);
}
}
namespace Psr\Log{
class NullLogger extends AbstractLogger
{
    
    public function log($level, $message, array $context = array())
    {
            }
}
}
namespace Monolog{
use Psr\Log\LoggerInterface;
use Psr\Log\LogLevel;
class ErrorHandler
{
    private $logger;
    private $previousExceptionHandler;
    private $uncaughtExceptionLevel;
    private $previousErrorHandler;
    private $errorLevelMap;
    private $fatalLevel;
    private $reservedMemory;
    private static $fatalErrors = array(E_ERROR, E_PARSE, E_CORE_ERROR, E_COMPILE_ERROR, E_USER_ERROR);
    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
    }
    
    public static function register(LoggerInterface $logger, $errorLevelMap = array(), $exceptionLevel = null, $fatalLevel = null)
    {
        $handler = new static($logger);
        if ($errorLevelMap !== false) {
            $handler->registerErrorHandler($errorLevelMap);
        }
        if ($exceptionLevel !== false) {
            $handler->registerExceptionHandler($exceptionLevel);
        }
        if ($fatalLevel !== false) {
            $handler->registerFatalHandler($fatalLevel);
        }
        return $handler;
    }
    public function registerExceptionHandler($level = null, $callPrevious = true)
    {
        $prev = set_exception_handler(array($this, 'handleException'));
        $this->uncaughtExceptionLevel = $level;
        if ($callPrevious && $prev) {
            $this->previousExceptionHandler = $prev;
        }
    }
    public function registerErrorHandler(array $levelMap = array(), $callPrevious = true, $errorTypes = -1)
    {
        $prev = set_error_handler(array($this, 'handleError'), $errorTypes);
        $this->errorLevelMap = array_replace($this->defaultErrorLevelMap(), $levelMap);
        if ($callPrevious) {
            $this->previousErrorHandler = $prev ?: true;
        }
    }
    public function registerFatalHandler($level = null, $reservedMemorySize = 20)
    {
        register_shutdown_function(array($this, 'handleFatalError'));
        $this->reservedMemory = str_repeat(' ', 1024 * $reservedMemorySize);
        $this->fatalLevel = $level;
    }
    protected function defaultErrorLevelMap()
    {
        return array(
            E_ERROR             => LogLevel::CRITICAL,
            E_WARNING           => LogLevel::WARNING,
            E_PARSE             => LogLevel::ALERT,
            E_NOTICE            => LogLevel::NOTICE,
            E_CORE_ERROR        => LogLevel::CRITICAL,
            E_CORE_WARNING      => LogLevel::WARNING,
            E_COMPILE_ERROR     => LogLevel::ALERT,
            E_COMPILE_WARNING   => LogLevel::WARNING,
            E_USER_ERROR        => LogLevel::ERROR,
            E_USER_WARNING      => LogLevel::WARNING,
            E_USER_NOTICE       => LogLevel::NOTICE,
            E_STRICT            => LogLevel::NOTICE,
            E_RECOVERABLE_ERROR => LogLevel::ERROR,
            E_DEPRECATED        => LogLevel::NOTICE,
            E_USER_DEPRECATED   => LogLevel::NOTICE,
        );
    }
    
    public function handleException(\Exception $e)
    {
        $this->logger->log(
            $this->uncaughtExceptionLevel === null ? LogLevel::ERROR : $this->uncaughtExceptionLevel,
            sprintf('Uncaught Exception %s: "%s" at %s line %s', get_class($e), $e->getMessage(), $e->getFile(), $e->getLine()),
            array('exception' => $e)
        );
        if ($this->previousExceptionHandler) {
            call_user_func($this->previousExceptionHandler, $e);
        }
    }
    
    public function handleError($code, $message, $file = '', $line = 0, $context = array())
    {
        if (!(error_reporting() & $code)) {
            return;
        }
        $level = isset($this->errorLevelMap[$code]) ? $this->errorLevelMap[$code] : LogLevel::CRITICAL;
        $this->logger->log($level, self::codeToString($code).': '.$message, array('file' => $file, 'line' => $line));
        if ($this->previousErrorHandler === true) {
            return false;
        } elseif ($this->previousErrorHandler) {
            return call_user_func($this->previousErrorHandler, $code, $message, $file, $line, $context);
        }
    }
    
    public function handleFatalError()
    {
        $this->reservedMemory = null;
        $lastError = error_get_last();
        if ($lastError && in_array($lastError['type'], self::$fatalErrors)) {
            $this->logger->log(
                $this->fatalLevel === null ? LogLevel::ALERT : $this->fatalLevel,
                'Fatal Error ('.self::codeToString($lastError['type']).'): '.$lastError['message'],
                array('file' => $lastError['file'], 'line' => $lastError['line'])
            );
        }
    }
    private static function codeToString($code)
    {
        switch ($code) {
            case E_ERROR:
                return 'E_ERROR';
            case E_WARNING:
                return 'E_WARNING';
            case E_PARSE:
                return 'E_PARSE';
            case E_NOTICE:
                return 'E_NOTICE';
            case E_CORE_ERROR:
                return 'E_CORE_ERROR';
            case E_CORE_WARNING:
                return 'E_CORE_WARNING';
            case E_COMPILE_ERROR:
                return 'E_COMPILE_ERROR';
            case E_COMPILE_WARNING:
                return 'E_COMPILE_WARNING';
            case E_USER_ERROR:
                return 'E_USER_ERROR';
            case E_USER_WARNING:
                return 'E_USER_WARNING';
            case E_USER_NOTICE:
                return 'E_USER_NOTICE';
            case E_STRICT:
                return 'E_STRICT';
            case E_RECOVERABLE_ERROR:
                return 'E_RECOVERABLE_ERROR';
            case E_DEPRECATED:
                return 'E_DEPRECATED';
            case E_USER_DEPRECATED:
                return 'E_USER_DEPRECATED';
        }
        return 'Unknown PHP error';
    }
}
}
namespace Monolog{
use Monolog\Handler\HandlerInterface;
use Monolog\Handler\StreamHandler;
use Psr\Log\LoggerInterface;
use Psr\Log\InvalidArgumentException;
class Logger implements LoggerInterface
{
    
    const DEBUG = 100;
    
    const INFO = 200;
    
    const NOTICE = 250;
    
    const WARNING = 300;
    
    const ERROR = 400;
    
    const CRITICAL = 500;
    
    const ALERT = 550;
    
    const EMERGENCY = 600;
    
    const API = 1;
    
    protected static $levels = array(
        100 => 'DEBUG',
        200 => 'INFO',
        250 => 'NOTICE',
        300 => 'WARNING',
        400 => 'ERROR',
        500 => 'CRITICAL',
        550 => 'ALERT',
        600 => 'EMERGENCY',
    );
    
    protected static $timezone;
    
    protected $name;
    
    protected $handlers;
    
    protected $processors;
    
    public function __construct($name, array $handlers = array(), array $processors = array())
    {
        $this->name = $name;
        $this->handlers = $handlers;
        $this->processors = $processors;
    }
    
    public function getName()
    {
        return $this->name;
    }
    
    public function pushHandler(HandlerInterface $handler)
    {
        array_unshift($this->handlers, $handler);
    }
    
    public function popHandler()
    {
        if (!$this->handlers) {
            throw new \LogicException('You tried to pop from an empty handler stack.');
        }
        return array_shift($this->handlers);
    }
    
    public function pushProcessor($callback)
    {
        if (!is_callable($callback)) {
            throw new \InvalidArgumentException('Processors must be valid callables (callback or object with an __invoke method), '.var_export($callback, true).' given');
        }
        array_unshift($this->processors, $callback);
    }
    
    public function popProcessor()
    {
        if (!$this->processors) {
            throw new \LogicException('You tried to pop from an empty processor stack.');
        }
        return array_shift($this->processors);
    }
    
    public function addRecord($level, $message, array $context = array())
    {
        if (!$this->handlers) {
            $this->pushHandler(new StreamHandler('php://stderr', static::DEBUG));
        }
        if (!static::$timezone) {
            static::$timezone = new \DateTimeZone(date_default_timezone_get() ?: 'UTC');
        }
        $record = array(
            'message' => (string) $message,
            'context' => $context,
            'level' => $level,
            'level_name' => static::getLevelName($level),
            'channel' => $this->name,
            'datetime' => \DateTime::createFromFormat('U.u', sprintf('%.6F', microtime(true)), static::$timezone)->setTimezone(static::$timezone),
            'extra' => array(),
        );
                $handlerKey = null;
        foreach ($this->handlers as $key => $handler) {
            if ($handler->isHandling($record)) {
                $handlerKey = $key;
                break;
            }
        }
                if (null === $handlerKey) {
            return false;
        }
                foreach ($this->processors as $processor) {
            $record = call_user_func($processor, $record);
        }
        while (isset($this->handlers[$handlerKey]) &&
            false === $this->handlers[$handlerKey]->handle($record)) {
            $handlerKey++;
        }
        return true;
    }
    
    public function addDebug($message, array $context = array())
    {
        return $this->addRecord(static::DEBUG, $message, $context);
    }
    
    public function addInfo($message, array $context = array())
    {
        return $this->addRecord(static::INFO, $message, $context);
    }
    
    public function addNotice($message, array $context = array())
    {
        return $this->addRecord(static::NOTICE, $message, $context);
    }
    
    public function addWarning($message, array $context = array())
    {
        return $this->addRecord(static::WARNING, $message, $context);
    }
    
    public function addError($message, array $context = array())
    {
        return $this->addRecord(static::ERROR, $message, $context);
    }
    
    public function addCritical($message, array $context = array())
    {
        return $this->addRecord(static::CRITICAL, $message, $context);
    }
    
    public function addAlert($message, array $context = array())
    {
        return $this->addRecord(static::ALERT, $message, $context);
    }
    
    public function addEmergency($message, array $context = array())
    {
        return $this->addRecord(static::EMERGENCY, $message, $context);
    }
    
    public static function getLevels()
    {
        return array_flip(static::$levels);
    }
    
    public static function getLevelName($level)
    {
        if (!isset(static::$levels[$level])) {
            throw new InvalidArgumentException('Level "'.$level.'" is not defined, use one of: '.implode(', ', array_keys(static::$levels)));
        }
        return static::$levels[$level];
    }
    
    public function isHandling($level)
    {
        $record = array(
            'level' => $level,
        );
        foreach ($this->handlers as $handler) {
            if ($handler->isHandling($record)) {
                return true;
            }
        }
        return false;
    }
    
    public function log($level, $message, array $context = array())
    {
        if (is_string($level) && defined(__CLASS__.'::'.strtoupper($level))) {
            $level = constant(__CLASS__.'::'.strtoupper($level));
        }
        return $this->addRecord($level, $message, $context);
    }
    
    public function debug($message, array $context = array())
    {
        return $this->addRecord(static::DEBUG, $message, $context);
    }
    
    public function info($message, array $context = array())
    {
        return $this->addRecord(static::INFO, $message, $context);
    }
    
    public function notice($message, array $context = array())
    {
        return $this->addRecord(static::NOTICE, $message, $context);
    }
    
    public function warn($message, array $context = array())
    {
        return $this->addRecord(static::WARNING, $message, $context);
    }
    
    public function warning($message, array $context = array())
    {
        return $this->addRecord(static::WARNING, $message, $context);
    }
    
    public function err($message, array $context = array())
    {
        return $this->addRecord(static::ERROR, $message, $context);
    }
    
    public function error($message, array $context = array())
    {
        return $this->addRecord(static::ERROR, $message, $context);
    }
    
    public function crit($message, array $context = array())
    {
        return $this->addRecord(static::CRITICAL, $message, $context);
    }
    
    public function critical($message, array $context = array())
    {
        return $this->addRecord(static::CRITICAL, $message, $context);
    }
    
    public function alert($message, array $context = array())
    {
        return $this->addRecord(static::ALERT, $message, $context);
    }
    
    public function emerg($message, array $context = array())
    {
        return $this->addRecord(static::EMERGENCY, $message, $context);
    }
    
    public function emergency($message, array $context = array())
    {
        return $this->addRecord(static::EMERGENCY, $message, $context);
    }
}
}
namespace Monolog{
use InvalidArgumentException;
class Registry
{
    
    private static $loggers = array();
    
    public static function addLogger(Logger $logger, $name = null, $overwrite = false)
    {
        $name = $name ?: $logger->getName();
        if (isset(self::$loggers[$name]) && !$overwrite) {
            throw new InvalidArgumentException('Logger with the given name already exists');
        }
        self::$loggers[$name] = $logger;
    }
    
    public static function removeLogger($logger)
    {
        if ($logger instanceof Logger) {
            if (false !== ($idx = array_search($logger, self::$loggers, true))) {
                unset(self::$loggers[$idx]);
            }
        } else {
            unset(self::$loggers[$logger]);
        }
    }
    
    public static function clear()
    {
        self::$loggers = array();
    }
    
    public static function getInstance($name)
    {
        if (!isset(self::$loggers[$name])) {
            throw new InvalidArgumentException(sprintf('Requested "%s" logger instance is not in the registry', $name));
        }
        return self::$loggers[$name];
    }
    
    public static function __callStatic($name, $arguments)
    {
        return self::getInstance($name);
    }
}
}
namespace Monolog\Formatter{
interface FormatterInterface
{
    
    public function format(array $record);
    
    public function formatBatch(array $records);
}
}
namespace Monolog\Formatter{
use Exception;
class NormalizerFormatter implements FormatterInterface
{
    const SIMPLE_DATE = "Y-m-d H:i:s";
    protected $dateFormat;
    
    public function __construct($dateFormat = null)
    {
        $this->dateFormat = $dateFormat ?: static::SIMPLE_DATE;
    }
    
    public function format(array $record)
    {
        return $this->normalize($record);
    }
    
    public function formatBatch(array $records)
    {
        foreach ($records as $key => $record) {
            $records[$key] = $this->format($record);
        }
        return $records;
    }
    protected function normalize($data)
    {
        if (null === $data || is_scalar($data)) {
            return $data;
        }
        if (is_array($data) || $data instanceof \Traversable) {
            $normalized = array();
            $count = 1;
            foreach ($data as $key => $value) {
                if ($count++ >= 1000) {
                    $normalized['...'] = 'Over 1000 items, aborting normalization';
                    break;
                }
                $normalized[$key] = $this->normalize($value);
            }
            return $normalized;
        }
        if ($data instanceof \DateTime) {
            return $data->format($this->dateFormat);
        }
        if (is_object($data)) {
            if ($data instanceof Exception) {
                return $this->normalizeException($data);
            }
            return sprintf("[object] (%s: %s)", get_class($data), $this->toJson($data, true));
        }
        if (is_resource($data)) {
            return '[resource]';
        }
        return '[unknown('.gettype($data).')]';
    }
    protected function normalizeException(Exception $e)
    {
        $data = array(
            'class' => get_class($e),
            'message' => $e->getMessage(),
            'file' => $e->getFile().':'.$e->getLine(),
        );
        $trace = $e->getTrace();
        foreach ($trace as $frame) {
            if (isset($frame['file'])) {
                $data['trace'][] = $frame['file'].':'.$frame['line'];
            } else {
                $data['trace'][] = json_encode($frame);
            }
        }
        if ($previous = $e->getPrevious()) {
            $data['previous'] = $this->normalizeException($previous);
        }
        return $data;
    }
    protected function toJson($data, $ignoreErrors = false)
    {
                if ($ignoreErrors) {
            if (version_compare(PHP_VERSION, '5.4.0', '>=')) {
                return @json_encode($data, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE);
            }
            return @json_encode($data);
        }
        if (version_compare(PHP_VERSION, '5.4.0', '>=')) {
            return json_encode($data, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE);
        }
        return json_encode($data);
    }
}
}
namespace Monolog\Formatter{
use Exception;
class LineFormatter extends NormalizerFormatter
{
    const SIMPLE_FORMAT = "[%datetime%] %channel%.%level_name%: %message% %context% %extra%\n";
    protected $format;
    protected $allowInlineLineBreaks;
    
    public function __construct($format = null, $dateFormat = null, $allowInlineLineBreaks = false)
    {
        $this->format = $format ?: static::SIMPLE_FORMAT;
        $this->allowInlineLineBreaks = $allowInlineLineBreaks;
        parent::__construct($dateFormat);
    }
    
    public function format(array $record)
    {
        $vars = parent::format($record);
        $output = $this->format;
        foreach ($vars['extra'] as $var => $val) {
            if (false !== strpos($output, '%extra.'.$var.'%')) {
                $output = str_replace('%extra.'.$var.'%', $this->replaceNewlines($this->convertToString($val)), $output);
                unset($vars['extra'][$var]);
            }
        }
        foreach ($vars as $var => $val) {
            if (false !== strpos($output, '%'.$var.'%')) {
                $output = str_replace('%'.$var.'%', $this->replaceNewlines($this->convertToString($val)), $output);
            }
        }
        return $output;
    }
    public function formatBatch(array $records)
    {
        $message = '';
        foreach ($records as $record) {
            $message .= $this->format($record);
        }
        return $message;
    }
    protected function normalizeException(Exception $e)
    {
        $previousText = '';
        if ($previous = $e->getPrevious()) {
            do {
                $previousText .= ', '.get_class($previous).': '.$previous->getMessage().' at '.$previous->getFile().':'.$previous->getLine();
            } while ($previous = $previous->getPrevious());
        }
        return '[object] ('.get_class($e).': '.$e->getMessage().' at '.$e->getFile().':'.$e->getLine().$previousText.')';
    }
    protected function convertToString($data)
    {
        if (null === $data || is_bool($data)) {
            return var_export($data, true);
        }
        if (is_scalar($data)) {
            return (string) $data;
        }
        if (version_compare(PHP_VERSION, '5.4.0', '>=')) {
            return $this->toJson($data, true);
        }
        return str_replace('\\/', '/', @json_encode($data));
    }
    protected function replaceNewlines($str)
    {
        if ($this->allowInlineLineBreaks) {
            return $str;
        }
        return preg_replace('{[\r\n]+}', ' ', $str);
    }
}
}
namespace Monolog\Handler{
use Monolog\Formatter\FormatterInterface;
interface HandlerInterface
{
    
    public function isHandling(array $record);
    
    public function handle(array $record);
    
    public function handleBatch(array $records);
    
    public function pushProcessor($callback);
    
    public function popProcessor();
    
    public function setFormatter(FormatterInterface $formatter);
    
    public function getFormatter();
}
}
namespace Monolog\Handler{
use Monolog\Logger;
use Monolog\Formatter\FormatterInterface;
use Monolog\Formatter\LineFormatter;
abstract class AbstractHandler implements HandlerInterface
{
    protected $level = Logger::DEBUG;
    protected $bubble = true;
    
    protected $formatter;
    protected $processors = array();
    
    public function __construct($level = Logger::DEBUG, $bubble = true)
    {
        $this->level = $level;
        $this->bubble = $bubble;
    }
    
    public function isHandling(array $record)
    {
        return $record['level'] >= $this->level;
    }
    
    public function handleBatch(array $records)
    {
        foreach ($records as $record) {
            $this->handle($record);
        }
    }
    
    public function close()
    {
    }
    
    public function pushProcessor($callback)
    {
        if (!is_callable($callback)) {
            throw new \InvalidArgumentException('Processors must be valid callables (callback or object with an __invoke method), '.var_export($callback, true).' given');
        }
        array_unshift($this->processors, $callback);
        return $this;
    }
    
    public function popProcessor()
    {
        if (!$this->processors) {
            throw new \LogicException('You tried to pop from an empty processor stack.');
        }
        return array_shift($this->processors);
    }
    
    public function setFormatter(FormatterInterface $formatter)
    {
        $this->formatter = $formatter;
        return $this;
    }
    
    public function getFormatter()
    {
        if (!$this->formatter) {
            $this->formatter = $this->getDefaultFormatter();
        }
        return $this->formatter;
    }
    
    public function setLevel($level)
    {
        $this->level = $level;
        return $this;
    }
    
    public function getLevel()
    {
        return $this->level;
    }
    
    public function setBubble($bubble)
    {
        $this->bubble = $bubble;
        return $this;
    }
    
    public function getBubble()
    {
        return $this->bubble;
    }
    public function __destruct()
    {
        try {
            $this->close();
        } catch (\Exception $e) {
                    }
    }
    
    protected function getDefaultFormatter()
    {
        return new LineFormatter();
    }
}
}
namespace Monolog\Handler{
abstract class AbstractProcessingHandler extends AbstractHandler
{
    
    public function handle(array $record)
    {
        if (!$this->isHandling($record)) {
            return false;
        }
        $record = $this->processRecord($record);
        $record['formatted'] = $this->getFormatter()->format($record);
        $this->write($record);
        return false === $this->bubble;
    }
    
    abstract protected function write(array $record);
    
    protected function processRecord(array $record)
    {
        if ($this->processors) {
            foreach ($this->processors as $processor) {
                $record = call_user_func($processor, $record);
            }
        }
        return $record;
    }
}
}
namespace Monolog\Handler{
use Monolog\Logger;
class StreamHandler extends AbstractProcessingHandler
{
    protected $stream;
    protected $url;
    private $errorMessage;
    protected $filePermission;
    
    public function __construct($stream, $level = Logger::DEBUG, $bubble = true, $filePermission = null)
    {
        parent::__construct($level, $bubble);
        if (is_resource($stream)) {
            $this->stream = $stream;
        } else {
            $this->url = $stream;
        }
        $this->filePermission = $filePermission;
    }
    
    public function close()
    {
        if (is_resource($this->stream)) {
            fclose($this->stream);
        }
        $this->stream = null;
    }
    
    protected function write(array $record)
    {
        if (!is_resource($this->stream)) {
            if (!$this->url) {
                throw new \LogicException('Missing stream url, the stream can not be opened. This may be caused by a premature call to close().');
            }
            $this->errorMessage = null;
            set_error_handler(array($this, 'customErrorHandler'));
            $this->stream = fopen($this->url, 'a');
            if ($this->filePermission !== null) {
                @chmod($this->url, $this->filePermission);
            }
            restore_error_handler();
            if (!is_resource($this->stream)) {
                $this->stream = null;
                throw new \UnexpectedValueException(sprintf('The stream or file "%s" could not be opened: '.$this->errorMessage, $this->url));
            }
        }
        fwrite($this->stream, (string) $record['formatted']);
    }
    private function customErrorHandler($code, $msg)
    {
        $this->errorMessage = preg_replace('{^fopen\(.*?\): }', '', $msg);
    }
}
}
